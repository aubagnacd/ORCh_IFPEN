#include "computeMultipleInlet.h"
#include <fstream>	//Huu-Tri: "read from file" library
#include <iostream>	//Huu-Tri
#include <sys/stat.h> 	//Huu-Tri: Check file exist - stat function - 20 Nov 2019
#include <tensorflow/c/c_api.h> //Huu-Tri@20200723 : Add Tensorflow C API to use trained model from Python Keras

// Huu-Tri@20200724 : Add Tensorflow libraries "cppflow" - Use Tensorflow C-API to load ANN model and predict in C++
// /home/huutri/workdir/orch/ORCh/cppflow
// CppFlow : https://github.com/serizba/cppflow
#include "../cppflow/include/Model.h"
#include "../cppflow/include/Tensor.h"
#include "opencv2/core/core.hpp" // Lib for PCA
#include <numeric>
#include <iomanip>

#include <fstream>// Huu-Tri NGUYEN 20210212 - To read from text file
#include <iostream>
#include <sstream>
#include <string>
using namespace std;



/* EMST model */
extern "C" void emst_(int* mode_emst,int* np_emst,int* nc_emst,double* f_emst,double* state_emst,double* wt_emst,double* omdt_emst,double* fscale_emst,double* cvars_emst,int* info_emst); // EMST mixing model - Edited by Kaidi - Added by Huu-Tri Nguyen 10.12.2019


//---computeMultipleInlet---

computeMultipleInlet::computeMultipleInlet() //Constructeur
{}

double Get_random ()
{
    int random = rand() % 10000;
    double random_number = double(random)/10000.0;
    return random_number;
}

/* Check if file exists */
/* Return true if the file exists */
/* Huu-Tri Nguyen 20 Nov 2019 */
bool file_exists(char *filename)
{
	struct stat buffer;
	return(stat(filename, &buffer) == 0);	//if the file exits, return true
}


/* Print to file - Source term Deterministic */
void SaveToFile_wDeter(double *wDeter_T, double **wDeter_species, int nsp, int nbInlets, int i, double delta_t, vector<Species_ORCh*> listSpecies, int rank)
{
// Print the Deterministic source term to CFD_results/sourceTermDeter_Inlet*.txt

	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{

		// Check if sourceTermDeter_Inlet*.txt file exists at the first step
		// If yes, clear the file content
		if((file_exists("CFD_results/sourceTermDeter_Inlet0.txt") || file_exists("CFD_results/sourceTermDeter_Inlet1.txt")) && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << "CFD_results/sourceTermDeter_Inlet*.txt exists. Clearing file ... " << endl;	
			
			ofstream sourceTermDeter_Inlet0_clear("CFD_results/sourceTermDeter_Inlet0.txt", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			sourceTermDeter_Inlet0_clear.close(); //close the file

			ofstream sourceTermDeter_Inlet1_clear("CFD_results/sourceTermDeter_Inlet1.txt", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			sourceTermDeter_Inlet1_clear.close(); //close the file
	
		}
		

		
		// Inlet 0
		ofstream sourceTermDeter_Inlet0("CFD_results/sourceTermDeter_Inlet0.txt",ios::app); //ios::app = append at the end of the file
		if(sourceTermDeter_Inlet0)
		{
			if(i==0)	//First step: Need to write the headline
			{
				// First line
				sourceTermDeter_Inlet0 << "#1:Time(s)	"; 
				sourceTermDeter_Inlet0 << "2:T	";
				for (int k=0; k<nsp; k++)
				{
					sourceTermDeter_Inlet0 << k+3 << ":" << listSpecies[k]->m_Name << "	";
				}
				sourceTermDeter_Inlet0 << endl;			

				// Data from ORCh
				sourceTermDeter_Inlet0 << i*delta_t << "	";
				sourceTermDeter_Inlet0 << wDeter_T[0] << "	";
				for (int k=0; k<nsp; k++)
				{
					sourceTermDeter_Inlet0 << wDeter_species[0][k] << "	";
				}
				sourceTermDeter_Inlet0 << endl;
			}
			else
			{		
				// Data from ORCh
				sourceTermDeter_Inlet0 << i*delta_t << "	";
				sourceTermDeter_Inlet0 << wDeter_T[0] << "	";
				for (int k=0; k<nsp; k++)
				{
					sourceTermDeter_Inlet0 << wDeter_species[0][k]  << "	";
					}
				sourceTermDeter_Inlet0 << endl;
			}
		}
		else
		{	
			cout << "ERROR: Impossible to write sourceTermDeter_Inlet0.txt" << endl;
			cout << "Please check computeMultipleInlet.cpp" << endl;
		}
	
		sourceTermDeter_Inlet0.close();

		// Inlet 1
		ofstream sourceTermDeter_Inlet1("CFD_results/sourceTermDeter_Inlet1.txt",ios::app); //ios::app = append at the end of the file
		if(sourceTermDeter_Inlet1)
		{
			if(i==0)	//First step: Need to write the headline
			{
				// First line
				sourceTermDeter_Inlet1 << "#1:Time(s)	"; 
				sourceTermDeter_Inlet1 << "2:T	";
				for (int k=0; k<nsp; k++)
				{
					sourceTermDeter_Inlet1 << k+3 << ":" << listSpecies[k]->m_Name << "	";
				}
				sourceTermDeter_Inlet1 << endl;			

				// Data from ORCh
				sourceTermDeter_Inlet1 << i*delta_t << "	";
				sourceTermDeter_Inlet1 << wDeter_T[1] << "	";
				for (int k=0; k<nsp; k++)
				{
					sourceTermDeter_Inlet1 << wDeter_species[1][k] << "	";
				}
				sourceTermDeter_Inlet1 << endl;
			}
			else
			{		
				// Data from ORCh
				sourceTermDeter_Inlet1 << i*delta_t << "	";
				sourceTermDeter_Inlet1 << wDeter_T[1] << "	";
				for (int k=0; k<nsp; k++)
				{
					sourceTermDeter_Inlet1 << wDeter_species[1][k]  << "	";
					}
				sourceTermDeter_Inlet1 << endl;
			}
		}
		else
		{	
			cout << "ERROR: Impossible to write sourceTermDeter_Inlet1.txt" << endl;
			cout << "Please check computeMultipleInlet.cpp" << endl;
		}
	
		sourceTermDeter_Inlet0.close();

	} // End if(rank==0)
} // END SaveToFile_wDeter



// Declare function for ANN - Huu-Tri 20210212
/* flagANN 1/4
bool getFileContent(std::string fileName, std::vector<std::string> &vecOfStrs) // Read from file to vector<string>
{
    // Open the File
    std::ifstream in(fileName.c_str());
    // Check if object is valid
    if(!in)
    {
        std::cerr << "Cannot open the File : "<<fileName<<std::endl;
        return false;
    }
    std::string str;
    // Read the next line from File untill it reaches the end.
    while(std::getline(in, str,',')) // Comma delimited
    {
        // Line contains string of length > 0 then save it in vector
        if(str.size() > 0)
            vecOfStrs.push_back(str);
    }
    //Close The File
    in.close();
    return true;
}

void readFromCommaDelimitedFile_Float(std::string fileName, std::vector<float> &floatVector)   // For "row type seperated by comma" file : Read from file to vector<float>
{
    // Open the File
    std::ifstream in(fileName.c_str());
    // Check if object is valid
    if(!in)
    {
        std::cerr << "Cannot open the File : "<< fileName <<std::endl;
        std::cout << "Cannot open the File : "<< fileName <<std::endl;
    }
    std::string str;
    std::vector<std::string> vecOfStrs;
    // Read the next line from File untill it reaches the end.
    while(std::getline(in, str,',')) // Comma delimited
    {
        // Line contains string of length > 0 then save it in vector
        if(str.size() > 0)
            vecOfStrs.push_back(str);
    }
    
    // Convert string to float
    floatVector.reserve(vecOfStrs.size()); // Secure the size of vector
    std::transform(vecOfStrs.begin(), vecOfStrs.end(), back_inserter(floatVector),
              [](string const& val) {return stod(val);});
    
    //Close The File
    in.close();
    
}

void readFromCommaDelimitedFile_Double(std::string fileName, std::vector<double> &doubleVector)   // For "row type seperated by comma" file : Read from file to vector<double>
{
    // Open the File
    std::ifstream in(fileName.c_str());
    // Check if object is valid
    if(!in)
    {
        std::cerr << "Cannot open the File : "<< fileName <<std::endl;
        std::cout << "Cannot open the File : "<< fileName <<std::endl;
    }
    std::string str;
    std::vector<std::string> vecOfStrs;
    // Read the next line from File untill it reaches the end.
    while(std::getline(in, str,',')) // Comma delimited
    {
        // Line contains string of length > 0 then save it in vector
        if(str.size() > 0)
            vecOfStrs.push_back(str);
    }
    
    // Convert string to float
    doubleVector.reserve(vecOfStrs.size()); // Secure the size of vector
    std::transform(vecOfStrs.begin(), vecOfStrs.end(), back_inserter(doubleVector),
                   [](string const& val) {return stod(val);});
    
    //Close The File
    in.close();
   
}

void advanceANN(std::vector<float> &child_MeanINPUTLoad, std::vector<float> &child_StdINPUTLoad,
                std::vector<float> &child_MeanOUTPUTLoad, std::vector<float> &child_StdOUTPUTLoad,
                std::vector<float> &child_MaxOUTPUTLoad, std::vector<float> &child_MinOUTPUTLoad,
                std::vector<double> &maxAftREACTORLoad, std::vector<double>  &minAftREACTORLoad,
                cv::PCA pcaANN,
                Tensor &inputPCAANNRegLoad, Model &modelANNRegLoad, Tensor &outputStandardizeANNRegLoad,
                double &Tm, std::vector<double> &Ym,
                int &numVarANN, int &nsp,
                std::vector<float> &input_childLocalStandardized, cv::Mat input_childLocalStandardized_Mat,
                cv::Mat inputPCA, std::vector<float> &inputPCA_Vec,
                std::vector<float> &outputStandardizeANN_Vec,
                vector<Species_ORCh*> listSpecies)
{
    // LOCAL INPUT Standardize
    // Standardize T
    input_childLocalStandardized[numVarANN-1] = Tm - child_MeanINPUTLoad[numVarANN-1];
    input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
    // Standardize Y
    for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
    {
        input_childLocalStandardized[kANN] = Ym[kANN] - child_MeanINPUTLoad[kANN];
        input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
        //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
        if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
    }
    
    
    // PCA Transform
    // Load to matrix
    input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
    // Project to LPCA space: inputPCA = input of ANN in LPCA space
    pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
    // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
    if (inputPCA.isContinuous()) // Continuous memory block
    {
        inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
    } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
    
    
    // ANN regression to predict Standardized variation
    // Set input tensor for cppflow (Tensorflow)
    inputPCAANNRegLoad.set_data(inputPCA_Vec);
    // Predict the  Standardized variation - saved as outputANN tensor
    modelANNRegLoad.run(inputPCAANNRegLoad,outputStandardizeANNRegLoad);
    // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
    int kRun=0;
    for (float f : outputStandardizeANNRegLoad.get_data<float>())
    {
        outputStandardizeANN_Vec[kRun] = f;
        kRun++;
    }
    
    // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
    //  X = standardizedX*standardDeviationScale + meanScale
    // T
    outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
    outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
    // Verify if output (Composition space) out-of-bound
    outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
    outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
    // Calculate Temperature and bound on Max Min GLOBAL data
    Tm = Tm + outputStandardizeANN_Vec[numVarANN-1];
    Tm = std::min(std::max(Tm,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
    
    //  Y
    for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
    {
        outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
        outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
        // Verify if output (Composition space) out-of-bound
        outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
        outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
        // Calculate Y and bound on Max Min GLOBAL data
        Ym[kANN] = Ym[kANN] + outputStandardizeANN_Vec[kANN];
        Ym[kANN] = std::min(std::max(Ym[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
        //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
        if(listSpecies[kANN]->m_Name == "N2")
            cout << "Warning : N2 in the ANN!!!" << endl;
    }
}
*/
// END Declare function for ANN - Huu-Tri 20210212


void computeMultipleInlet::getMultipleInlet(
   string mech,
   string mech_desc,
   vector<MultipleInlet*> listInlets,
   vector<bool> Targets,
   bool new_mixing,
   string step,
   vector<vector<vector<double> > > &R_AD_Trajectories,
   vector<vector<double> > &max_j_on_Target,
   vector<vector<vector<double> > > &Ym_Trajectories_store,
   vector<vector<vector<double> > > &Production_Trajectories_ref,
   vector<vector<vector<double> > > &Consumption_Trajectories_ref,
   vector<vector<double> > &T_Trajectories_store,
   vector<double> &time_store,
   vector<bool> &SpeciesIntoReactants)
{

   //Treat parallel stuff
   int rank, nb_processus;

   if (step != "Optimisation")
       {
       MPI_Comm_rank(MPI_COMM_WORLD, &rank);
       MPI_Comm_size(MPI_COMM_WORLD, &nb_processus);
       }
    else
       rank = 0;



   IdealGasMix *mixture  = new IdealGasMix(mech,mech_desc);
   int nsp = mixture->nSpecies();
   int nbInlets = listInlets.size();

   getMixedGasesComposition(mech, mech_desc, listInlets, step);

   

   vector<Species_ORCh*> listSpecies;
   vector<Reaction_ORCh*> listReactions;

   Read *r = new Read();
   r->Read_species(mech, listSpecies);
   r->Read_reactions(mech, listReactions);

   double t = 0.0; //Initial computational time
   int nTot = 0; //Total number of particles

   double Particle_flowRate = 0.001; //elementary mass flow rate
   vector<int> nbParticles (nbInlets, 0); //Number of particles per inlet
   for (int n=0; n<nbInlets; n++)
   {
      nbParticles[n] = listInlets[n]->m_flowRate/Particle_flowRate;
      if (rank == 0)
      {
         cout << "Nb particles  " << n << "  " << nbParticles[n] << endl;
      }
      nTot += nbParticles[n];
   }

	//Huu-Tri - 13.01.2020
	if(rank==0) cout << "nTot = " << nTot << endl;
   int AirPart = ceil(nbParticles[0]*0.4);

   //-----------------------------------------------------------------------------------------------------------------------//
   //   Randomly select the particles that will be mixed or read that into the "Selection.dat" file if new_mixing == false
   //-----------------------------------------------------------------------------------------------------------------------//

   vector<vector<int> > Particle_1;
   vector<vector<int> > Particle_2;

   double delta_t = dynamic_cast <Characteristics_MultipleInlet*> (listInlets[nbInlets-1])->m_delta_t;
   double tau_t = dynamic_cast <Characteristics_MultipleInlet*> (listInlets[nbInlets-1])->m_tau_t;
   int nbLines =  dynamic_cast <Characteristics_MultipleInlet*> (listInlets[nbInlets-1])->m_NbIterations;
	

   // Huu-Tri Nguyen - 20.01.2020
	if(rank==0) cout << "Time step = " << delta_t << " | Iterations = " << nbLines << " | Mixing time = " << tau_t << endl;

   double Pressure =  dynamic_cast <Characteristics_MultipleInlet*> (listInlets[nbInlets-1])->m_Pressure;
   double F =1;

   int Nmix = delta_t*nTot/tau_t;
   if (rank == 0)
      cout << "Nmix " << Nmix << endl;

   if (Nmix < 0) 
   {
      cout << "Problem with the delta_t and tau_t description, Nmix = " << Nmix << endl;
      getchar();
   }

   // by Kaidi@2019.11 - Huu-Tri Nguyen added - 10.12.2019
   if (Nmix*2 > nTot)
   {
      cout << "Problem with the delta_t and tau_t description, Nmix is too large!" << endl;
      getchar();
   }


   //seed the random number generator
   srand(time(NULL));

   if (new_mixing == false || step == "Optimisation_XML" || step == "Optimisation_Analytical")
   {
      ifstream Selection_read("Selection.dat");

      for (int nb=0; nb<nbLines; nb++)
      {
         Particle_1.push_back(vector<int> (Nmix));
         Particle_2.push_back(vector<int> (Nmix));

         double a;
         Selection_read >> a;
         for (int sp=0; sp<Nmix; sp++)
         {
            Selection_read >> Particle_1[nb][sp] >> Particle_2[nb][sp];
         }
      }
      Selection_read.close();
   }
   else
   {
      ofstream Selection("Selection.dat");

      int select;

      for (int nb=0; nb<nbLines; nb++)
      {


         Particle_1.push_back(vector<int> (Nmix));
         Particle_2.push_back(vector<int> (Nmix));

         Selection << nb << "  ";


         for (int sp=0; sp<Nmix; sp++)
         {
            //Select first and second particle to be mixed
            for (int fs=0; fs<2; fs++)
            {
               bool particle_found = false;
               while (!particle_found)
               {
//air dilution add 17/07/17 
       //           if (nb < nbLines/2) // On ne mélange que 60% de l'air entrant avec le reste
       //           {
       //  	     select = rand() % (nTot-AirPart) + AirPart; 
       //                
       //           }
       //           else // on rajoute les particules d'air restantes petit à petit jusqu à la fin
       //           {
       //              float c = nb;
       //              float d = nbLines;
       //              double b = abs(AirPart*(1 - ( 2*( c - d/2 )/d)));
       //              int a = b;

       // 	     select = rand() % (nTot-a) + a;
       // 
       //           }
                 select = rand() % nTot;

                  if (sp == 0 && fs == 0)
                     particle_found = true;
                  if (sp == 0 && fs == 1)
                  {
                     if (select != Particle_1[nb][0])
                        particle_found = true;
                  }

                  //Check that the particle hasn't been used yet

             	  /* Comment to add the edited code from Kaidi - Huu-Tri Nguyen 10.12.2019 */
	//HT	  for (int sp_test=0; sp_test<sp; sp_test++)
        //HT      {
        //HT             if (select != Particle_1[nb][sp_test] && select != Particle_2[nb][sp_test])
        //HT             {
        //HT                particle_found = true;
        //HT             }
        //HT      }
		/* End comment - Huu-Tri Nguyen 10.12.2019 */


		/* Add the corrected code from Kaidi -  Huu-Tri Nguyen 10.12.2019 */
		bool particle_used = false;
                for (int sp_test=0; sp_test<sp; sp_test++)
                {
                	if (select == Particle_1[nb][sp_test] || select == Particle_2[nb][sp_test])
                     	{
                       		particle_used = true;
                     	}
                }
                
		if (fs == 1)
                {
                	if (select == Particle_1[nb][sp])  
				particle_used = true;
                }
                
		if (particle_used)
                	particle_found = false;
                else
                	particle_found = true;
		/* End the corrected code from Kaidi -  Huu-Tri Nguyen 10.12.2019 */

               }

               if (fs == 0)
                  Particle_1[nb][sp] = select;
               else if (fs == 1)
                  Particle_2[nb][sp] = select;
            }
            Selection << Particle_1[nb][sp] << " " << Particle_2[nb][sp] << "   ";
         }
         Selection << endl;

      }
      Selection.close();
   }


   //---Trajectories store---
   vector<double> Hm_Trajectories(nbInlets, 0.0);
   vector<double> Zm_Trajectories(nbInlets, 0.0);
   vector<double> Hm_inletIni(nbInlets, 0.0); // Save initial enthalpy of each inlet - Huu-Tri Nguyen - 16.01.2020

   double *Ym = new double[nsp];
   double Hm = 0.0;
   double Zm = 0.0;
   double Tm = 0.0;
   double density = 0.0;

   //First create the Particles which will transport the gaseous and liquid phases
   vector<Particle*> listParticles;








   double Diameter_init; 
   double tau_vj;
   for (int n=0; n<nbInlets; n++)
   {
      IdealGasMix *InletMixture = new IdealGasMix(mech, mech_desc);
      
      if (listInlets[n]->m_X_Species != "")
      {
         if (rank == 0)
         {
         cout << "Set the mole fraction of inlet " << n << endl;
         }
         InletMixture->setState_TPX(listInlets[n]->m_Temperature, listInlets[n]->m_Pressure, listInlets[n]->m_X_Species);
      }
      else if (listInlets[n]->m_Y_Species != "")
      {
         if (rank == 0)
         {
            cout << "Set the mass fraction of inlet " << n << endl;
         }
         InletMixture->setState_TPY(listInlets[n]->m_Temperature, listInlets[n]->m_Pressure, listInlets[n]->m_Y_Species);
      }

      InletMixture->getMassFractions(Ym);
      Hm  = InletMixture->enthalpy_mass();
      vector<double> Y_transfer (nsp, 0.0);
      for (int k=0; k<nsp; k++)
         Y_transfer[k] = Ym[k];
      density = InletMixture->density();

      for (int k=0; k<nsp; k++)
      {
         if (Ym[k] > 0.0)
         {
            SpeciesIntoReactants[k] = true;
         }
      }

      
	Hm_inletIni[n] = Hm; // Save initial enthalpy of each inlet - Huu-Tri Nguyen - 16.01.2020
	if(rank ==0) cout << "Hm initial inlet " << n << " = " << Hm_inletIni[n] << endl;

      if (n < nbInlets-1)  
      {
         //Composition space Lagrangian trajectories
         for (int k=0; k<nsp; k++)
            Ym_Trajectories_store[n][0][k] = Y_transfer[k];
 
         Hm_Trajectories[n] = Hm;
         T_Trajectories_store[n][0] = listInlets[n]->m_Temperature;

      }
	
      

      for (int i=0; i<nbParticles[n]; i++)
      {
         if (listInlets[n]->m_liquid)
         {
            double nbDroplets = Particle_flowRate/(listInlets[n]->m_density_liquid*(PI/6)*pow(listInlets[n]->m_DropletsDiameter,3.0));
            listParticles.push_back(new Particle(
                           Y_transfer, 
                           listInlets[n]->m_Temperature, 
                           Hm, 
                           1, 
                           0.0, 
                           nbDroplets, 
                           listInlets[n]->m_DropletsDiameter, 
                           0.001 /*0% gas, 100% liquid*/, 
			   Y_transfer, 
                           listInlets[n]->m_density_liquid, 
                           listInlets[n]->m_EvaporationLatentHeat));

            Diameter_init = listInlets[n]->m_DropletsDiameter;
            tau_vj = listInlets[n]->m_Tau_vj;
         }
         else
         {
            listParticles.push_back(new Particle(
                           Y_transfer, 
                           listInlets[n]->m_Temperature, 
                           Hm, 
                           0, 
                           density, 
                           0, 
                           0.0, 
                           1.0 /*100% gas, 0% liquid*/, 
                           vector<double> (nsp, 0.0), 
                           0.0, 
                           0.0));
         }
      }
   }





   //Table with the sensible enthalpy of species i at Tboiling
   vector<double> BoilingEnthalpy (nsp, 0.0);
   for (int k=0; k<nsp; k++)
   {
      IdealGasMix *InletMixture = new IdealGasMix(mech, mech_desc);
      double *Ym = new double[nsp];
      for (int kbis=0; kbis<nsp; kbis++)
      {
         if (k != kbis)
            Ym[kbis] = 0;
         else
            Ym[kbis] = 1;
      }
      InletMixture->setState_TPY(listInlets[1]->m_Temperature, listInlets[1]->m_Pressure, Ym);
      BoilingEnthalpy[k] = InletMixture->enthalpy_mass();
   }





   double dt = dynamic_cast <Characteristics_MultipleInlet*> (listInlets[nbInlets-1])->m_delta_t;
   double gas_mass_p1;
   double gas_mass_p2;
   double Total_gas_mass;


   vector<double> Mean_Ym(nsp, 0.0);
   double Mean_Hm = 0.0;
   double Mean_Zm = 0.0;
   double Mean_Tm = 0.0;
	
   // Data for scatterplot
   // ofstream store ("outputs/data.dat"); // Store mean values
   // ofstream store_particles ("data_particles.dat");	// Store scatterplot
   // store_particles << "#1:time  2:Particle_number  3:Zfraction  4:T(K) 5:Y_CO2 6:Y_O2 7:particle type  8:ratio  9:Zst " << endl;
	

   /* Add EMST model initialization - Huu-Tri Nguyen - 10.12.2019 */
   // EMST mixing model initialization -- by Kaidi@2019.12
   int mode_emst = 1;		// 1:-the state variables of all particles are initialized. No mixing is performed (check emst.f)
   int np_emst = nTot;		// np_emst: number of particles
   int nc_emst = nsp+1;		// nc_emst: number of compositions variables (+1 to add Enthalpy at the end of array)
   double *f_emst = new double[np_emst*nc_emst];	// Particle composition
   double *state_emst = new double[np_emst];		// State (or age) variable
   double *wt_emst = new double[np_emst];		// Particle weights. wt(i)>0 is the numerical weight of the i-th particle
   double *fscale_emst = new double[nc_emst];		// Scale factors for the compositions (fscale(j)>0) - see explanation in emst.f
   double cvars_emst[6] = {0,0,0,0,0,0};		// Control variables for expert users. cvars_emst[6] = {0,0,0,0,0,0} is default
   int info_emst = 0;					// = 0 for successful execution; < 0 for error in input
   int i_emst;
   double Cphi = 2; 					// Mixing model constant, see explanation in emst.f
   double omdt_emst = delta_t/tau_t*Cphi;		// Normalized mixing time 
	if(rank ==0) cout << "omdt = " << omdt_emst << endl;
   i_emst = 0;
   for (int ic=0; ic<nc_emst; ic++)	// ic: running variable for number of composition nc_emst
   {
      for (int ip=0; ip<np_emst; ip++)	// ik: running variable for number of particle np_emst
      {
         if (ic<nsp)  
		f_emst[i_emst] = listParticles[ip]->m_Yk_gas[ic];
         else         
		f_emst[i_emst] = listParticles[ip]->m_H_gas;		// Ad enthalpy in the end of array to calculate
         i_emst++;
      }
   }

   for (int ip=0; ip<np_emst; ip++)
   {
      state_emst[ip] = 0;
      wt_emst[ip] = 1.0;
   }

   for (int ic=0; ic<nc_emst; ic++)
   {
      if (ic<nsp)   fscale_emst[ic] = 0.1;	// Intialization values - recommended by emst.f
      else          fscale_emst[ic] = 1e16;
   }

   emst_(&mode_emst,&np_emst,&nc_emst,f_emst,state_emst,wt_emst,&omdt_emst,fscale_emst,cvars_emst,&info_emst);
   if (info_emst != 0)
   {
      cout << "emst initialization failed" << endl;
      getchar();
   }
   /* END Add EMST model initialization - Huu-Tri Nguyen - 10.12.2019 */

   int ndil = 0;

    // ============================================================================
    // Declare flagANN parameters before loop- Huu-Tri Nguyen - 20210206 =========
    // ============================================================================

/* flagANN 2/4
    
    int numVarANN = 11; // CasKaidi: 10 species (remove N2),  T (remove H)
    //int numParentCluster = 2; // Number of cluster
    //vector<int> numChildCluster = {14,6}; // parentCluster0 has 14 child clusters
    int numComponentPCA = 11;   // Global number of components of each cluster
    if(rank==0)
    {
        cout << "Number of variables: " << numVarANN;
        cout << "| Number of components: " << numComponentPCA;
        cout << endl;
    }
    
    // Overall case path
    std::string casePath = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/";
    
    //Declare GLOBAL Standardize for K-means (or ANN Classifier): standardizedX = (X - meanScale) / standardDeviationScale
    std::string GLOBAL_meanScalePATH = casePath + "0.treatedFile/scalerGlobal_OnlyMean.txt";
    vector<float> GLOBAL_meanScale;
    readFromCommaDelimitedFile_Float(GLOBAL_meanScalePATH, GLOBAL_meanScale); // readFromCommaDelimitedFile_Float(path, vectorFloat)
    
    std::string GLOBAL_stdScalePATH = casePath + "0.treatedFile/scalerGlobal_OnlyStandardDeviation.txt";
    vector<float> GLOBAL_stdScale;
    readFromCommaDelimitedFile_Float(GLOBAL_stdScalePATH, GLOBAL_stdScale);
    
    
    // Declare Max Min Label after REACTOR (maxAftREACTOR Y,T not Var) of each child/grandChild cluster (who have ANNReg)
    // Child of parent 0
    std::string child0_0_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_0.txt";
    std::string child0_0_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_0.txt";
    vector<double> child0_0_maxVal;
    vector<double> child0_0_minVal;
    readFromCommaDelimitedFile_Double(child0_0_maxValPATH, child0_0_maxVal);
    readFromCommaDelimitedFile_Double(child0_0_minValPATH, child0_0_minVal);
    
    std::string child0_1_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_1.txt";
    std::string child0_1_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_1.txt";
    vector<double> child0_1_maxVal;
    vector<double> child0_1_minVal;
    readFromCommaDelimitedFile_Double(child0_1_maxValPATH, child0_1_maxVal);
    readFromCommaDelimitedFile_Double(child0_1_minValPATH, child0_1_minVal);
    
    std::string child0_2_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_2.txt";
    std::string child0_2_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_2.txt";
    vector<double> child0_2_maxVal;
    vector<double> child0_2_minVal;
    readFromCommaDelimitedFile_Double(child0_2_maxValPATH, child0_2_maxVal);
    readFromCommaDelimitedFile_Double(child0_2_minValPATH, child0_2_minVal);
    
    std::string child0_3_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_3.txt";
    std::string child0_3_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_3.txt";
    vector<double> child0_3_maxVal;
    vector<double> child0_3_minVal;
    readFromCommaDelimitedFile_Double(child0_3_maxValPATH, child0_3_maxVal);
    readFromCommaDelimitedFile_Double(child0_3_minValPATH, child0_3_minVal);
    
    std::string child0_4_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_4.txt";
    std::string child0_4_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_4.txt";
    vector<double> child0_4_maxVal;
    vector<double> child0_4_minVal;
    readFromCommaDelimitedFile_Double(child0_4_maxValPATH, child0_4_maxVal);
    readFromCommaDelimitedFile_Double(child0_4_minValPATH, child0_4_minVal);
    
    std::string child0_5_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_5.txt";
    std::string child0_5_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_5.txt";
    vector<double> child0_5_maxVal;
    vector<double> child0_5_minVal;
    readFromCommaDelimitedFile_Double(child0_5_maxValPATH, child0_5_maxVal);
    readFromCommaDelimitedFile_Double(child0_5_minValPATH, child0_5_minVal);
    
    std::string child0_6_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_6.txt";
    std::string child0_6_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_6.txt";
    vector<double> child0_6_maxVal;
    vector<double> child0_6_minVal;
    readFromCommaDelimitedFile_Double(child0_6_maxValPATH, child0_6_maxVal);
    readFromCommaDelimitedFile_Double(child0_6_minValPATH, child0_6_minVal);
    
    std::string child0_7_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_7.txt";
    std::string child0_7_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_7.txt";
    vector<double> child0_7_maxVal;
    vector<double> child0_7_minVal;
    readFromCommaDelimitedFile_Double(child0_7_maxValPATH, child0_7_maxVal);
    readFromCommaDelimitedFile_Double(child0_7_minValPATH, child0_7_minVal);
    
    std::string child0_8_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_8.txt";
    std::string child0_8_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_8.txt";
    vector<double> child0_8_maxVal;
    vector<double> child0_8_minVal;
    readFromCommaDelimitedFile_Double(child0_8_maxValPATH, child0_8_maxVal);
    readFromCommaDelimitedFile_Double(child0_8_minValPATH, child0_8_minVal);
    
    std::string child0_9_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_9.txt";
    std::string child0_9_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_9.txt";
    vector<double> child0_9_maxVal;
    vector<double> child0_9_minVal;
    readFromCommaDelimitedFile_Double(child0_9_maxValPATH, child0_9_maxVal);
    readFromCommaDelimitedFile_Double(child0_9_minValPATH, child0_9_minVal);
    
    std::string child0_10_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_10.txt";
    std::string child0_10_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_10.txt";
    vector<double> child0_10_maxVal;
    vector<double> child0_10_minVal;
    readFromCommaDelimitedFile_Double(child0_10_maxValPATH, child0_10_maxVal);
    readFromCommaDelimitedFile_Double(child0_10_minValPATH, child0_10_minVal);
    
    std::string child0_11_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_11.txt";
    std::string child0_11_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_11.txt";
    vector<double> child0_11_maxVal;
    vector<double> child0_11_minVal;
    readFromCommaDelimitedFile_Double(child0_11_maxValPATH, child0_11_maxVal);
    readFromCommaDelimitedFile_Double(child0_11_minValPATH, child0_11_minVal);
    
    std::string child0_12_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_12.txt";
    std::string child0_12_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_12.txt";
    vector<double> child0_12_maxVal;
    vector<double> child0_12_minVal;
    readFromCommaDelimitedFile_Double(child0_12_maxValPATH, child0_12_maxVal);
    readFromCommaDelimitedFile_Double(child0_12_minValPATH, child0_12_minVal);
    
    std::string child0_13_maxValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMax_cluster0_13.txt";
    std::string child0_13_minValPATH = casePath + "0.treatedFile/parentCluster0/label_OnlyMin_cluster0_13.txt";
    vector<double> child0_13_maxVal;
    vector<double> child0_13_minVal;
    readFromCommaDelimitedFile_Double(child0_13_maxValPATH, child0_13_maxVal);
    readFromCommaDelimitedFile_Double(child0_13_minValPATH, child0_13_minVal);

    // grandChild of parent 1
    // grandChild of child1_0
    vector<double> grandChild1_0_0_maxVal = {1.965170000000000024e-04,1.809009999999999947e-04,1.840320000000000150e-02,2.912420000000000009e-01,1.695590000000000291e-02,2.889330000000000023e-02,5.276630000000000334e-05,9.227889999999998863e-07,1.400430000000000008e-01,4.797089999999999965e-01,3.039380000000000109e+03};
    vector<double> grandChild1_0_0_minVal = {1.412279999999999970e-04,1.346519999999999976e-04,1.686909999999999799e-02,2.338599999999999846e-01,1.564710000000000059e-02,2.661919999999999911e-02,4.555520000000002083e-05,7.371970000000000333e-07,1.047319999999999918e-01,4.658180000000000098e-01,2.963469999999999800e+03};
    
    vector<double> grandChild1_0_1_maxVal = {2.592490000000000246e-04,2.254390000000000213e-04,1.786659999999999984e-02,2.054749999999999910e-01,1.775879999999999820e-02,3.114399999999999807e-02,4.852359999999999735e-05,9.281950000000000341e-07,1.737569999999999948e-01,4.859680000000000111e-01,3.083730000000000018e+03};
    vector<double> grandChild1_0_1_minVal = {2.274190000000000532e-04,1.950209999999999748e-04,1.663910000000000042e-02,1.810799999999999910e-01,1.712649999999999936e-02,3.005940000000000001e-02,4.466479999999998612e-05,8.576000000000001619e-07,1.557589999999999808e-01,4.806000000000000272e-01,3.053219999999999800e+03};
    
    vector<double> grandChild1_0_2_maxVal = {1.355460000000000063e-04,1.294029999999999942e-04,1.706540000000000140e-02,3.174280000000000435e-01,1.537209999999999965e-02,2.666600000000000220e-02,5.341430000000000120e-05,8.859279999999999905e-07,1.021330000000000016e-01,4.730109999999999593e-01,2.992639999999999873e+03};
    vector<double> grandChild1_0_2_minVal = {1.141420000000000059e-04,1.055339999999999962e-04,1.536989999999999884e-02,2.920599999999999863e-01,1.463010000000000352e-02,2.580109999999999695e-02,4.837479999999999634e-05,7.746319999999999976e-07,8.621280000000000610e-02,4.628489999999999549e-01,2.954690000000000055e+03};
    
    vector<double> grandChild1_0_3_maxVal = {5.047629999999999782e-04,3.573340000000000045e-04,1.461109999999999666e-02,1.024549999999999905e-01,1.732279999999999931e-02,3.676740000000000563e-02,3.201150000000000344e-05,7.884229999999998331e-07,2.761409999999999698e-01,4.732739999999999725e-01,3.110190000000000055e+03};
    vector<double> grandChild1_0_3_minVal = {4.400380000000000177e-04,3.091659999999999873e-04,1.256210000000000139e-02,8.274689999999999823e-02,1.656240000000000143e-02,3.535220000000000029e-02,2.724160000000000020e-05,6.573760000000000229e-07,2.521130000000000315e-01,4.606649999999999912e-01,3.063909999999999854e+03};
    
    vector<double> grandChild1_0_4_maxVal = {8.673570000000000238e-04,8.296210000000000043e-04,2.242290000000000255e-02,5.516290000000000360e-01,7.620820000000000372e-03,3.713000000000000328e-02,2.663259999999999976e-04,4.680390000000000262e-06,4.770149999999999668e-01,2.242630000000000179e-01,1.821960000000000036e+03};
    vector<double> grandChild1_0_4_minVal = {1.126260000000000022e-04,1.312320000000000066e-04,1.248690000000000043e-02,1.920719999999999927e-01,4.315189999999999998e-03,2.112859999999999738e-02,1.710899999999999899e-04,2.175609999999999826e-06,1.420279999999999876e-01,1.484779999999999989e-01,1.636109999999999900e+03};
    
    vector<double> grandChild1_0_5_maxVal = {5.471630000000000330e-04,7.401919999999999767e-04,2.924320000000000044e-02,2.438610000000000222e-01,1.768420000000000061e-02,3.235860000000000125e-02,3.352709999999999957e-05,4.511339999999999950e-07,2.808579999999999965e-01,4.429310000000000191e-01,2.796889999999999873e+03};
    vector<double> grandChild1_0_5_minVal = {2.867340000000000231e-04,3.469509999999999652e-04,2.135740000000000208e-02,1.206769999999999926e-01,1.621600000000000125e-02,2.659349999999999908e-02,2.256940000000000113e-05,3.859910000000000052e-07,1.791739999999999999e-01,4.014429999999999943e-01,2.530889999999999873e+03};
    
    vector<double> grandChild1_0_6_maxVal = {3.667359999999999934e-04,2.917240000000000414e-04,1.692619999999999889e-02,1.515299999999999980e-01,1.793509999999999896e-02,3.390909999999999758e-02,4.117319999999999400e-05,8.850500000000000008e-07,2.240099999999999869e-01,4.838330000000000131e-01,3.105719999999999800e+03};
    vector<double> grandChild1_0_6_minVal = {3.155440000000000133e-04,2.507359999999999927e-04,1.525790000000000132e-02,1.280260000000000009e-01,1.747770000000000226e-02,3.261159999999999753e-02,3.666059999999999930e-05,7.840249999999999812e-07,2.002190000000000081e-01,4.752939999999999388e-01,3.070539999999999964e+03};
    
    vector<double> grandChild1_0_7_maxVal = {2.076070000000000064e-04,1.885420000000000119e-04,1.807409999999999919e-02,2.406300000000000106e-01,1.719449999999999798e-02,2.969859999999999861e-02,5.123359999999999682e-05,9.286180000000000637e-07,1.463969999999999994e-01,4.849209999999999909e-01,3.059789999999999964e+03};
    vector<double> grandChild1_0_7_minVal = {1.853129999999999925e-04,1.671920000000000079e-04,1.674009999999999734e-02,2.133860000000000201e-01,1.660209999999999811e-02,2.859689999999999802e-02,4.731370000000000069e-05,8.331979999999999677e-07,1.324730000000000074e-01,4.766479999999999606e-01,3.023929999999999836e+03};
    
    vector<double> grandChild1_0_8_maxVal = {1.217399999999999965e-04,1.158539999999999923e-04,1.645349999999999938e-02,3.321979999999999933e-01,1.489610000000000066e-02,2.615239999999999926e-02,5.332510000000000212e-05,8.714979999999999864e-07,9.245189999999998964e-02,4.694710000000000272e-01,2.978340000000000146e+03};
    vector<double> grandChild1_0_8_minVal = {1.036450000000000012e-04,9.558620000000000311e-05,1.492030000000000092e-02,3.070169999999999844e-01,1.416489999999999937e-02,2.529559999999999795e-02,4.905919999999999948e-05,7.650100000000000455e-07,7.873960000000000681e-02,4.592169999999999863e-01,2.940210000000000036e+03};
    
    vector<double> grandChild1_0_9_maxVal = {2.522250000000000186e-04,2.906930000000000169e-04,2.331620000000000220e-02,3.549329999999999985e-01,1.717209999999999917e-02,2.878480000000000621e-02,4.020640000000000184e-05,5.824439999999999710e-07,1.696499999999999952e-01,4.574079999999999813e-01,2.892079999999999927e+03};
    vector<double> grandChild1_0_9_minVal = {1.088339999999999951e-04,1.173800000000000044e-04,1.774259999999999726e-02,2.276530000000000220e-01,1.392320000000000016e-02,2.402320000000000150e-02,3.060469999999999516e-05,3.897420000000001027e-07,8.205419999999999381e-02,4.203879999999999839e-01,2.676260000000000218e+03};
    
    vector<double> grandChild1_0_10_maxVal = {1.525370000000000068e-03,1.153380000000000074e-03,1.763800000000000090e-02,4.870890000000001052e-01,6.370869999999999832e-03,3.548890000000000378e-02,2.774739999999999932e-04,5.906929999999999703e-06,5.431239999999999402e-01,1.900380000000000125e-01,1.711910000000000082e+03};
    vector<double> grandChild1_0_10_minVal = {2.589399999999999840e-04,2.102590000000000210e-04,1.161929999999999907e-02,1.167979999999999990e-01,4.872439999999999584e-03,2.437080000000000149e-02,1.340760000000000085e-04,3.615609999999999591e-06,2.156369999999999953e-01,1.421140000000000181e-01,1.603759999999999991e+03};
    
    vector<double> grandChild1_0_11_maxVal = {1.667490000000000530e-04,1.494649999999999928e-04,1.697749999999999954e-02,2.659389999999999810e-01,1.627879999999999952e-02,2.829370000000000149e-02,5.241939999999999485e-05,9.153350000000000632e-07,1.202720000000000039e-01,4.812600000000000211e-01,3.030179999999999836e+03};
    vector<double> grandChild1_0_11_minVal = {1.555299999999999966e-04,1.413449999999999960e-04,1.637989999999999932e-02,2.478179999999999827e-01,1.591800000000000159e-02,2.764350000000000140e-02,5.063239999999999993e-05,8.974500000000001912e-07,1.137789999999999913e-01,4.773470000000000213e-01,3.020079999999999927e+03};
    
    vector<double> grandChild1_0_12_maxVal = {1.010060000000000016e-04,9.652889999999998986e-05,1.553079999999999912e-02,3.638270000000000115e-01,1.393759999999999964e-02,2.508109999999999853e-02,5.255709999999999863e-05,8.351860000000002102e-07,7.791770000000000640e-02,4.605189999999999562e-01,2.944619999999999891e+03};
    vector<double> grandChild1_0_12_minVal = {8.333680000000000482e-05,7.583630000000000438e-05,1.373339999999999977e-02,3.397959999999999869e-01,1.307020000000000057e-02,2.428999999999999909e-02,4.539310000000000420e-05,6.688560000000000171e-07,6.382590000000000485e-02,4.475550000000000361e-01,2.886630000000000109e+03};
    
    vector<double> grandChild1_0_13_maxVal = {1.452720000000000010e-04,1.385269999999999969e-04,1.736129999999999965e-02,3.029830000000000023e-01,1.569989999999999927e-02,2.715159999999999796e-02,5.337890000000001167e-05,8.971490000000000352e-07,1.087819999999999898e-01,4.759390000000001120e-01,3.004769999999999982e+03};
    vector<double> grandChild1_0_13_minVal = {1.251299999999999895e-04,1.155899999999999961e-04,1.573690000000000158e-02,2.783570000000000211e-01,1.503919999999999910e-02,2.628509999999999874e-02,4.759949999999999717e-05,7.660219999999998166e-07,9.378190000000000137e-02,4.654930000000001011e-01,2.964739999999999782e+03};
    
    vector<double> grandChild1_0_14_maxVal = {8.426300000000000283e-04,1.238640000000000053e-03,2.795629999999999990e-02,4.624260000000000037e-01,9.848370000000000388e-03,3.883400000000000046e-02,1.826300000000000048e-04,2.664780000000000175e-06,5.061359999999999193e-01,2.783749999999999836e-01,1.985720000000000027e+03};
    vector<double> grandChild1_0_14_minVal = {1.341970000000000164e-04,2.232129999999999921e-04,1.738540000000000224e-02,1.117920000000000025e-01,5.894520000000000315e-03,2.431320000000000009e-02,8.891219999999999213e-05,1.292599999999999915e-06,1.782619999999999760e-01,1.847560000000000036e-01,1.769980000000000018e+03};
    
    vector<double> grandChild1_0_15_maxVal = {4.084030000000001622e-04,3.177959999999999639e-04,1.625060000000000046e-02,1.340679999999999927e-01,1.784399999999999875e-02,3.484539999999999860e-02,3.827049999999999891e-05,8.585869999999999841e-07,2.410909999999999720e-01,4.812550000000000439e-01,3.108880000000000109e+03};
    vector<double> grandChild1_0_15_minVal = {3.536659999999999847e-04,2.710430000000000001e-04,1.447170000000000054e-02,1.119359999999999938e-01,1.729270000000000113e-02,3.353630000000000499e-02,3.318180000000000137e-05,7.212609999999999626e-07,2.173179999999999834e-01,4.696329999999999671e-01,3.061599999999999909e+03};
    
    vector<double> grandChild1_0_16_maxVal = {5.553490000000000119e-04,3.794190000000000344e-04,1.372829999999999884e-02,8.869199999999999307e-02,1.690849999999999992e-02,3.777599999999999708e-02,2.874449999999999897e-05,7.455020000000001596e-07,2.926030000000000020e-01,4.678319999999999701e-01,3.108289999999999964e+03};
    vector<double> grandChild1_0_16_minVal = {4.900840000000000057e-04,3.264289999999999878e-04,1.135659999999999968e-02,6.883689999999999254e-02,1.594729999999999759e-02,3.619919999999999388e-02,2.453369999999999856e-05,5.910300000000000189e-07,2.700770000000000115e-01,4.533880000000000132e-01,3.037829999999999927e+03};
    
    vector<double> grandChild1_0_17_maxVal = {1.664209999999999951e-03,1.130340000000000077e-03,2.054879999999999901e-02,5.097859999999999614e-01,7.518399999999999736e-03,3.625319999999999931e-02,2.706879999999999942e-04,5.452759999999999442e-06,5.519859999999999767e-01,2.170710000000000139e-01,1.801799999999999955e+03};
    vector<double> grandChild1_0_17_minVal = {2.018099999999999939e-04,1.790590000000000215e-04,1.044699999999999969e-02,1.324649999999999994e-01,4.617529999999999898e-03,2.336699999999999888e-02,1.265010000000000006e-04,2.566279999999999763e-06,1.918650000000000078e-01,1.366999999999999882e-01,1.597849999999999909e+03};
    
    vector<double> grandChild1_0_18_maxVal = {2.911820000000000185e-04,2.504620000000000153e-04,1.772209999999999758e-02,1.870040000000000036e-01,1.789649999999999921e-02,3.201580000000000398e-02,4.633949999999999907e-05,9.194209999999999847e-07,1.897380000000000178e-01,4.859510000000000218e-01,3.092940000000000055e+03};
    vector<double> grandChild1_0_18_minVal = {2.524299999999999938e-04,2.121120000000000048e-04,1.635320000000000176e-02,1.634180000000000077e-01,1.733890000000000084e-02,3.090559999999999835e-02,4.164590000000000051e-05,8.153109999999998287e-07,1.691459999999999908e-01,4.783010000000000317e-01,3.058030000000000200e+03};
    
    vector<double> grandChild1_0_19_maxVal = {1.770509999999999825e-04,1.577760000000000154e-04,1.722859999999999669e-02,2.565909999999999580e-01,1.652150000000000146e-02,2.867509999999999851e-02,5.195329999999999604e-05,9.213559999999999290e-07,1.266089999999999993e-01,4.825529999999999542e-01,3.037619999999999891e+03};
    vector<double> grandChild1_0_19_minVal = {1.637449999999999984e-04,1.484939999999999915e-04,1.650959999999999581e-02,2.381429999999999936e-01,1.612989999999999910e-02,2.799240000000000408e-02,5.013920000000000269e-05,9.022119999999999264e-07,1.189199999999999979e-01,4.789359999999999729e-01,3.027570000000000164e+03};
    
    vector<double> grandChild1_0_20_maxVal = {2.300030000000000000e-04,2.045729999999999944e-04,1.799540000000000167e-02,2.251969999999999805e-01,1.750530000000000141e-02,3.037239999999999732e-02,5.006829999999999630e-05,9.306499999999999326e-07,1.586200000000000110e-01,4.857170000000000099e-01,3.071019999999999982e+03};
    vector<double> grandChild1_0_20_minVal = {2.047920000000000003e-04,1.798390000000000242e-04,1.678790000000000143e-02,1.979499999999999871e-01,1.686709999999999945e-02,2.920769999999999963e-02,4.659030000000000013e-05,8.529640000000001990e-07,1.438959999999999961e-01,4.785569999999999546e-01,3.036670000000000073e+03};
    
    vector<double> grandChild1_0_21_maxVal = {5.153539999999999857e-04,5.263999999999998932e-04,2.392450000000000132e-02,2.346659999999999857e-01,1.793540000000000065e-02,3.416269999999999724e-02,3.479719999999999949e-05,6.033449999999999806e-07,2.775500000000000189e-01,4.657789999999999986e-01,2.975730000000000018e+03};
    vector<double> grandChild1_0_21_minVal = {2.407309999999999962e-04,2.540059999999999801e-04,1.763529999999999959e-02,1.056609999999999910e-01,1.694419999999999954e-02,2.792719999999999925e-02,2.232040000000000063e-05,3.903840000000000366e-07,1.619279999999999886e-01,4.266020000000000367e-01,2.771070000000000164e+03};
    
    vector<double> grandChild1_0_22_maxVal = {1.501630000000000055e-04,1.386810000000000093e-04,1.719520000000000076e-02,2.897570000000000423e-01,1.594049999999999981e-02,2.757970000000000213e-02,5.311289999999999761e-05,9.065080000000000332e-07,1.108740000000000003e-01,4.782020000000000159e-01,3.016199999999999818e+03};
    vector<double> grandChild1_0_22_minVal = {1.364100000000000035e-04,1.250989999999999893e-04,1.601770000000000277e-02,2.666189999999999949e-01,1.539109999999999957e-02,2.677189999999999778e-02,4.927290000000000050e-05,8.090989999999999846e-07,1.014130000000000031e-01,4.691760000000000375e-01,2.983170000000000073e+03};
    
    vector<double> grandChild1_0_23_maxVal = {5.402879999999999879e-04,4.483980000000000257e-04,1.815850000000000103e-02,1.382019999999999915e-01,1.779550000000000229e-02,3.654519999999999991e-02,3.251370000000000009e-05,7.072470000000000067e-07,2.876849999999999685e-01,4.688169999999999837e-01,3.076420000000000073e+03};
    vector<double> grandChild1_0_23_minVal = {3.909859999999999594e-04,3.192480000000000036e-04,1.349189999999999764e-02,8.111039999999999917e-02,1.663859999999999992e-02,3.298510000000000331e-02,2.273670000000000205e-05,4.389709999999999938e-07,2.357889999999999986e-01,4.387109999999999621e-01,2.893719999999999800e+03};
    
    vector<double> grandChild1_0_24_maxVal = {1.551970000000000118e-04,1.573049999999999991e-04,1.883020000000000180e-02,3.668099999999999694e-01,1.588960000000000025e-02,2.709940000000000265e-02,4.946590000000000356e-05,7.794639999999999710e-07,1.157249999999999945e-01,4.666899999999999382e-01,2.966969999999999800e+03};
    vector<double> grandChild1_0_24_minVal = {9.011309999999998939e-05,8.851610000000001129e-05,1.530339999999999999e-02,2.795380000000000087e-01,1.329229999999999995e-02,2.404890000000000153e-02,3.685890000000000043e-05,4.985260000000000530e-07,6.911489999999999301e-02,4.363159999999999816e-01,2.808300000000000182e+03};
    
    vector<double> grandChild1_0_25_maxVal = {1.810549999999999963e-03,1.298160000000000026e-03,2.256770000000000304e-02,2.248639999999999806e-01,8.337330000000000435e-03,3.870450000000000279e-02,1.952440000000000165e-04,4.881310000000000026e-06,5.849340000000000650e-01,2.425289999999999946e-01,1.874450000000000045e+03};
    vector<double> grandChild1_0_25_minVal = {5.268939999999999735e-04,6.704619999999999243e-04,9.349539999999999934e-03,9.451699999999998991e-02,4.182019999999999835e-03,3.355930000000000024e-02,9.375489999999999237e-05,1.926019999999999984e-06,4.042050000000000365e-01,1.348789999999999989e-01,1.600420000000000073e+03};
    
    vector<double> grandChild1_0_26_maxVal = {6.901160000000000584e-04,1.213820000000000003e-03,3.140319999999999917e-02,3.929079999999999795e-01,1.203550000000000106e-02,3.618049999999999738e-02,1.313040000000000019e-04,1.648520000000000100e-06,4.178359999999999852e-01,3.265629999999999922e-01,2.143880000000000109e+03};
    vector<double> grandChild1_0_26_minVal = {1.707520000000000077e-04,3.221850000000000061e-04,2.339509999999999854e-02,1.273200000000000165e-01,8.377690000000000137e-03,2.572459999999999677e-02,7.299489999999999462e-05,8.723279999999998158e-07,1.916049999999999975e-01,2.422690000000000121e-01,1.927200000000000045e+03};
    
    vector<double> grandChild1_0_27_maxVal = {1.578499999999999879e-04,1.433010000000000024e-04,1.698679999999999982e-02,2.773739999999999539e-01,1.609799999999999773e-02,2.795149999999999718e-02,5.287520000000001173e-05,9.120029999999999907e-07,1.148849999999999871e-01,4.799029999999999685e-01,3.023710000000000036e+03};
    vector<double> grandChild1_0_27_minVal = {1.467419999999999987e-04,1.336449999999999986e-04,1.621970000000000009e-02,2.567110000000000225e-01,1.567789999999999809e-02,2.722219999999999848e-02,5.102239999999999450e-05,8.751090000000000311e-07,1.082609999999999961e-01,4.744380000000000264e-01,3.008480000000000018e+03};
    
    vector<double> grandChild1_0_28_maxVal = {1.106220000000000125e-04,1.047939999999999999e-04,1.594649999999999887e-02,3.473780000000000201e-01,1.442410000000000393e-02,2.561779999999999960e-02,5.317520000000001225e-05,8.547169999999999898e-07,8.476989999999999525e-02,4.652779999999999694e-01,2.962409999999999854e+03};
    vector<double> grandChild1_0_28_minVal = {9.331809999999999682e-05,8.565010000000000180e-05,1.437609999999999930e-02,3.231100000000000083e-01,1.364660000000000005e-02,2.480590000000000225e-02,4.795279999999999936e-05,7.311170000000000212e-07,7.122950000000000115e-02,4.542209999999999859e-01,2.918280000000000200e+03};
    
    vector<double> grandChild1_0_29_maxVal = {3.013259999999999810e-04,4.132009999999999763e-04,2.898560000000000025e-02,3.454420000000000268e-01,1.738400000000000015e-02,2.894479999999999623e-02,4.001100000000000029e-05,4.546750000000000132e-07,1.930719999999999936e-01,4.460089999999999888e-01,2.805030000000000200e+03};
    vector<double> grandChild1_0_29_minVal = {1.411949999999999924e-04,1.802709999999999957e-04,2.223050000000000026e-02,2.083530000000000104e-01,1.385649999999999903e-02,2.338829999999999729e-02,2.893989999999999714e-05,3.827670000000000022e-07,1.016690000000000094e-01,3.901040000000000063e-01,2.462079999999999927e+03};
    
    vector<double> grandChild1_0_30_maxVal = {4.135419999999999786e-04,3.599319999999999820e-04,1.961250000000000146e-02,1.864069999999999894e-01,1.794820000000000096e-02,3.436650000000000121e-02,4.066640000000000082e-05,8.113630000000000107e-07,2.428460000000000063e-01,4.782229999999999537e-01,3.080639999999999873e+03};
    vector<double> grandChild1_0_30_minVal = {2.812919999999999895e-04,2.516909999999999590e-04,1.580420000000000089e-02,1.168359999999999954e-01,1.759459999999999844e-02,3.079039999999999902e-02,2.878929999999999895e-05,5.522930000000000076e-07,1.864910000000000179e-01,4.567959999999999798e-01,2.960780000000000200e+03};
    
    vector<double> grandChild1_0_31_maxVal = {9.434650000000000208e-05,9.152719999999999335e-05,1.534869999999999984e-02,3.806410000000000071e-01,1.349389999999999964e-02,2.454109999999999625e-02,5.185960000000000065e-05,8.126519999999998047e-07,7.365060000000001050e-02,4.551310000000001188e-01,2.924929999999999836e+03};
    vector<double> grandChild1_0_31_minVal = {7.346339999999999869e-05,6.585359999999999576e-05,1.295970000000000108e-02,3.569979999999999820e-01,1.241200000000000116e-02,2.383120000000000030e-02,4.338930000000000147e-05,6.241470000000000103e-07,5.631209999999999688e-02,4.430419999999999914e-01,2.864360000000000127e+03};
    
    vector<double> grandChild1_0_32_maxVal = {2.998490000000000356e-04,2.839569999999999920e-04,2.131250000000000158e-02,3.014949999999999575e-01,1.785270000000000259e-02,3.087930000000000189e-02,4.636720000000001238e-05,7.699779999999999614e-07,1.928010000000000002e-01,4.732149999999999412e-01,2.999139999999999873e+03};
    vector<double> grandChild1_0_32_minVal = {1.457180000000000031e-04,1.470230000000000050e-04,1.786190000000000347e-02,1.793399999999999994e-01,1.550879999999999967e-02,2.603010000000000046e-02,3.399939999999999842e-05,5.155639999999999439e-07,1.071319999999999911e-01,4.527880000000000238e-01,2.877429999999999836e+03};
    
    vector<double> grandChild1_0_33_maxVal = {4.555669999999999837e-04,3.367059999999999845e-04,1.583789999999999851e-02,1.204469999999999985e-01,1.768590000000000093e-02,3.581969999999999599e-02,3.520010000000000201e-05,8.262890000000000479e-07,2.589190000000000103e-01,4.777979999999999450e-01,3.110480000000000018e+03};
    vector<double> grandChild1_0_33_minVal = {3.949900000000000112e-04,2.903159999999999899e-04,1.359600000000000045e-02,9.673110000000000042e-02,1.699909999999999963e-02,3.424689999999999679e-02,3.034739999999999679e-05,7.008209999999999728e-07,2.345500000000000085e-01,4.663760000000000128e-01,3.057340000000000146e+03};
    
    vector<double> grandChild1_0_34_maxVal = {6.098600000000000462e-04,8.780330000000000686e-04,2.478059999999999985e-02,5.801229999999999443e-01,8.425749999999999212e-03,3.862950000000000411e-02,2.380520000000000173e-04,3.558450000000000209e-06,4.731659999999999755e-01,2.478139999999999787e-01,1.889559999999999945e+03};
    vector<double> grandChild1_0_34_minVal = {9.387129999999999010e-05,1.071429999999999871e-04,1.253690000000000013e-02,1.679220000000000157e-01,4.179369999999999960e-03,1.930600000000000024e-02,1.389529999999999823e-04,1.638479999999999939e-06,1.123210000000000042e-01,1.574669999999999959e-01,1.658369999999999891e+03};
    
    vector<double> grandChild1_0_35_maxVal = {3.280459999999999691e-04,2.708349999999999777e-04,1.763309999999999877e-02,1.714119999999999810e-01,1.793990000000000168e-02,3.297110000000000318e-02,4.399920000000000388e-05,9.059340000000000705e-07,2.070869999999999933e-01,4.853390000000000204e-01,3.100590000000000146e+03};
    vector<double> grandChild1_0_35_minVal = {2.822160000000000098e-04,2.311790000000000036e-04,1.589749999999999844e-02,1.453919999999999935e-01,1.748959999999999751e-02,3.163500000000000340e-02,3.937599999999999705e-05,7.950279999999998317e-07,1.842759999999999954e-01,4.770229999999999748e-01,3.053510000000000218e+03};
    
    vector<double> grandChild1_0_36_maxVal = {2.978990000000000153e-04,2.696649999999999872e-04,1.938919999999999880e-02,2.464860000000000106e-01,1.790290000000000284e-02,3.177880000000000288e-02,4.786170000000000290e-05,8.762999999999999787e-07,1.928099999999999814e-01,4.815490000000000048e-01,3.066530000000000200e+03};
    vector<double> grandChild1_0_36_minVal = {1.872290000000000195e-04,1.778829999999999908e-04,1.749809999999999907e-02,1.664940000000000031e-01,1.672569999999999960e-02,2.826359999999999636e-02,3.659950000000000085e-05,6.388099999999999875e-07,1.334980000000000055e-01,4.672470000000000234e-01,2.984219999999999800e+03};
    
    vector<double> grandChild1_0_37_maxVal = {5.911119999999999743e-04,1.056789999999999943e-03,3.390059999999999601e-02,3.433959999999999790e-01,1.503799999999999928e-02,3.075430000000000177e-02,8.823180000000000454e-05,9.995869999999999894e-07,3.480240000000000000e-01,3.834319999999999951e-01,2.359869999999999891e+03};
    vector<double> grandChild1_0_37_minVal = {2.022349999999999907e-04,3.630390000000000049e-04,2.907239999999999824e-02,1.436650000000000149e-01,1.109789999999999908e-02,2.391209999999999863e-02,4.415439999999999860e-05,5.935130000000000551e-07,1.542119999999999880e-01,3.182490000000000041e-01,2.120639999999999873e+03};
    
    vector<double> grandChild1_0_38_maxVal = {5.839470000000000251e-04,9.248379999999999839e-04,3.378230000000000122e-02,3.461310000000000220e-01,1.685970000000000177e-02,2.973240000000000605e-02,5.911350000000000247e-05,6.249230000000000432e-07,2.966650000000000120e-01,4.194819999999999660e-01,2.595630000000000109e+03};
    vector<double> grandChild1_0_38_minVal = {1.751119999999999999e-04,2.810809999999999741e-04,2.746959999999999680e-02,1.380089999999999928e-01,1.276670000000000062e-02,2.338440000000000310e-02,3.065050000000000072e-05,4.232059999999999847e-07,1.227619999999999545e-01,3.646739999999999982e-01,2.297269999999999982e+03};
    
    vector<double> grandChild1_0_39_maxVal = {1.900369999999999967e-04,1.721249999999999961e-04,1.771150000000000155e-02,2.507610000000000117e-01,1.685620000000000174e-02,2.913450000000000761e-02,5.199419999999999763e-05,9.272289999999999446e-07,1.353290000000000048e-01,4.837919999999999998e-01,3.047619999999999891e+03};
    vector<double> grandChild1_0_39_minVal = {1.718890000000000207e-04,1.561770000000000194e-04,1.662890000000000201e-02,2.268329999999999791e-01,1.635299999999999948e-02,2.822780000000000081e-02,4.912609999999999709e-05,8.727719999999997898e-07,1.242270000000000041e-01,4.782010000000000427e-01,3.031429999999999836e+03};
    
    // grandChild of child1_1
    vector<double> grandChild1_1_0_maxVal = {6.682040000000000147e-05,8.137379999999999668e-05,1.604360000000000161e-02,5.300229999999999109e-01,1.111810000000000055e-02,2.212700000000000083e-02,3.680889999999999922e-05,4.918869999999999629e-07,5.626810000000000145e-02,4.147109999999999408e-01,2.742510000000000218e+03};
    vector<double> grandChild1_1_0_minVal = {3.466119999999999943e-05,3.143320000000000256e-05,9.164570000000000355e-03,4.310910000000000020e-01,7.634079999999999686e-03,1.869020000000000056e-02,2.409449999999999776e-05,2.889020000000000018e-07,2.664479999999999627e-02,3.439610000000000167e-01,2.384119999999999891e+03};
    
    vector<double> grandChild1_1_1_maxVal = {6.949120000000000308e-05,6.829899999999999101e-05,1.380999999999999936e-02,4.347380000000000133e-01,1.185119999999999924e-02,2.328329999999999983e-02,4.930299999999999874e-05,7.500830000000001925e-07,5.528269999999999712e-02,4.400430000000000175e-01,2.871630000000000109e+03};
    vector<double> grandChild1_1_1_minVal = {4.961699999999999607e-05,4.245729999999999752e-05,1.054159999999999993e-02,3.998610000000000220e-01,1.047039999999999950e-02,2.198999999999999913e-02,3.455219999999999760e-05,4.456190000000000147e-07,3.780889999999999945e-02,4.120810000000000306e-01,2.725820000000000164e+03};
    
    vector<double> grandChild1_1_2_maxVal = {1.891820000000000058e-04,3.165470000000000306e-04,2.935290000000000121e-02,4.843669999999999920e-01,1.450770000000000011e-02,2.474650000000000113e-02,7.866200000000000004e-05,7.716389999999999655e-07,1.442769999999999886e-01,4.304270000000001151e-01,2.754059999999999945e+03};
    vector<double> grandChild1_1_2_minVal = {8.673170000000000174e-05,1.328620000000000029e-04,1.936960000000000071e-02,3.312400000000000344e-01,8.795350000000000390e-03,2.007240000000000066e-02,3.068500000000000182e-05,3.609599999999999711e-07,6.889320000000000166e-02,3.086510000000000087e-01,2.111880000000000109e+03};
    
    vector<double> grandChild1_1_3_maxVal = {1.065839999999999946e-04,1.989840000000000044e-04,2.320459999999999884e-02,6.191210000000000324e-01,9.060779999999999182e-03,2.425669999999999910e-02,1.293110000000000093e-04,1.422779999999999615e-06,1.621170000000000111e-01,3.242389999999999994e-01,2.211440000000000055e+03};
    vector<double> grandChild1_1_3_minVal = {2.933479999999999907e-05,4.393040000000000210e-05,1.033349999999999894e-02,4.561810000000001142e-01,4.104619999999999796e-03,1.684650000000000036e-02,4.733300000000000235e-05,5.009939999999999928e-07,4.766459999999999447e-02,2.172000000000000042e-01,1.796079999999999927e+03};
    
    vector<double> grandChild1_1_4_maxVal = {4.384420000000000282e-05,3.979270000000000273e-05,1.047520000000000048e-02,4.975499999999999923e-01,9.625879999999999853e-03,2.164999999999999911e-02,4.357100000000001364e-05,6.389659999999999526e-07,3.476430000000000492e-02,4.139869999999999939e-01,2.777260000000000218e+03};
    vector<double> grandChild1_1_4_minVal = {2.638079999999999990e-05,2.009900000000000187e-05,6.989620000000000208e-03,4.599829999999999752e-01,7.660679999999999573e-03,2.057240000000000110e-02,3.193950000000000142e-05,4.148699999999999556e-07,1.938619999999999927e-02,3.903590000000000115e-01,2.658030000000000200e+03};
    
    vector<double> grandChild1_1_5_maxVal = {3.490739999999999718e-05,3.815790000000000273e-05,1.063700000000000062e-02,5.724489999999999856e-01,7.756070000000000325e-03,1.977380000000000110e-02,3.271679999999999819e-05,4.678329999999999515e-07,3.077020000000000102e-02,3.738170000000000104e-01,2.619920000000000073e+03};
    vector<double> grandChild1_1_5_minVal = {1.034549999999999946e-05,6.323420000000000013e-06,3.431060000000000099e-03,5.249249999999999750e-01,4.537479999999999986e-03,1.809359999999999788e-02,2.084929999999999705e-05,2.610469999999999949e-07,7.128619999999999575e-03,3.370279999999999943e-01,2.396329999999999927e+03};
    
    vector<double> grandChild1_1_6_maxVal = {2.325440000000000219e-05,2.315090000000000225e-05,7.867070000000000313e-03,6.190999999999999837e-01,6.137609999999999941e-03,1.875529999999999906e-02,2.508519999999999828e-05,3.514809999999999959e-07,2.067429999999999962e-02,3.488800000000000234e-01,2.509789999999999964e+03};
    vector<double> grandChild1_1_6_minVal = {6.836419999999997473e-06,3.734409999999999623e-06,2.441969999999999905e-03,5.649790000000000090e-01,3.560649999999999839e-03,1.635400000000000048e-02,1.656950000000000119e-05,2.200699999999999847e-07,4.537900000000000093e-03,2.988099999999999645e-01,2.201539999999999964e+03};
    
    vector<double> grandChild1_1_7_maxVal = {1.917940000000000140e-04,3.318880000000000181e-04,2.403199999999999781e-02,6.019140000000000601e-01,8.167219999999999341e-03,3.330209999999999421e-02,2.222100000000000019e-04,3.118109999999999696e-06,3.123449999999999838e-01,2.785130000000000106e-01,1.996619999999999891e+03};
    vector<double> grandChild1_1_7_minVal = {5.064600000000000265e-05,7.509519999999999889e-05,1.190460000000000129e-02,3.419840000000000102e-01,3.810379999999999930e-03,1.801269999999999954e-02,9.655290000000004249e-05,9.620480000000001189e-07,8.032489999999999075e-02,1.630520000000000025e-01,1.666289999999999964e+03};
    
    vector<double> grandChild1_1_8_maxVal = {5.835040000000000295e-05,5.756199999999999539e-05,1.282599999999999886e-02,4.626729999999999454e-01,1.087349999999999949e-02,2.248909999999999798e-02,4.692430000000000066e-05,7.006449999999999850e-07,4.679330000000000295e-02,4.283939999999999415e-01,2.829889999999999873e+03};
    vector<double> grandChild1_1_8_minVal = {3.764309999999999878e-05,3.075929999999999534e-05,8.892330000000000373e-03,4.285479999999998735e-01,9.180390000000000078e-03,2.137879999999999989e-02,3.567520000000000023e-05,4.671119999999999545e-07,2.833929999999999783e-02,4.062939999999999885e-01,2.725559999999999945e+03};
    
    vector<double> grandChild1_1_9_maxVal = {2.450929999999999927e-04,4.578189999999999885e-04,3.073419999999999971e-02,4.739779999999999549e-01,1.329970000000000110e-02,3.257559999999999623e-02,1.519379999999999808e-04,1.759970000000000109e-06,3.060370000000000035e-01,3.768819999999999948e-01,2.383559999999999945e+03};
    vector<double> grandChild1_1_9_minVal = {9.754799999999999506e-05,1.766229999999999927e-04,1.860490000000000060e-02,3.022529999999999939e-01,6.635150000000000249e-03,2.209009999999999793e-02,4.738770000000002065e-05,5.163439999999999813e-07,1.198589999999999933e-01,2.280820000000000070e-01,1.876529999999999973e+03};
    
    vector<double> grandChild1_1_10_maxVal = {1.260289999999999956e-04,1.445839999999999831e-04,2.120220000000000091e-02,4.548640000000001016e-01,1.417630000000000105e-02,2.477899999999999894e-02,4.447589999999999882e-05,6.452330000000000444e-07,9.929559999999999775e-02,4.439229999999999565e-01,2.870059999999999945e+03};
    vector<double> grandChild1_1_10_minVal = {6.280070000000000335e-05,6.369940000000000205e-05,1.340780000000000097e-02,3.417159999999999642e-01,1.043920000000000091e-02,2.072059999999999874e-02,2.836199999999999713e-05,3.340919999999999982e-07,4.858989999999999837e-02,3.685739999999999572e-01,2.435480000000000018e+03};
    
    vector<double> grandChild1_1_11_maxVal = {3.518700000000000040e-05,3.664809999999999899e-05,1.035859999999999906e-02,5.344619999999999926e-01,8.513470000000000412e-03,2.072229999999999905e-02,3.873059999999999811e-05,5.590999999999999706e-07,3.054809999999999817e-02,3.954199999999999937e-01,2.706840000000000146e+03};
    vector<double> grandChild1_1_11_minVal = {1.703859999999999980e-05,1.172640000000000516e-05,5.058029999999999818e-03,4.896670000000000189e-01,6.056080000000000144e-03,1.908750000000000030e-02,2.407260000000000056e-05,2.910229999999999981e-07,1.204140000000000071e-02,3.568999999999999950e-01,2.473719999999999800e+03};
    
    vector<double> grandChild1_1_12_maxVal = {8.804520000000000195e-05,8.545040000000000437e-05,1.505939999999999883e-02,4.071839999999999904e-01,1.316490000000000021e-02,2.416240000000000401e-02,5.092050000000000146e-05,7.860169999999998048e-07,6.892199999999999716e-02,4.485939999999999372e-01,2.902590000000000146e+03};
    vector<double> grandChild1_1_12_minVal = {6.211990000000000133e-05,5.473149999999999597e-05,1.193260000000000154e-02,3.673899999999999944e-01,1.157139999999999905e-02,2.281709999999999988e-02,3.966860000000000167e-05,5.414559999999999748e-07,4.758339999999999792e-02,4.269069999999999809e-01,2.797599999999999909e+03};
    
    vector<double> grandChild1_1_13_maxVal = {9.137959999999999497e-05,1.541970000000000146e-04,2.213009999999999977e-02,5.879710000000000214e-01,1.116840000000000020e-02,2.152109999999999787e-02,6.181810000000000365e-05,6.246889999999999367e-07,9.311200000000000032e-02,3.884389999999999787e-01,2.564130000000000109e+03};
    vector<double> grandChild1_1_13_minVal = {3.807820000000000416e-05,5.320619999999999891e-05,1.239529999999999972e-02,4.409699999999999731e-01,5.532320000000000293e-03,1.753479999999999969e-02,2.726640000000000037e-05,3.164800000000000387e-07,3.437130000000000046e-02,2.782729999999999926e-01,2.029410000000000082e+03};
    
    vector<double> grandChild1_1_14_maxVal = {4.345039999999999992e-05,6.422910000000000479e-05,1.410149999999999945e-02,6.273229999999999640e-01,8.024369999999999420e-03,1.921180000000000110e-02,6.536349999999999853e-05,6.885930000000000833e-07,5.876830000000000248e-02,3.574360000000000315e-01,2.465570000000000164e+03};
    vector<double> grandChild1_1_14_minVal = {1.640410000000000105e-05,1.699379999999999982e-05,6.321669999999999720e-03,5.258639999999999981e-01,4.420069999999999902e-03,1.598990000000000133e-02,2.084849999999999868e-05,2.606439999999999879e-07,1.438090000000000028e-02,2.579420000000000046e-01,1.950230000000000018e+03};

    
    // grandChild of child1_2
    vector<double> grandChild1_2_0_maxVal = {1.737430000000000094e-03,5.727150000000000079e-04,5.570300000000000251e-03,1.808699999999999891e-02,1.017449999999999952e-02,4.474380000000001412e-02,6.857550000000000098e-06,3.045629999999999989e-07,4.917309999999999737e-01,3.981109999999999927e-01,3.001699999999999818e+03};
    vector<double> grandChild1_2_0_minVal = {1.045069999999999940e-03,2.962460000000000093e-04,8.257210000000000721e-04,1.977490000000000150e-03,4.003480000000000233e-03,4.086119999999998642e-02,1.092230000000000086e-06,8.354789999999999601e-08,4.033700000000000063e-01,3.218739999999999934e-01,2.671719999999999800e+03};
    
    vector<double> grandChild1_2_1_maxVal = {9.746680000000000404e-04,7.651310000000000576e-04,1.463680000000000016e-02,6.018659999999999982e-02,1.527039999999999995e-02,4.128890000000000338e-02,1.973279999999999850e-05,6.018860000000000468e-07,3.943980000000000263e-01,4.481709999999999861e-01,3.091019999999999982e+03};
    vector<double> grandChild1_2_1_minVal = {6.507800000000000000e-04,3.630649999999999806e-04,6.784789999999999745e-03,3.078940000000000149e-02,1.267320000000000078e-02,3.583250000000000324e-02,1.086910000000000068e-05,2.863130000000000042e-07,3.193520000000000247e-01,3.792800000000000060e-01,2.677719999999999800e+03};
    
    vector<double> grandChild1_2_2_maxVal = {2.827650000000000129e-03,7.757830000000000498e-04,3.048100000000000202e-03,7.588329999999999902e-03,6.908380000000000423e-03,4.441409999999999803e-02,3.404439999999999799e-06,1.637079999999999992e-07,5.742580000000000462e-01,3.270700000000000274e-01,2.742289999999999964e+03};
    vector<double> grandChild1_2_2_minVal = {1.586960000000000107e-03,2.355710000000000117e-04,1.237800000000000109e-04,1.819009999999999919e-04,1.157279999999999897e-03,3.822949999999999959e-02,1.308930000000000062e-07,2.304540000000000398e-08,4.809129999999999794e-01,2.427999999999999881e-01,2.382559999999999945e+03};
    
    vector<double> grandChild1_2_3_maxVal = {3.563399999999999988e-03,1.106379999999999907e-03,4.806089999999999841e-03,9.086389999999999745e-03,6.567650000000000397e-03,3.922930000000000167e-02,5.320639999999999765e-06,2.342320000000000026e-07,6.233360000000000012e-01,2.911239999999999939e-01,2.466159999999999854e+03};
    vector<double> grandChild1_2_3_minVal = {1.895589999999999949e-03,2.718689999999999952e-04,1.422750000000000024e-04,1.862509999999999893e-04,1.200859999999999992e-03,2.861740000000000464e-02,1.432150000000000023e-07,2.634050000000000019e-08,5.197439999999999838e-01,1.983509999999999995e-01,1.989109999999999900e+03};
    
    vector<double> grandChild1_2_4_maxVal = {1.178819999999999911e-03,6.543760000000000245e-04,1.040040000000000062e-02,3.822730000000000572e-02,1.326480000000000020e-02,4.343049999999999689e-02,1.331280000000000068e-05,4.714770000000000071e-07,4.284209999999999963e-01,4.282340000000000035e-01,3.061809999999999945e+03};
    vector<double> grandChild1_2_4_minVal = {8.048939999999999003e-04,3.643270000000000102e-04,3.846769999999999790e-03,1.423890000000000051e-02,9.535500000000000573e-03,3.791480000000000544e-02,6.394640000000001679e-06,2.286080000000000047e-07,3.572449999999999792e-01,3.689259999999999762e-01,2.764510000000000218e+03};
    
    vector<double> grandChild1_2_5_maxVal = {1.334660000000000100e-03,1.761240000000000071e-03,3.156880000000000103e-02,1.485680000000000056e-01,1.732679999999999984e-02,3.590320000000000317e-02,6.693300000000000443e-05,1.001440000000000105e-06,4.925080000000000013e-01,4.365589999999999749e-01,2.866010000000000218e+03};
    vector<double> grandChild1_2_5_minVal = {5.032510000000000238e-04,4.656390000000000052e-04,1.203979999999999981e-02,2.839220000000000632e-02,7.997100000000000042e-03,2.851739999999999831e-02,1.273059999999999971e-05,3.054929999999999946e-07,2.742800000000000238e-01,2.758390000000000009e-01,2.008400000000000091e+03};
    
    vector<double> grandChild1_2_6_maxVal = {8.205089999999999736e-04,6.818599999999999531e-04,1.866150000000000100e-02,1.136019999999999947e-01,1.731640000000000262e-02,3.935749999999999665e-02,2.534959999999999866e-05,6.939270000000000436e-07,3.606750000000000234e-01,4.608039999999999914e-01,3.103690000000000055e+03};
    vector<double> grandChild1_2_6_minVal = {5.019269999999999938e-04,3.432740000000000205e-04,9.376189999999999525e-03,4.997920000000000140e-02,1.472009999999999985e-02,3.364459999999999673e-02,1.467020000000000059e-05,3.243520000000000181e-07,2.752470000000000194e-01,3.964079999999999826e-01,2.739809999999999945e+03};
    
    vector<double> grandChild1_2_7_maxVal = {2.943540000000000132e-03,1.787830000000000018e-03,2.973430000000000170e-02,1.521079999999999932e-01,1.202499999999999923e-02,3.878140000000000059e-02,1.171029999999999933e-04,3.951620000000000123e-06,6.654919999999999725e-01,3.265170000000000017e-01,2.139320000000000164e+03};
    vector<double> grandChild1_2_7_minVal = {5.581110000000000237e-04,9.818380000000000683e-04,3.614360000000000055e-03,2.065219999999999903e-02,1.880630000000000105e-03,2.927739999999999856e-02,2.615149999999999856e-05,9.431580000000000338e-07,3.490420000000000189e-01,1.275910000000000100e-01,1.591269999999999982e+03};
    
    vector<double> grandChild1_2_8_maxVal = {3.752179999999999925e-03,1.972820000000000129e-03,1.752089999999999897e-02,4.404700000000000282e-02,1.067040000000000002e-02,3.528049999999999936e-02,3.467889999999999759e-05,1.490729999999999532e-06,6.818330000000000224e-01,3.336330000000000129e-01,2.420590000000000146e+03};
    vector<double> grandChild1_2_8_minVal = {1.205389999999999977e-03,9.617109999999999678e-04,5.163900000000000347e-04,4.006640000000000115e-04,8.547939999999999748e-04,2.468530000000000030e-02,4.642789999999999978e-07,1.306330000000000025e-07,4.514310000000000267e-01,1.274530000000000107e-01,1.599759999999999991e+03};
    
    vector<double> grandChild1_2_9_maxVal = {1.961179999999999868e-03,1.184949999999999936e-03,1.350720000000000046e-02,4.690400000000000125e-02,1.372300000000000082e-02,4.115089999999999720e-02,1.341419999999999940e-05,3.453439999999999986e-07,5.206159999999999677e-01,3.846189999999999887e-01,2.814000000000000000e+03};
    vector<double> grandChild1_2_9_minVal = {9.551470000000000489e-04,5.485439999999999847e-04,2.791220000000000073e-03,5.136720000000000001e-03,5.679720000000000081e-03,3.379309999999999953e-02,2.833870000000000110e-06,1.469870000000000178e-07,3.895050000000001011e-01,2.885679999999999912e-01,2.349340000000000146e+03};
    
    
    //Declare centroids for 2 PARENT clusters to calculate distance >> Classifier indexParentCluster
    vector<float> centroid_parentCluster0 = {1.713780619512165,-0.9588882215412154,-2.365754845288025,1.2927333993804122,-2.469156746880645,-2.3313978219868834,-0.052244235276517684,0.6426930767593209,1.1149588996770736,-2.6286763724580773,-2.5988998455590124};   // parentCluster0
    vector<float> centroid_parentCluster1 = {-0.2187069151215826,0.12237008779999738,0.3019096716674042,-0.16497428587657495,0.31510547436081937,0.29752514397852037,0.00666723348374963,-0.08201832754302517,-0.14228730250499966,0.33546283213132794,0.3316628519780743};   // parentCluster1
    // Transform to openCV MAT
    cv::Mat r0 = cv::Mat(numVarANN, 1, CV_32F, centroid_parentCluster0.data());
    cv::Mat r1 = cv::Mat(numVarANN, 1, CV_32F, centroid_parentCluster1.data());
    
    //Declare PARENT LOCAL INPUT Standardize for each PARENT cluster: standardizedX = (X - meanScale) / standardDeviationScale
    std::string parentCluster0_meanScaleINPUTPATH = casePath + "0.treatedFile/parentCluster0/scalerParentCluster0_OnlyMean.txt";
    vector<float> parentCluster0_meanScaleINPUT;
    readFromCommaDelimitedFile_Float(parentCluster0_meanScaleINPUTPATH, parentCluster0_meanScaleINPUT);
    std::string parentCluster0_stdScaleINPUTPATH = casePath + "0.treatedFile/parentCluster0/scalerParentCluster0_OnlyStandardDeviation.txt";
    vector<float> parentCluster0_stdScaleINPUT;
    readFromCommaDelimitedFile_Float(parentCluster0_stdScaleINPUTPATH, parentCluster0_stdScaleINPUT);

    std::string parentCluster1_meanScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/scalerParentCluster1_OnlyMean.txt";
    vector<float> parentCluster1_meanScaleINPUT;
    readFromCommaDelimitedFile_Float(parentCluster1_meanScaleINPUTPATH, parentCluster1_meanScaleINPUT);
    std::string parentCluster1_stdScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/scalerParentCluster1_OnlyStandardDeviation.txt";
    vector<float> parentCluster1_stdScaleINPUT;
    readFromCommaDelimitedFile_Float(parentCluster1_stdScaleINPUTPATH, parentCluster1_stdScaleINPUT);
    
    //Declare centroids for CHILD cluster to calculate distance >> Classifier >> indexChildCluster
    // Child of parentCluster0
    vector<float> centroid_childCluster0_0 = {-0.7856763594025837,-0.3507322515362266,-0.32026202621781386,0.8574685043685454,-0.4125699324584326,-0.17327941499915334,0.9581959526361229,0.8939171232536954,-0.7917525853220728,-0.2806922205873283,-0.4970975463385322};
    vector<float> centroid_childCluster0_1 = {-0.9068125064702791,-0.3146255612353812,1.2295940066429982,0.45781849499443344,1.4063680776442573,0.9121769921289745,-0.14195815880264748,-0.2637816653250137,-0.9244814924534872,1.760763707386912,1.31428614723598};
    vector<float> centroid_childCluster0_2 = {1.4935986952677773,-0.2653711777080768,-0.41346065973911944,-1.2239021066717573,-0.4614218684413995,-0.630073736301961,-0.33024978337809324,-0.26057454515861594,1.3368082985651546,-0.34392843673840534,0.18276560180192447};
    vector<float> centroid_childCluster0_3 = {0.371196482366543,2.544307656679002,-0.35780995456767506,-1.295731195943003,0.09090885120372365,2.6167996836330896,-0.46411658551779617,-0.28891379052216515,0.9978803091426384,1.0608341019715313,1.4553971102937442};
    vector<float> centroid_childCluster0_4 = {0.2622469347259141,-0.35296896615509193,-0.41688512680242723,0.033818250565707364,-0.46465624258960336,-0.7330831686063964,-0.07904051533342872,-0.16571727294369212,0.14824094729983017,-0.6688826995450833,-0.5346958554342284};
    vector<float> centroid_childCluster0_5 = {-0.9063697051519706,-0.2879874074347624,2.1922185267982646,0.3024997178926355,2.9763817781585153,1.1625536280966648,-0.2610482332518937,-0.278168540639293,-0.9303891833686312,2.3690391568634275,1.7831581143619135};
    vector<float> centroid_childCluster0_6 = {-0.3233886737820214,-0.3325509414888255,-0.3288564698778762,0.3692098164786052,-0.4044289208151431,-0.055858223243060806,3.0830751867562554,4.583137653595118,-0.29929087139613825,-0.288275694901036,-0.2715047124493042};
    vector<float> centroid_childCluster0_7 = {-0.04230991655134872,-0.13254677566620707,0.25457543239459296,0.05290703942297293,-0.04238614017324239,0.023210615533642193,3.9137799619398663,1.4547596108659742,0.0027184024886679203,-0.23510760413953471,-0.13221363861318086};
    vector<float> centroid_childCluster0_8 = {1.0054726037481512,0.8974206979797796,-0.3948760908082766,-1.2899610252881972,-0.4144394212967418,0.9321753558373932,-0.4183982206609701,-0.2830009235484384,1.2325175420353922,0.22575482843486397,0.7510828598038413};
    vector<float> centroid_childCluster0_9 = {-0.13030511211810203,-0.3396695607493009,-0.384798307345399,0.16418014348710114,-0.4398977447358103,0.00659205539683218,3.6917399427654205,10.40089432037977,-0.08381009488236507,-0.32703634891246214,-0.2026363604821658};
    vector<float> centroid_childCluster0_10 = {-0.8062156050303434,-0.35327334104498975,-0.41589422464585124,1.0891847961446361,-0.4642493187619384,-0.7193466100202813,-0.40414241445989063,-0.22658982557630108,-0.8606534651161553,-0.9021828523623053,-1.250011686691736};
    vector<float> centroid_childCluster0_11 = {0.3113298771036517,5.347909585077625,-0.02004679081746553,-1.2767260947837598,0.5604209894478345,2.413311503709607,-0.3430974590021649,-0.26796432201077874,1.0036813154874065,0.9670809940137053,1.263803746627631};
    vector<float> centroid_childCluster0_12 = {-0.841669102019961,0.19269952149883285,5.0333087433717285,0.25270123401159905,2.960474745557481,1.272424178276809,1.1277900533501874,-0.059057558809681915,-0.665654431275583,1.4569065240537664,1.067568138470002};
    vector<float> centroid_childCluster0_13 = {-0.9013976793975146,-0.332877168442425,0.3441749670719879,0.667971983373883,0.08271544448513587,0.5269689725451964,0.3800977049952809,-0.08906986397307777,-0.8884369170681231,0.8142113451692912,0.5319652752834171};
    // Transform to openCV MAT
    cv::Mat r0_0 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_0.data());
    cv::Mat r0_1 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_1.data());
    cv::Mat r0_2 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_2.data());
    cv::Mat r0_3 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_3.data());
    cv::Mat r0_4 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_4.data());
    cv::Mat r0_5 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_5.data());
    cv::Mat r0_6 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_6.data());
    cv::Mat r0_7 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_7.data());
    cv::Mat r0_8 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_8.data());
    cv::Mat r0_9 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_9.data());
    cv::Mat r0_10 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_10.data());
    cv::Mat r0_11 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_11.data());
    cv::Mat r0_12 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_12.data());
    cv::Mat r0_13 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster0_13.data());
    
    // Child of parentCluster1
    vector<float> centroid_childCluster1_0 = {-0.13889903357859185,-0.06356253220637721,0.3296718333304367,-0.08107204203062648,0.3191659412959153,0.012349117874402276,0.25481141808433233,0.29148255519761584,-0.07788202412112441,0.3153363122923706,0.26919372389381785};
    vector<float> centroid_childCluster1_1 = {-0.6335774487751448,-1.163136095683796,-1.695748458182291,2.194570945206625,-2.2391517876492384,-1.7875518991536579,-0.6504658151229136,-1.461716514410033,-1.2296989963179743,-1.7966127030551116,-2.0946483754145366};
    vector<float> centroid_childCluster1_2 = {3.3964328887867827,3.0149739319688633,-2.7090793524232035,-2.3073271217813756,-1.6233311814419449,2.7825189505817445,-3.198343782278732,-2.458150205662163,3.367205449232841,-2.2991981366165364,-1.0244231830188812};
    // Transform to openCV MAT
    cv::Mat r1_0 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0.data());
    cv::Mat r1_1 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1.data());
    cv::Mat r1_2 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2.data());

    
    // parentCluster1 - childCluster0 - grandChild
    vector<float> centroid_childCluster1_0_0 = {-0.24348171456920173,-0.13853354403900225,0.9480504976035935,0.2683578281368178,0.2292364598638829,-0.2965314340270474,0.23365557458398592,-0.1031726295311068,-0.1933299639443453,-0.12028610989192239,-0.10154784653353432};
    vector<float> centroid_childCluster1_0_1 = {0.7579038546482112,0.8880167416997489,0.676145819321681,-1.0186318923141904,1.2727809139169335,0.9399321515494593,-0.4682322533018221,0.21868521188138504,0.9008853557465777,0.750062027721772,0.9045389080547682};
    vector<float> centroid_childCluster1_0_2 = {-0.8133585013901297,-0.8988498897448001,-0.5431173284819654,1.0692676698111807,-1.1481964373165952,-0.9811835071832214,0.5172873354598984,-0.1728250729943117,-0.9197479865704322,-0.7504157572843791,-0.8066743466414116};
    vector<float> centroid_childCluster1_0_3 = {3.7844731445265065,3.139018307470041,-2.959697987015471,-2.910006071402576,0.8272304871897584,3.353955268771636,-3.336821138865212,-1.306003449503615,3.4333428561193626,-0.867863661749397,1.484832470852338};
    vector<float> centroid_childCluster1_0_4 = {5.104659281417642,3.811285147981989,-1.1343365320175618,2.610055439927665,-10.442302148411292,-0.3105539721884727,34.99084761275421,49.062182020425645,4.505075825152966,-29.863869487029667,-26.10986780815732};
    vector<float> centroid_childCluster1_0_5 = {2.8935466889244945,6.459253186433119,9.583434310572093,-1.2541550831408075,0.940184915576524,0.36399685182245095,-3.6220293900830147,-4.609821219143921,2.6004165788631473,-5.489451419195495,-6.83306262981729};
    vector<float> centroid_childCluster1_0_6 = {2.0469644430151694,2.0252811763094676,-0.46323009485682115,-2.0233126624309725,1.5654230621151424,2.106791137276431,-1.7107135368660047,-0.26005257926522046,2.107060198906328,0.38378462482184367,1.3890453085811145};
    vector<float> centroid_childCluster1_0_7 = {0.1817317924085448,0.27872504313333096,0.6701658329715183,-0.42059518354628156,0.7254208436298845,0.32964199581582515,0.007090456684868933,0.25790774434061736,0.2822759547821683,0.6058054810707205,0.4827866183560813};
    vector<float> centroid_childCluster1_0_8 = {-0.9596334324068886,-1.087326588087358,-0.9558447186151402,1.3598652142012613,-1.5845237672394075,-1.2099243938175612,0.5135672993744533,-0.3252516255576715,-1.1129006407840074,-1.145818476490748,-1.100980849065634};
    vector<float> centroid_childCluster1_0_9 = {-0.17240247989300445,0.578883840397643,4.242442894557562,0.9525326794874222,-0.5543583820708897,-1.061244239489009,-2.5437468358068585,-3.9245303815642023,-0.11996550066543502,-3.603134411573721,-4.100902806606282};
    vector<float> centroid_childCluster1_0_10 = {12.76704829834745,5.544968128380595,-3.7531910081089768,1.523696606765339,-11.048796448131176,-0.36836703923893716,43.95076666888733,95.90816277724662,6.4883517949669525,-32.81203688174211,-27.966270966564846};
    vector<float> centroid_childCluster1_0_11 = {-0.2808058836736614,-0.26187188472277617,0.22240619275735463,0.1475011718969256,-0.010577489777351526,-0.20565724589495726,0.287333098252735,0.16493122454610512,-0.25769231694831524,0.27321298989945575,-0.006466024920869401};
    vector<float> centroid_childCluster1_0_12 = {-1.2372504654951717,-1.4566081074976336,-2.030371186357282,1.9782604469860015,-2.604403564546551,-1.6749482622517795,0.36773649023051247,-0.742681546789,-1.492661434310992,-2.1181209946382675,-1.8093620737962133};
    vector<float> centroid_childCluster1_0_13 = {-0.66556260139211,-0.7155800661612277,-0.23784236952016605,0.7901579982440978,-0.769611484911429,-0.7546866376553993,0.4903202638230645,-0.03949133777045096,-0.7299215081027639,-0.39810988022766586,-0.5425211027560958};
    vector<float> centroid_childCluster1_0_14 = {3.6410394858328052,8.453583254403997,4.848506478676224,0.537774072122957,-8.519837586975147,1.5756975007190648,19.808944645050044,18.01383077402252,5.618384697564554,-25.77088279165578,-23.050366322803253};
    vector<float> centroid_childCluster1_0_15 = {2.5835863884764634,2.417201562323675,-1.1738096156377067,-2.34220528660686,1.4388924405375119,2.5259074085843727,-2.2342872371468623,-0.5554128774209778,2.5488965878742067,0.0581576263624423,1.4681969452780739};
    vector<float> centroid_childCluster1_0_16 = {4.472690485362686,3.473154480571264,-3.9974355039629823,-3.1629280175115517,0.3388005554244972,3.764940952791186,-3.9152567213580682,-1.7773948636254902,3.8844986527098406,-1.4858062668190761,1.4043776653885987};
    vector<float> centroid_childCluster1_0_17 = {11.57585890098398,6.537841895339535,-2.9628100253887646,1.1756244709660562,-10.789484070496677,0.18581078732415585,37.35377659557082,68.89198459079208,6.649750202484769,-32.03226278712504,-27.190464643224615};
    vector<float> centroid_childCluster1_0_18 = {1.1355313182778315,1.2508701612605517,0.4566088678913395,-1.356122290904271,1.4644961687907945,1.3092336019024935,-0.8227111533353622,0.12122334587889107,1.2774723240115686,0.7243912450221464,1.098283632914717};
    vector<float> centroid_childCluster1_0_19 = {-0.16322693497835516,-0.12326079552092586,0.3527967264699757,-0.012635408671548245,0.1952194155761185,-0.05990856929047111,0.22074808999368753,0.20223250727810252,-0.11743169428076929,0.3944930489647256,0.1325078575879669};
    vector<float> centroid_childCluster1_0_20 = {0.43837467768956034,0.5591977131854068,0.7375798810949605,-0.6999695476926133,1.0137367710018905,0.6082639407285126,-0.191685118884608,0.2579278958891155,0.5648854377111464,0.7000882793527622,0.6918095244850441};
    vector<float> centroid_childCluster1_0_21 = {2.375638741535174,3.8017296528436995,4.389551580673267,-1.4398607236695187,1.3862652305558523,1.10572726509797,-3.61865144828955,-4.0047736377066485,2.2966383126265475,-3.040681151062874,-2.8650287605841585};
    vector<float> centroid_childCluster1_0_22 = {-0.5231969561928239,-0.5445818839497865,-0.02558687409400169,0.5368659947498262,-0.457200604570144,-0.5433742143899821,0.43182238716969745,0.057517892290343764,-0.5518069799527209,-0.10791723524580951,-0.3222598990500885};
    vector<float> centroid_childCluster1_0_23 = {3.811157715297577,3.7960858481105157,-1.0919341463748442,-2.66746131748308,1.099112480799992,2.8870323015134423,-3.7237730430402016,-2.6294059766390365,3.4446293182877574,-1.940439968450909,0.11249917419638446};
    vector<float> centroid_childCluster1_0_24 = {-0.8180545251913974,-0.7481473480402323,0.5521301139387782,1.450271184303511,-1.3742866130309348,-1.314807251750746,-0.7527073830033231,-2.0080729198896083,-0.9017642836816412,-2.248056671717063,-2.143622471707427};
    vector<float> centroid_childCluster1_0_25 = {16.63009179968263,13.930961258740272,-3.7917089397477843,-1.6437242511317125,-10.782850327705225,2.235284304556185,22.05868910400463,41.308632997976225,9.891861767008344,-32.66330252299062,-26.74934401362962};
    vector<float> centroid_childCluster1_0_26 = {2.4989993087104017,9.221883045274346,10.197176546516308,0.2582847427210406,-6.375277417614074,0.8924575960946552,11.897024362901341,6.564070311627808,4.527783823140487,-20.360320322421476,-19.965071214069276};
    vector<float> centroid_childCluster1_0_27 = {-0.39547742152156357,-0.39594796222674333,0.10385707824876284,0.3213313818349045,-0.21631380778402653,-0.3590244953471578,0.3566219936202081,0.1216343435319258,-0.39594071706626216,0.11690780723934131,-0.14920562873439427};
    vector<float> centroid_childCluster1_0_28 = {-1.0998110146988926,-1.2718823955832579,-1.4455011817427166,1.660239656893165,-2.06549663550945,-1.4393937618432988,0.4639483703342972,-0.5152743292345353,-1.3024695689011632,-1.597151463284816,-1.4322427937661184};
    vector<float> centroid_childCluster1_0_29 = {0.5171962691875645,2.5454031076755457,9.031687672433323,0.6737903828730512,-0.4190939915043541,-1.099116975698414,-2.912509792183853,-4.5747469620775725,0.594398964785971,-5.7219157563589285,-7.223094953330239};
    vector<float> centroid_childCluster1_0_30 = {2.1858501404751762,2.5016295853576276,0.8296571156131797,-1.858007457166066,1.657811922167162,1.8680207592353202,-2.3381053057061654,-1.6287576440244809,2.227549825485496,-0.6690272987735337,0.3672703800597856};
    vector<float> centroid_childCluster1_0_31 = {-1.3676689527081307,-1.6342540627257909,-2.6906014747415985,2.3072586726179503,-3.1889082483239033,-1.911582863793398,0.21462629710113243,-1.0140758883409473,-1.67703722142502,-2.7076363141905753,-2.2341914260305007};
    vector<float> centroid_childCluster1_0_32 = {0.249596164629726,0.7565919357648699,2.849459887358432,0.025522360243417197,0.5957740464634024,-0.14688617870744722,-1.554565500533721,-2.328605453931724,0.3631166049291973,-1.404706504010044,-1.4752104961568553};
    vector<float> centroid_childCluster1_0_33 = {3.158328488375947,2.7976016877564507,-1.9735608539596885,-2.631758882828499,1.2045565418067736,2.932791276825889,-2.77861011530759,-0.9199532678633783,2.9897456569811047,-0.37252708980502197,1.487080022179909};
    vector<float> centroid_childCluster1_0_34 = {2.7599710934074184,3.695579675741581,0.8496622438575474,2.6896778558282417,-9.931655583881122,-0.1790802609561724,28.492560801442384,31.51369492738954,3.9037438247631058,-27.937206118551536,-24.81721744611236};
    vector<float> centroid_childCluster1_0_35 = {1.5654216835767758,1.6367085496673384,0.09530157422459033,-1.6909232117316917,1.5735665834931878,1.6974506567622647,-1.2390859079710832,-0.0424983596974613,1.6824661534692038,0.5972575574302383,1.2591898615675754};
    vector<float> centroid_childCluster1_0_36 = {0.7879775487106012,1.123253026610266,1.7653375874905977,-0.7964684576071263,1.3449727683695514,0.7094530958000064,-0.9918693773265883,-0.8905845297862528,0.9449149095483516,-0.12939023534473199,0.17637685539964773};
    vector<float> centroid_childCluster1_0_37 = {2.395481346524138,9.414210099018913,14.659511190256223,0.024181345434499683,-3.4876367734491596,-0.3371290967077136,4.366677734396451,-0.2590222977780243,3.1388168791868556,-13.78800090688118,-15.93106058273829};
    vector<float> centroid_childCluster1_0_38 = {1.9747334337761582,7.066247505192174,14.388184121897439,0.013641719866665243,-1.1003326779548481,-0.9139300694338978,-0.7495541997002397,-3.453744795136773,1.9430158265431414,-8.748665266128528,-11.544133448596977};
    vector<float> centroid_childCluster1_0_39 = {-0.01657576759452268,0.05086869017645795,0.5217980044647039,-0.19133996230017936,0.44278811900897536,0.10825955032213024,0.1402937130298314,0.23721827002214557,0.05531550282195583,0.4994535873903326,0.2940785043046367};
    cv::Mat r1_0_0 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_0.data());
    cv::Mat r1_0_1 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_1.data());
    cv::Mat r1_0_2 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_2.data());
    cv::Mat r1_0_3 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_3.data());
    cv::Mat r1_0_4 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_4.data());
    cv::Mat r1_0_5 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_5.data());
    cv::Mat r1_0_6 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_6.data());
    cv::Mat r1_0_7 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_7.data());
    cv::Mat r1_0_8 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_8.data());
    cv::Mat r1_0_9 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_9.data());
    cv::Mat r1_0_10 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_10.data());
    cv::Mat r1_0_11 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_11.data());
    cv::Mat r1_0_12 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_12.data());
    cv::Mat r1_0_13 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_13.data());
    cv::Mat r1_0_14 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_14.data());
    cv::Mat r1_0_15 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_15.data());
    cv::Mat r1_0_16 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_16.data());
    cv::Mat r1_0_17 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_17.data());
    cv::Mat r1_0_18 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_18.data());
    cv::Mat r1_0_19 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_19.data());
    cv::Mat r1_0_20 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_20.data());
    cv::Mat r1_0_21 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_21.data());
    cv::Mat r1_0_22 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_22.data());
    cv::Mat r1_0_23 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_23.data());
    cv::Mat r1_0_24 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_24.data());
    cv::Mat r1_0_25 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_25.data());
    cv::Mat r1_0_26 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_26.data());
    cv::Mat r1_0_27 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_27.data());
    cv::Mat r1_0_28 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_28.data());
    cv::Mat r1_0_29 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_29.data());
    cv::Mat r1_0_30 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_30.data());
    cv::Mat r1_0_31 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_31.data());
    cv::Mat r1_0_32 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_32.data());
    cv::Mat r1_0_33 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_33.data());
    cv::Mat r1_0_34 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_34.data());
    cv::Mat r1_0_35 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_35.data());
    cv::Mat r1_0_36 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_36.data());
    cv::Mat r1_0_37 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_37.data());
    cv::Mat r1_0_38 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_38.data());
    cv::Mat r1_0_39 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_0_39.data());
    
    
    // parentCluster1 - childCluster1 - grandChild
    vector<float> centroid_childCluster1_1_0 = {-0.006622240203966122,0.12371319175472023,0.4073312778638616,0.20290249081539724,0.0006375321435787469,-0.3629277366977748,-0.7352205871635039,-0.9013343607134658,0.027896566693192897,-0.30172761643977886,-0.3927057416280153};
    vector<float> centroid_childCluster1_1_1 = {0.5054804125433227,0.2951288416041735,0.47811217748583384,-0.7389839438019038,0.7371201920336092,0.7286774011517757,0.5765539316902747,0.6441475953157867,0.40992362079699185,0.7506473621819619,0.7199313092989421};
    vector<float> centroid_childCluster1_1_2 = {3.578669275712771,5.217044528070816,3.9421897145546643,-0.9815134584105794,1.0654214442845666,0.6392672716689503,0.3775171063137346,-0.39163582790622703,3.511521413396403,-0.7541069462638007,-1.5278084437295605};
    vector<float> centroid_childCluster1_1_3 = {1.0183180468952844,2.20260143783564,1.7244032196670898,1.2461987564184371,-1.2455174382728047,-0.9512623005720743,3.8838340750768126,2.482968408922148,2.7785273537499964,-3.2832171526091365,-3.8381002541546283};
    vector<float> centroid_childCluster1_1_4 = {-0.5152552511018852,-0.49895855894514196,-0.45827644972423,0.20254782530202092,-0.2716970457043349,-0.152240218073971,-0.0322867042851065,-0.04690057530825038,-0.5154932886695002,0.030108060732984387,0.12931952803480576};
    vector<float> centroid_childCluster1_1_5 = {-1.2088931487881962,-0.9707276556409112,-1.2816525124637357,1.3120235936043807,-1.3721794814962498,-1.244323459967566,-1.157066404825845,-1.1542495898547296,-1.1136406109611032,-1.1032476470925516,-0.9493608584586946};
    vector<float> centroid_childCluster1_1_6 = {-1.4491637717901917,-1.1232617372103855,-1.6189668890839868,1.924107423472131,-1.8940013224369283,-1.9091149414255273,-1.656411676278588,-1.5715956043862505,-1.3041948327054147,-1.8159987959016026,-1.6908330475244437};
    vector<float> centroid_childCluster1_1_7 = {3.7478121135030458,3.9356822692277555,1.77081135776772,0.7037815854191285,-1.5673215599180115,0.7683455783237395,9.815258705796744,9.443978378702738,6.357706190732247,-4.430614157809753,-4.791970916292739};
    vector<float> centroid_childCluster1_1_8 = {-0.026170666533108747,-0.12110678556986203,0.03572508917377567,-0.28726083798069624,0.2608902007614592,0.2990868256227603,0.31464680525084016,0.3284287210126015,-0.0694990689645868,0.4238185338703135,0.45597112560116543};
    vector<float> centroid_childCluster1_1_9 = {5.2482099674599345,8.727372267905473,4.43932712090317,-1.0267786499895206,0.023371091492832466,1.8617229316824784,4.966178456344934,2.762086575511018,7.118075539244293,-2.61994250963218,-3.3905044103503177};
    vector<float> centroid_childCluster1_1_10 = {1.7482757692428368,1.776205045584181,1.8209813194142777,-0.9930583837542414,1.2169533809535529,0.7915349230375862,-0.3400121722258214,-0.5096920304713182,1.5894083610696104,0.4147672916980292,0.14057510343576965};
    vector<float> centroid_childCluster1_1_11 = {-0.8961200701605986,-0.7638202591048646,-0.8783468666008566,0.741769929614855,-0.8167387908754014,-0.6750473597618294,-0.5849442382968526,-0.6192029437190777,-0.8490290818629637,-0.49424117296985143,-0.3554776333913937};
    vector<float> centroid_childCluster1_1_12 = {1.0537886075619292,0.7163616611425371,0.8383018243123032,-1.1540364995057617,1.1492772139028267,1.1441566700394215,0.786203260383429,0.932689225164445,0.895449198980142,1.0279300387713686,0.9458118023639219};
    vector<float> centroid_childCluster1_1_13 = {0.7074746589034433,1.621886165252885,1.9000393190896385,0.6362092277047763,-0.2762897888995346,-0.9775387188176261,-0.0037243753840710365,-0.643241553589764,1.137904210546779,-1.5877448107638144,-2.1169461702649652};
    vector<float> centroid_childCluster1_1_14 = {-0.835499629163914,-0.3521062566274442,-0.22303593051941717,1.8211013606400903,-1.4157079781642556,-2.0952583951868022,-0.9179940087946463,-1.166750496397924,-0.459907355601807,-2.22149178164397,-2.442154424767151};
    cv::Mat r1_1_0 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_0.data());
    cv::Mat r1_1_1 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_1.data());
    cv::Mat r1_1_2 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_2.data());
    cv::Mat r1_1_3 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_3.data());
    cv::Mat r1_1_4 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_4.data());
    cv::Mat r1_1_5 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_5.data());
    cv::Mat r1_1_6 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_6.data());
    cv::Mat r1_1_7 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_7.data());
    cv::Mat r1_1_8 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_8.data());
    cv::Mat r1_1_9 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_9.data());
    cv::Mat r1_1_10 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_10.data());
    cv::Mat r1_1_11 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_11.data());
    cv::Mat r1_1_12 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_12.data());
    cv::Mat r1_1_13 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_13.data());
    cv::Mat r1_1_14 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_1_14.data());
    
    // parentCluster1 - childCluster2 - grandChild
    vector<float> centroid_childCluster1_2_0 = {0.23416475798167824,-0.2573124782692213,-0.9021969250360478,-0.9231757204371865,-0.6921790752909088,1.28392043558355,-0.8670783436799416,-0.8057739887428488,0.49104679163266796,-0.3320545125813871,-0.014462311224041787};
    vector<float> centroid_childCluster1_2_1 = {-0.6321200878388398,-0.36383907291775847,0.46722460442613883,0.4311166295362001,0.6797353877243908,0.09490021206586392,0.4300987800979915,0.4857288429836925,-0.6459315869614936,0.6770352260692322,0.6464933727026073};
    vector<float> centroid_childCluster1_2_2 = {1.353426014484258,0.0023771098601134658,-1.3354722576601936,-1.209447135914938,-1.5296525009502628,0.5255610672133942,-1.179430818291319,-1.2418877099142809,1.375836674860415,-1.353387082202313,-1.0695868208874875};
    vector<float> centroid_childCluster1_2_3 = {2.283560273574398,0.7618174440186894,-1.3947886395020168,-1.2454258391125996,-1.8053588139089825,-1.173054867073811,-1.2031860957525362,-1.220038281340329,1.90019251209666,-1.9846271940540712,-1.950277087574036};
    vector<float> centroid_childCluster1_2_4 = {-0.32041727125402836,-0.23658249351243085,-0.1696476665354819,-0.3069524388397872,0.13647240536206368,0.7195010638774565,-0.2533979848931236,-0.13703329444912693,-0.15343040926280094,0.28463278514236773,0.4166844755855728};
    vector<float> centroid_childCluster1_2_5 = {-0.500443693646965,2.355145487826637,3.2938201095995234,2.0543830745075224,0.7071189359703547,-2.7459930878228236,1.5399214058512163,0.4045481732673226,-0.44164100278500534,-0.15196269680627705,-1.2530402012689488};
    vector<float> centroid_childCluster1_2_6 = {-0.8436114992446174,-0.524581558252813,1.017289904696561,1.2684562810660225,1.046844504421831,-0.5212825728968155,1.1071250236939723,0.9982357502214714,-1.0603235964854734,0.9461806615379442,0.7724825336335411};
    vector<float> centroid_childCluster1_2_7 = {0.4609080078529854,4.053621696543734,1.678437697503326,1.8964459836850793,-1.1873542216468191,-2.0034969677566803,7.059632911161433,7.795613047988728,1.6095819154392836,-2.737959606236628,-3.813200586609476};
    vector<float> centroid_childCluster1_2_8 = {1.7700961890007103,4.83337411192909,-0.39021980779872756,-0.9000283371832847,-1.4257883150985748,-3.3764726097111732,-0.41367204045319633,0.2846109892439179,1.875599525058737,-2.063725090497158,-2.881724742007038};
    vector<float> centroid_childCluster1_2_9 = {0.4165447642224988,1.045467039647213,-0.30098527980327044,-0.6555054402141239,-0.44786738790568686,-0.16237689067615385,-0.6719011813644468,-0.7324219331027141,0.685039214721085,-0.6729951892729994,-0.7460187031818031};
    cv::Mat r1_2_0 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_0.data());
    cv::Mat r1_2_1 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_1.data());
    cv::Mat r1_2_2 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_2.data());
    cv::Mat r1_2_3 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_3.data());
    cv::Mat r1_2_4 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_4.data());
    cv::Mat r1_2_5 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_5.data());
    cv::Mat r1_2_6 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_6.data());
    cv::Mat r1_2_7 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_7.data());
    cv::Mat r1_2_8 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_8.data());
    cv::Mat r1_2_9 = cv::Mat(numVarANN, 1, CV_32F, centroid_childCluster1_2_9.data());

    

    
    //Declare CHILD LOCAL INPUT & OUTPUT Standardize for CHILD clusters: standardizedX = (X - meanScale) / standardDeviationScale
    // Child of parentCluster0
    std::string cluster0_0_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_0/1000batch_2427epochs_WithEarlyStopping200/";
    std::string cluster0_0_meanScaleINPUTPATH = casePath + cluster0_0_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_0_stdScaleINPUTPATH = casePath + cluster0_0_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_0_meanScaleOUTPUTPATH = casePath + cluster0_0_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_0_stdScaleOUTPUTPATH = casePath + cluster0_0_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_0_meanScaleINPUT;
    vector<float> cluster0_0_stdScaleINPUT;
    vector<float> cluster0_0_meanScaleOUTPUT;
    vector<float> cluster0_0_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_0_meanScaleINPUTPATH, cluster0_0_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_0_stdScaleINPUTPATH, cluster0_0_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_0_meanScaleOUTPUTPATH, cluster0_0_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_0_stdScaleOUTPUTPATH, cluster0_0_stdScaleOUTPUT);
    
    std::string cluster0_1_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_1/900batch_1050epochs_WithEarlyStopping200/";
    std::string cluster0_1_meanScaleINPUTPATH = casePath + cluster0_1_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_1_stdScaleINPUTPATH = casePath + cluster0_1_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_1_meanScaleOUTPUTPATH = casePath + cluster0_1_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_1_stdScaleOUTPUTPATH = casePath + cluster0_1_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_1_meanScaleINPUT;
    vector<float> cluster0_1_stdScaleINPUT;
    vector<float> cluster0_1_meanScaleOUTPUT;
    vector<float> cluster0_1_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_1_meanScaleINPUTPATH, cluster0_1_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_1_stdScaleINPUTPATH, cluster0_1_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_1_meanScaleOUTPUTPATH, cluster0_1_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_1_stdScaleOUTPUTPATH, cluster0_1_stdScaleOUTPUT);
    
    std::string cluster0_2_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_2/3600batch_2080epochs_WithEarlyStopping200/";
    std::string cluster0_2_meanScaleINPUTPATH = casePath + cluster0_2_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_2_stdScaleINPUTPATH = casePath + cluster0_2_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_2_meanScaleOUTPUTPATH = casePath + cluster0_2_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_2_stdScaleOUTPUTPATH = casePath + cluster0_2_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_2_meanScaleINPUT;
    vector<float> cluster0_2_stdScaleINPUT;
    vector<float> cluster0_2_meanScaleOUTPUT;
    vector<float> cluster0_2_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_2_meanScaleINPUTPATH, cluster0_2_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_2_stdScaleINPUTPATH, cluster0_2_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_2_meanScaleOUTPUTPATH, cluster0_2_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_2_stdScaleOUTPUTPATH, cluster0_2_stdScaleOUTPUT);
    
    std::string cluster0_3_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_3/790batch_1673epochs_WithEarlyStopping200/";
    std::string cluster0_3_meanScaleINPUTPATH = casePath + cluster0_3_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_3_stdScaleINPUTPATH = casePath + cluster0_3_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_3_meanScaleOUTPUTPATH = casePath + cluster0_3_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_3_stdScaleOUTPUTPATH = casePath + cluster0_3_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_3_meanScaleINPUT;
    vector<float> cluster0_3_stdScaleINPUT;
    vector<float> cluster0_3_meanScaleOUTPUT;
    vector<float> cluster0_3_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_3_meanScaleINPUTPATH, cluster0_3_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_3_stdScaleINPUTPATH, cluster0_3_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_3_meanScaleOUTPUTPATH, cluster0_3_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_3_stdScaleOUTPUTPATH, cluster0_3_stdScaleOUTPUT);
    
    std::string cluster0_4_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_4/600batch_1131epochs_WithEarlyStopping200/";
    std::string cluster0_4_meanScaleINPUTPATH = casePath + cluster0_4_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_4_stdScaleINPUTPATH = casePath + cluster0_4_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_4_meanScaleOUTPUTPATH = casePath + cluster0_4_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_4_stdScaleOUTPUTPATH = casePath + cluster0_4_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_4_meanScaleINPUT;
    vector<float> cluster0_4_stdScaleINPUT;
    vector<float> cluster0_4_meanScaleOUTPUT;
    vector<float> cluster0_4_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_4_meanScaleINPUTPATH, cluster0_4_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_4_stdScaleINPUTPATH, cluster0_4_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_4_meanScaleOUTPUTPATH, cluster0_4_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_4_stdScaleOUTPUTPATH, cluster0_4_stdScaleOUTPUT);
    
    std::string cluster0_5_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_5/950batch_616epochs_WithEarlyStopping200/";
    std::string cluster0_5_meanScaleINPUTPATH = casePath + cluster0_5_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_5_stdScaleINPUTPATH = casePath + cluster0_5_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_5_meanScaleOUTPUTPATH = casePath + cluster0_5_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_5_stdScaleOUTPUTPATH = casePath + cluster0_5_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_5_meanScaleINPUT;
    vector<float> cluster0_5_stdScaleINPUT;
    vector<float> cluster0_5_meanScaleOUTPUT;
    vector<float> cluster0_5_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_5_meanScaleINPUTPATH, cluster0_5_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_5_stdScaleINPUTPATH, cluster0_5_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_5_meanScaleOUTPUTPATH, cluster0_5_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_5_stdScaleOUTPUTPATH, cluster0_5_stdScaleOUTPUT);
    
    std::string cluster0_6_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_6/200batch_725epochs_WithEarlyStopping200/";
    std::string cluster0_6_meanScaleINPUTPATH = casePath + cluster0_6_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_6_stdScaleINPUTPATH = casePath + cluster0_6_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_6_meanScaleOUTPUTPATH = casePath + cluster0_6_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_6_stdScaleOUTPUTPATH = casePath + cluster0_6_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_6_meanScaleINPUT;
    vector<float> cluster0_6_stdScaleINPUT;
    vector<float> cluster0_6_meanScaleOUTPUT;
    vector<float> cluster0_6_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_6_meanScaleINPUTPATH, cluster0_6_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_6_stdScaleINPUTPATH, cluster0_6_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_6_meanScaleOUTPUTPATH, cluster0_6_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_6_stdScaleOUTPUTPATH, cluster0_6_stdScaleOUTPUT);
    
    std::string cluster0_7_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_7/430batch_1579epochs_WithEarlyStopping200/";
    std::string cluster0_7_meanScaleINPUTPATH = casePath + cluster0_7_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_7_stdScaleINPUTPATH = casePath + cluster0_7_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_7_meanScaleOUTPUTPATH = casePath + cluster0_7_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_7_stdScaleOUTPUTPATH = casePath + cluster0_7_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_7_meanScaleINPUT;
    vector<float> cluster0_7_stdScaleINPUT;
    vector<float> cluster0_7_meanScaleOUTPUT;
    vector<float> cluster0_7_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_7_meanScaleINPUTPATH, cluster0_7_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_7_stdScaleINPUTPATH, cluster0_7_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_7_meanScaleOUTPUTPATH, cluster0_7_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_7_stdScaleOUTPUTPATH, cluster0_7_stdScaleOUTPUT);
    
    std::string cluster0_8_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_8/1000batch_568epochs_WithEarlyStopping200/";
    std::string cluster0_8_meanScaleINPUTPATH = casePath + cluster0_8_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_8_stdScaleINPUTPATH = casePath + cluster0_8_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_8_meanScaleOUTPUTPATH = casePath + cluster0_8_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_8_stdScaleOUTPUTPATH = casePath + cluster0_8_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_8_meanScaleINPUT;
    vector<float> cluster0_8_stdScaleINPUT;
    vector<float> cluster0_8_meanScaleOUTPUT;
    vector<float> cluster0_8_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_8_meanScaleINPUTPATH, cluster0_8_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_8_stdScaleINPUTPATH, cluster0_8_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_8_meanScaleOUTPUTPATH, cluster0_8_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_8_stdScaleOUTPUTPATH, cluster0_8_stdScaleOUTPUT);
    
    std::string cluster0_9_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_9/50batch_699epochs_WithEarlyStopping200/";
    std::string cluster0_9_meanScaleINPUTPATH = casePath + cluster0_9_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_9_stdScaleINPUTPATH = casePath + cluster0_9_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_9_meanScaleOUTPUTPATH = casePath + cluster0_9_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_9_stdScaleOUTPUTPATH = casePath + cluster0_9_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_9_meanScaleINPUT;
    vector<float> cluster0_9_stdScaleINPUT;
    vector<float> cluster0_9_meanScaleOUTPUT;
    vector<float> cluster0_9_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_9_meanScaleINPUTPATH, cluster0_9_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_9_stdScaleINPUTPATH, cluster0_9_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_9_meanScaleOUTPUTPATH, cluster0_9_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_9_stdScaleOUTPUTPATH, cluster0_9_stdScaleOUTPUT);
    
    std::string cluster0_10_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_10/4200batch_386epochs_WithEarlyStopping200/";
    std::string cluster0_10_meanScaleINPUTPATH = casePath + cluster0_10_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_10_stdScaleINPUTPATH = casePath + cluster0_10_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_10_meanScaleOUTPUTPATH = casePath + cluster0_10_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_10_stdScaleOUTPUTPATH = casePath + cluster0_10_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_10_meanScaleINPUT;
    vector<float> cluster0_10_stdScaleINPUT;
    vector<float> cluster0_10_meanScaleOUTPUT;
    vector<float> cluster0_10_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_10_meanScaleINPUTPATH, cluster0_10_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_10_stdScaleINPUTPATH, cluster0_10_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_10_meanScaleOUTPUTPATH, cluster0_10_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_10_stdScaleOUTPUTPATH, cluster0_10_stdScaleOUTPUT);
    
    std::string cluster0_11_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_11/240batch_928epochs_WithEarlyStopping200/";
    std::string cluster0_11_meanScaleINPUTPATH = casePath + cluster0_11_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_11_stdScaleINPUTPATH = casePath + cluster0_11_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_11_meanScaleOUTPUTPATH = casePath + cluster0_11_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_11_stdScaleOUTPUTPATH = casePath + cluster0_11_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_11_meanScaleINPUT;
    vector<float> cluster0_11_stdScaleINPUT;
    vector<float> cluster0_11_meanScaleOUTPUT;
    vector<float> cluster0_11_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_11_meanScaleINPUTPATH, cluster0_11_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_11_stdScaleINPUTPATH, cluster0_11_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_11_meanScaleOUTPUTPATH, cluster0_11_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_11_stdScaleOUTPUTPATH, cluster0_11_stdScaleOUTPUT);
    
    std::string cluster0_12_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_12/230batch_2547epochs_WithEarlyStopping200/";
    std::string cluster0_12_meanScaleINPUTPATH = casePath + cluster0_12_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_12_stdScaleINPUTPATH = casePath + cluster0_12_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_12_meanScaleOUTPUTPATH = casePath + cluster0_12_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_12_stdScaleOUTPUTPATH = casePath + cluster0_12_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_12_meanScaleINPUT;
    vector<float> cluster0_12_stdScaleINPUT;
    vector<float> cluster0_12_meanScaleOUTPUT;
    vector<float> cluster0_12_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_12_meanScaleINPUTPATH, cluster0_12_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_12_stdScaleINPUTPATH, cluster0_12_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_12_meanScaleOUTPUTPATH, cluster0_12_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_12_stdScaleOUTPUTPATH, cluster0_12_stdScaleOUTPUT);
    
    std::string cluster0_13_Folder = "ANNReg_parentCluster0/ANNReg_childCluster0_13/900batch_1231epochs_WithEarlyStopping200/";
    std::string cluster0_13_meanScaleINPUTPATH = casePath + cluster0_13_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster0_13_stdScaleINPUTPATH = casePath + cluster0_13_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster0_13_meanScaleOUTPUTPATH = casePath + cluster0_13_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster0_13_stdScaleOUTPUTPATH = casePath + cluster0_13_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster0_13_meanScaleINPUT;
    vector<float> cluster0_13_stdScaleINPUT;
    vector<float> cluster0_13_meanScaleOUTPUT;
    vector<float> cluster0_13_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster0_13_meanScaleINPUTPATH, cluster0_13_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_13_stdScaleINPUTPATH, cluster0_13_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster0_13_meanScaleOUTPUTPATH, cluster0_13_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster0_13_stdScaleOUTPUTPATH, cluster0_13_stdScaleOUTPUT);
    
    
    // Child of parentCluster1: child1_0, child1_1, child1_2
    std::string cluster1_0_meanScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/childCluster0_40grandChild/scalerParentCluster1_childCluster0_OnlyMean.txt";
    vector<float> cluster1_0_meanScaleINPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_meanScaleINPUTPATH, cluster1_0_meanScaleINPUT);
    std::string cluster1_0_stdScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/childCluster0_40grandChild/scalerParentCluster1_childCluster0_OnlyStandardDeviation.txt";
    vector<float> cluster1_0_stdScaleINPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_stdScaleINPUTPATH, cluster1_0_stdScaleINPUT);
    
    std::string cluster1_1_meanScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/childCluster1_15grandChild/scalerParentCluster1_childCluster1_OnlyMean.txt";
    vector<float> cluster1_1_meanScaleINPUT;
    readFromCommaDelimitedFile_Float(cluster1_1_meanScaleINPUTPATH, cluster1_1_meanScaleINPUT);
    std::string cluster1_1_stdScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/childCluster1_15grandChild/scalerParentCluster1_childCluster1_OnlyStandardDeviation.txt";
    vector<float> cluster1_1_stdScaleINPUT;
    readFromCommaDelimitedFile_Float(cluster1_1_stdScaleINPUTPATH, cluster1_1_stdScaleINPUT);
    
    std::string cluster1_2_meanScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/childCluster2/scalerParentCluster1_childCluster2_OnlyMean.txt";
    vector<float> cluster1_2_meanScaleINPUT;
    readFromCommaDelimitedFile_Float(cluster1_2_meanScaleINPUTPATH, cluster1_2_meanScaleINPUT);
    std::string cluster1_2_stdScaleINPUTPATH = casePath + "0.treatedFile/parentCluster1/childCluster2/scalerParentCluster1_childCluster2_OnlyStandardDeviation.txt";
    vector<float> cluster1_2_stdScaleINPUT;
    readFromCommaDelimitedFile_Float(cluster1_2_stdScaleINPUTPATH, cluster1_2_stdScaleINPUT);
    

    // Grand child of parentCluster1
        // parentCluster1 - childCluster0
    std::string cluster1_0_0_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_0/1200batch_1849epochs_WithEarlyStopping200/";
    std::string cluster1_0_0_meanScaleINPUTPATH = casePath + cluster1_0_0_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_0_stdScaleINPUTPATH = casePath + cluster1_0_0_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_0_meanScaleOUTPUTPATH = casePath + cluster1_0_0_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_0_stdScaleOUTPUTPATH = casePath + cluster1_0_0_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_0_meanScaleINPUT;
    vector<float> cluster1_0_0_stdScaleINPUT;
    vector<float> cluster1_0_0_meanScaleOUTPUT;
    vector<float> cluster1_0_0_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_0_meanScaleINPUTPATH, cluster1_0_0_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_0_stdScaleINPUTPATH, cluster1_0_0_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_0_meanScaleOUTPUTPATH, cluster1_0_0_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_0_stdScaleOUTPUTPATH, cluster1_0_0_stdScaleOUTPUT);
    
    std::string cluster1_0_1_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_1/3700batch_2236epochs_WithEarlyStopping200/";
    std::string cluster1_0_1_meanScaleINPUTPATH = casePath + cluster1_0_1_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_1_stdScaleINPUTPATH = casePath + cluster1_0_1_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_1_meanScaleOUTPUTPATH = casePath + cluster1_0_1_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_1_stdScaleOUTPUTPATH = casePath + cluster1_0_1_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_1_meanScaleINPUT;
    vector<float> cluster1_0_1_stdScaleINPUT;
    vector<float> cluster1_0_1_meanScaleOUTPUT;
    vector<float> cluster1_0_1_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_1_meanScaleINPUTPATH, cluster1_0_1_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_1_stdScaleINPUTPATH, cluster1_0_1_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_1_meanScaleOUTPUTPATH, cluster1_0_1_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_1_stdScaleOUTPUTPATH, cluster1_0_1_stdScaleOUTPUT);
    
    std::string cluster1_0_2_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_2/4100batch_2828epochs_WithEarlyStopping200/";
    std::string cluster1_0_2_meanScaleINPUTPATH = casePath + cluster1_0_2_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_2_stdScaleINPUTPATH = casePath + cluster1_0_2_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_2_meanScaleOUTPUTPATH = casePath + cluster1_0_2_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_2_stdScaleOUTPUTPATH = casePath + cluster1_0_2_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_2_meanScaleINPUT;
    vector<float> cluster1_0_2_stdScaleINPUT;
    vector<float> cluster1_0_2_meanScaleOUTPUT;
    vector<float> cluster1_0_2_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_2_meanScaleINPUTPATH, cluster1_0_2_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_2_stdScaleINPUTPATH, cluster1_0_2_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_2_meanScaleOUTPUTPATH, cluster1_0_2_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_2_stdScaleOUTPUTPATH, cluster1_0_2_stdScaleOUTPUT);
    
    std::string cluster1_0_3_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_3/1000batch_3019epochs_WithEarlyStopping200/";
    std::string cluster1_0_3_meanScaleINPUTPATH = casePath + cluster1_0_3_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_3_stdScaleINPUTPATH = casePath + cluster1_0_3_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_3_meanScaleOUTPUTPATH = casePath + cluster1_0_3_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_3_stdScaleOUTPUTPATH = casePath + cluster1_0_3_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_3_meanScaleINPUT;
    vector<float> cluster1_0_3_stdScaleINPUT;
    vector<float> cluster1_0_3_meanScaleOUTPUT;
    vector<float> cluster1_0_3_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_3_meanScaleINPUTPATH, cluster1_0_3_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_3_stdScaleINPUTPATH, cluster1_0_3_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_3_meanScaleOUTPUTPATH, cluster1_0_3_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_3_stdScaleOUTPUTPATH, cluster1_0_3_stdScaleOUTPUT);
    
    std::string cluster1_0_4_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_4/6batch_1098epochs_WithEarlyStopping200/";
    std::string cluster1_0_4_meanScaleINPUTPATH = casePath + cluster1_0_4_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_4_stdScaleINPUTPATH = casePath + cluster1_0_4_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_4_meanScaleOUTPUTPATH = casePath + cluster1_0_4_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_4_stdScaleOUTPUTPATH = casePath + cluster1_0_4_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_4_meanScaleINPUT;
    vector<float> cluster1_0_4_stdScaleINPUT;
    vector<float> cluster1_0_4_meanScaleOUTPUT;
    vector<float> cluster1_0_4_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_4_meanScaleINPUTPATH, cluster1_0_4_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_4_stdScaleINPUTPATH, cluster1_0_4_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_4_meanScaleOUTPUTPATH, cluster1_0_4_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_4_stdScaleOUTPUTPATH, cluster1_0_4_stdScaleOUTPUT);
    
    std::string cluster1_0_5_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_5/35batch_1746epochs_WithEarlyStopping200/";
    std::string cluster1_0_5_meanScaleINPUTPATH = casePath + cluster1_0_5_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_5_stdScaleINPUTPATH = casePath + cluster1_0_5_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_5_meanScaleOUTPUTPATH = casePath + cluster1_0_5_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_5_stdScaleOUTPUTPATH = casePath + cluster1_0_5_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_5_meanScaleINPUT;
    vector<float> cluster1_0_5_stdScaleINPUT;
    vector<float> cluster1_0_5_meanScaleOUTPUT;
    vector<float> cluster1_0_5_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_5_meanScaleINPUTPATH, cluster1_0_5_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_5_stdScaleINPUTPATH, cluster1_0_5_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_5_meanScaleOUTPUTPATH, cluster1_0_5_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_5_stdScaleOUTPUTPATH, cluster1_0_5_stdScaleOUTPUT);
    
    std::string cluster1_0_6_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_6/1800batch_2372epochs_WithEarlyStopping200/";
    std::string cluster1_0_6_meanScaleINPUTPATH = casePath + cluster1_0_6_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_6_stdScaleINPUTPATH = casePath + cluster1_0_6_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_6_meanScaleOUTPUTPATH = casePath + cluster1_0_6_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_6_stdScaleOUTPUTPATH = casePath + cluster1_0_6_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_6_meanScaleINPUT;
    vector<float> cluster1_0_6_stdScaleINPUT;
    vector<float> cluster1_0_6_meanScaleOUTPUT;
    vector<float> cluster1_0_6_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_6_meanScaleINPUTPATH, cluster1_0_6_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_6_stdScaleINPUTPATH, cluster1_0_6_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_6_meanScaleOUTPUTPATH, cluster1_0_6_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_6_stdScaleOUTPUTPATH, cluster1_0_6_stdScaleOUTPUT);
    
    std::string cluster1_0_7_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_7/6200batch_3129epochs_WithEarlyStopping200/";
    std::string cluster1_0_7_meanScaleINPUTPATH = casePath + cluster1_0_7_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_7_stdScaleINPUTPATH = casePath + cluster1_0_7_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_7_meanScaleOUTPUTPATH = casePath + cluster1_0_7_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_7_stdScaleOUTPUTPATH = casePath + cluster1_0_7_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_7_meanScaleINPUT;
    vector<float> cluster1_0_7_stdScaleINPUT;
    vector<float> cluster1_0_7_meanScaleOUTPUT;
    vector<float> cluster1_0_7_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_7_meanScaleINPUTPATH, cluster1_0_7_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_7_stdScaleINPUTPATH, cluster1_0_7_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_7_meanScaleOUTPUTPATH, cluster1_0_7_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_7_stdScaleOUTPUTPATH, cluster1_0_7_stdScaleOUTPUT);
    
    std::string cluster1_0_8_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_8/3058batch_2874epochs_WithEarlyStopping200/";
    std::string cluster1_0_8_meanScaleINPUTPATH = casePath + cluster1_0_8_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_8_stdScaleINPUTPATH = casePath + cluster1_0_8_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_8_meanScaleOUTPUTPATH = casePath + cluster1_0_8_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_8_stdScaleOUTPUTPATH = casePath + cluster1_0_8_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_8_meanScaleINPUT;
    vector<float> cluster1_0_8_stdScaleINPUT;
    vector<float> cluster1_0_8_meanScaleOUTPUT;
    vector<float> cluster1_0_8_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_8_meanScaleINPUTPATH, cluster1_0_8_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_8_stdScaleINPUTPATH, cluster1_0_8_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_8_meanScaleOUTPUTPATH, cluster1_0_8_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_8_stdScaleOUTPUTPATH, cluster1_0_8_stdScaleOUTPUT);
    
    std::string cluster1_0_9_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_9/90batch_1644epochs_WithEarlyStopping200/";
    std::string cluster1_0_9_meanScaleINPUTPATH = casePath + cluster1_0_9_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_9_stdScaleINPUTPATH = casePath + cluster1_0_9_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_9_meanScaleOUTPUTPATH = casePath + cluster1_0_9_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_9_stdScaleOUTPUTPATH = casePath + cluster1_0_9_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_9_meanScaleINPUT;
    vector<float> cluster1_0_9_stdScaleINPUT;
    vector<float> cluster1_0_9_meanScaleOUTPUT;
    vector<float> cluster1_0_9_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_9_meanScaleINPUTPATH, cluster1_0_9_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_9_stdScaleINPUTPATH, cluster1_0_9_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_9_meanScaleOUTPUTPATH, cluster1_0_9_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_9_stdScaleOUTPUTPATH, cluster1_0_9_stdScaleOUTPUT);
    
    std::string cluster1_0_10_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_10/3batch_368epochs_WithEarlyStopping200/";
    std::string cluster1_0_10_meanScaleINPUTPATH = casePath + cluster1_0_10_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_10_stdScaleINPUTPATH = casePath + cluster1_0_10_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_10_meanScaleOUTPUTPATH = casePath + cluster1_0_10_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_10_stdScaleOUTPUTPATH = casePath + cluster1_0_10_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_10_meanScaleINPUT;
    vector<float> cluster1_0_10_stdScaleINPUT;
    vector<float> cluster1_0_10_meanScaleOUTPUT;
    vector<float> cluster1_0_10_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_10_meanScaleINPUTPATH, cluster1_0_10_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_10_stdScaleINPUTPATH, cluster1_0_10_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_10_meanScaleOUTPUTPATH, cluster1_0_10_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_10_stdScaleOUTPUTPATH, cluster1_0_10_stdScaleOUTPUT);
    
    std::string cluster1_0_11_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_11/16936batch_3633epochs_WithEarlyStopping200/";
    std::string cluster1_0_11_meanScaleINPUTPATH = casePath + cluster1_0_11_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_11_stdScaleINPUTPATH = casePath + cluster1_0_11_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_11_meanScaleOUTPUTPATH = casePath + cluster1_0_11_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_11_stdScaleOUTPUTPATH = casePath + cluster1_0_11_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_11_meanScaleINPUT;
    vector<float> cluster1_0_11_stdScaleINPUT;
    vector<float> cluster1_0_11_meanScaleOUTPUT;
    vector<float> cluster1_0_11_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_11_meanScaleINPUTPATH, cluster1_0_11_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_11_stdScaleINPUTPATH, cluster1_0_11_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_11_meanScaleOUTPUTPATH, cluster1_0_11_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_11_stdScaleOUTPUTPATH, cluster1_0_11_stdScaleOUTPUT);
    
    std::string cluster1_0_12_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_12/2111batch_3211epochs_WithEarlyStopping200/";
    std::string cluster1_0_12_meanScaleINPUTPATH = casePath + cluster1_0_12_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_12_stdScaleINPUTPATH = casePath + cluster1_0_12_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_12_meanScaleOUTPUTPATH = casePath + cluster1_0_12_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_12_stdScaleOUTPUTPATH = casePath + cluster1_0_12_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_12_meanScaleINPUT;
    vector<float> cluster1_0_12_stdScaleINPUT;
    vector<float> cluster1_0_12_meanScaleOUTPUT;
    vector<float> cluster1_0_12_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_12_meanScaleINPUTPATH, cluster1_0_12_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_12_stdScaleINPUTPATH, cluster1_0_12_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_12_meanScaleOUTPUTPATH, cluster1_0_12_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_12_stdScaleOUTPUTPATH, cluster1_0_12_stdScaleOUTPUT);
    
    std::string cluster1_0_13_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_13/5555batch_2179epochs_WithEarlyStopping200/";
    std::string cluster1_0_13_meanScaleINPUTPATH = casePath + cluster1_0_13_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_13_stdScaleINPUTPATH = casePath + cluster1_0_13_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_13_meanScaleOUTPUTPATH = casePath + cluster1_0_13_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_13_stdScaleOUTPUTPATH = casePath + cluster1_0_13_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_13_meanScaleINPUT;
    vector<float> cluster1_0_13_stdScaleINPUT;
    vector<float> cluster1_0_13_meanScaleOUTPUT;
    vector<float> cluster1_0_13_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_13_meanScaleINPUTPATH, cluster1_0_13_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_13_stdScaleINPUTPATH, cluster1_0_13_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_13_meanScaleOUTPUTPATH, cluster1_0_13_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_13_stdScaleOUTPUTPATH, cluster1_0_13_stdScaleOUTPUT);
    
    std::string cluster1_0_14_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_14/11batch_648epochs_WithEarlyStopping200/";
    std::string cluster1_0_14_meanScaleINPUTPATH = casePath + cluster1_0_14_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_14_stdScaleINPUTPATH = casePath + cluster1_0_14_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_14_meanScaleOUTPUTPATH = casePath + cluster1_0_14_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_14_stdScaleOUTPUTPATH = casePath + cluster1_0_14_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_14_meanScaleINPUT;
    vector<float> cluster1_0_14_stdScaleINPUT;
    vector<float> cluster1_0_14_meanScaleOUTPUT;
    vector<float> cluster1_0_14_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_14_meanScaleINPUTPATH, cluster1_0_14_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_14_stdScaleINPUTPATH, cluster1_0_14_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_14_meanScaleOUTPUTPATH, cluster1_0_14_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_14_stdScaleOUTPUTPATH, cluster1_0_14_stdScaleOUTPUT);
    
    std::string cluster1_0_15_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_15/1502batch_3399epochs_WithEarlyStopping200/";
    std::string cluster1_0_15_meanScaleINPUTPATH = casePath + cluster1_0_15_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_15_stdScaleINPUTPATH = casePath + cluster1_0_15_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_15_meanScaleOUTPUTPATH = casePath + cluster1_0_15_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_15_stdScaleOUTPUTPATH = casePath + cluster1_0_15_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_15_meanScaleINPUT;
    vector<float> cluster1_0_15_stdScaleINPUT;
    vector<float> cluster1_0_15_meanScaleOUTPUT;
    vector<float> cluster1_0_15_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_15_meanScaleINPUTPATH, cluster1_0_15_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_15_stdScaleINPUTPATH, cluster1_0_15_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_15_meanScaleOUTPUTPATH, cluster1_0_15_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_15_stdScaleOUTPUTPATH, cluster1_0_15_stdScaleOUTPUT);
    
    std::string cluster1_0_16_Folder = "NNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_16/898batch_1791epochs_WithEarlyStopping200/";
    std::string cluster1_0_16_meanScaleINPUTPATH = casePath + cluster1_0_16_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_16_stdScaleINPUTPATH = casePath + cluster1_0_16_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_16_meanScaleOUTPUTPATH = casePath + cluster1_0_16_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_16_stdScaleOUTPUTPATH = casePath + cluster1_0_16_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_16_meanScaleINPUT;
    vector<float> cluster1_0_16_stdScaleINPUT;
    vector<float> cluster1_0_16_meanScaleOUTPUT;
    vector<float> cluster1_0_16_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_16_meanScaleINPUTPATH, cluster1_0_16_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_16_stdScaleINPUTPATH, cluster1_0_16_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_16_meanScaleOUTPUTPATH, cluster1_0_16_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_16_stdScaleOUTPUTPATH, cluster1_0_16_stdScaleOUTPUT);
    
    std::string cluster1_0_17_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_17/5batch_827epochs_WithEarlyStopping200/";
    std::string cluster1_0_17_meanScaleINPUTPATH = casePath + cluster1_0_17_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_17_stdScaleINPUTPATH = casePath + cluster1_0_17_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_17_meanScaleOUTPUTPATH = casePath + cluster1_0_17_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_17_stdScaleOUTPUTPATH = casePath + cluster1_0_17_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_17_meanScaleINPUT;
    vector<float> cluster1_0_17_stdScaleINPUT;
    vector<float> cluster1_0_17_meanScaleOUTPUT;
    vector<float> cluster1_0_17_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_17_meanScaleINPUTPATH, cluster1_0_17_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_17_stdScaleINPUTPATH, cluster1_0_17_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_17_meanScaleOUTPUTPATH, cluster1_0_17_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_17_stdScaleOUTPUTPATH, cluster1_0_17_stdScaleOUTPUT);
    
    std::string cluster1_0_18_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_18/2923batch_2709epochs_WithEarlyStopping200/";
    std::string cluster1_0_18_meanScaleINPUTPATH = casePath + cluster1_0_18_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_18_stdScaleINPUTPATH = casePath + cluster1_0_18_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_18_meanScaleOUTPUTPATH = casePath + cluster1_0_18_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_18_stdScaleOUTPUTPATH = casePath + cluster1_0_18_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_18_meanScaleINPUT;
    vector<float> cluster1_0_18_stdScaleINPUT;
    vector<float> cluster1_0_18_meanScaleOUTPUT;
    vector<float> cluster1_0_18_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_18_meanScaleINPUTPATH, cluster1_0_18_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_18_stdScaleINPUTPATH, cluster1_0_18_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_18_meanScaleOUTPUTPATH, cluster1_0_18_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_18_stdScaleOUTPUTPATH, cluster1_0_18_stdScaleOUTPUT);
    
    std::string cluster1_0_19_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_19/13377batch_2575epochs_WithEarlyStopping200/";
    std::string cluster1_0_19_meanScaleINPUTPATH = casePath + cluster1_0_19_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_19_stdScaleINPUTPATH = casePath + cluster1_0_19_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_19_meanScaleOUTPUTPATH = casePath + cluster1_0_19_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_19_stdScaleOUTPUTPATH = casePath + cluster1_0_19_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_19_meanScaleINPUT;
    vector<float> cluster1_0_19_stdScaleINPUT;
    vector<float> cluster1_0_19_meanScaleOUTPUT;
    vector<float> cluster1_0_19_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_19_meanScaleINPUTPATH, cluster1_0_19_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_19_stdScaleINPUTPATH, cluster1_0_19_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_19_meanScaleOUTPUTPATH, cluster1_0_19_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_19_stdScaleOUTPUTPATH, cluster1_0_19_stdScaleOUTPUT);
    
    std::string cluster1_0_20_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_20/4795batch_3170epochs_WithEarlyStopping200/";
    std::string cluster1_0_20_meanScaleINPUTPATH = casePath + cluster1_0_20_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_20_stdScaleINPUTPATH = casePath + cluster1_0_20_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_20_meanScaleOUTPUTPATH = casePath + cluster1_0_20_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_20_stdScaleOUTPUTPATH = casePath + cluster1_0_20_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_20_meanScaleINPUT;
    vector<float> cluster1_0_20_stdScaleINPUT;
    vector<float> cluster1_0_20_meanScaleOUTPUT;
    vector<float> cluster1_0_20_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_20_meanScaleINPUTPATH, cluster1_0_20_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_20_stdScaleINPUTPATH, cluster1_0_20_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_20_meanScaleOUTPUTPATH, cluster1_0_20_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_20_stdScaleOUTPUTPATH, cluster1_0_20_stdScaleOUTPUT);
    
    std::string cluster1_0_21_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_21/86batch_1601epochs_WithEarlyStopping200/";
    std::string cluster1_0_21_meanScaleINPUTPATH = casePath + cluster1_0_21_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_21_stdScaleINPUTPATH = casePath + cluster1_0_21_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_21_meanScaleOUTPUTPATH = casePath + cluster1_0_21_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_21_stdScaleOUTPUTPATH = casePath + cluster1_0_21_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_21_meanScaleINPUT;
    vector<float> cluster1_0_21_stdScaleINPUT;
    vector<float> cluster1_0_21_meanScaleOUTPUT;
    vector<float> cluster1_0_21_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_21_meanScaleINPUTPATH, cluster1_0_21_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_21_stdScaleINPUTPATH, cluster1_0_21_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_21_meanScaleOUTPUTPATH, cluster1_0_21_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_21_stdScaleOUTPUTPATH, cluster1_0_21_stdScaleOUTPUT);
    
    std::string cluster1_0_22_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_22/7873batch_3866epochs_WithEarlyStopping200/";
    std::string cluster1_0_22_meanScaleINPUTPATH = casePath + cluster1_0_22_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_22_stdScaleINPUTPATH = casePath + cluster1_0_22_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_22_meanScaleOUTPUTPATH = casePath + cluster1_0_22_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_22_stdScaleOUTPUTPATH = casePath + cluster1_0_22_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_22_meanScaleINPUT;
    vector<float> cluster1_0_22_stdScaleINPUT;
    vector<float> cluster1_0_22_meanScaleOUTPUT;
    vector<float> cluster1_0_22_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_22_meanScaleINPUTPATH, cluster1_0_22_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_22_stdScaleINPUTPATH, cluster1_0_22_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_22_meanScaleOUTPUTPATH, cluster1_0_22_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_22_stdScaleOUTPUTPATH, cluster1_0_22_stdScaleOUTPUT);
    
    std::string cluster1_0_23_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_23/188batch_1769epochs_WithEarlyStopping200/";
    std::string cluster1_0_23_meanScaleINPUTPATH = casePath + cluster1_0_23_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_23_stdScaleINPUTPATH = casePath + cluster1_0_23_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_23_meanScaleOUTPUTPATH = casePath + cluster1_0_23_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_23_stdScaleOUTPUTPATH = casePath + cluster1_0_23_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_23_meanScaleINPUT;
    vector<float> cluster1_0_23_stdScaleINPUT;
    vector<float> cluster1_0_23_meanScaleOUTPUT;
    vector<float> cluster1_0_23_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_23_meanScaleINPUTPATH, cluster1_0_23_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_23_stdScaleINPUTPATH, cluster1_0_23_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_23_meanScaleOUTPUTPATH, cluster1_0_23_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_23_stdScaleOUTPUTPATH, cluster1_0_23_stdScaleOUTPUT);
    
    std::string cluster1_0_24_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_24/249batch_838epochs_WithEarlyStopping200/";
    std::string cluster1_0_24_meanScaleINPUTPATH = casePath + cluster1_0_24_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_24_stdScaleINPUTPATH = casePath + cluster1_0_24_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_24_meanScaleOUTPUTPATH = casePath + cluster1_0_24_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_24_stdScaleOUTPUTPATH = casePath + cluster1_0_24_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_24_meanScaleINPUT;
    vector<float> cluster1_0_24_stdScaleINPUT;
    vector<float> cluster1_0_24_meanScaleOUTPUT;
    vector<float> cluster1_0_24_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_24_meanScaleINPUTPATH, cluster1_0_24_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_24_stdScaleINPUTPATH, cluster1_0_24_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_24_meanScaleOUTPUTPATH, cluster1_0_24_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_24_stdScaleOUTPUTPATH, cluster1_0_24_stdScaleOUTPUT);
    
    std::string cluster1_0_25_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_25/4batch_450epochs_WithEarlyStopping200/";
    std::string cluster1_0_25_meanScaleINPUTPATH = casePath + cluster1_0_25_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_25_stdScaleINPUTPATH = casePath + cluster1_0_25_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_25_meanScaleOUTPUTPATH = casePath + cluster1_0_25_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_25_stdScaleOUTPUTPATH = casePath + cluster1_0_25_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_25_meanScaleINPUT;
    vector<float> cluster1_0_25_stdScaleINPUT;
    vector<float> cluster1_0_25_meanScaleOUTPUT;
    vector<float> cluster1_0_25_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_25_meanScaleINPUTPATH, cluster1_0_25_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_25_stdScaleINPUTPATH, cluster1_0_25_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_25_meanScaleOUTPUTPATH, cluster1_0_25_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_25_stdScaleOUTPUTPATH, cluster1_0_25_stdScaleOUTPUT);
    
    std::string cluster1_0_26_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_26/13batch_1275epochs_WithEarlyStopping200/";
    std::string cluster1_0_26_meanScaleINPUTPATH = casePath + cluster1_0_26_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_26_stdScaleINPUTPATH = casePath + cluster1_0_26_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_26_meanScaleOUTPUTPATH = casePath + cluster1_0_26_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_26_stdScaleOUTPUTPATH = casePath + cluster1_0_26_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_26_meanScaleINPUT;
    vector<float> cluster1_0_26_stdScaleINPUT;
    vector<float> cluster1_0_26_meanScaleOUTPUT;
    vector<float> cluster1_0_26_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_26_meanScaleINPUTPATH, cluster1_0_26_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_26_stdScaleINPUTPATH, cluster1_0_26_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_26_meanScaleOUTPUTPATH, cluster1_0_26_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_26_stdScaleOUTPUTPATH, cluster1_0_26_stdScaleOUTPUT);
    
    std::string cluster1_0_27_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_27/12696batch_2594epochs_WithEarlyStopping200/";
    std::string cluster1_0_27_meanScaleINPUTPATH = casePath + cluster1_0_27_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_27_stdScaleINPUTPATH = casePath + cluster1_0_27_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_27_meanScaleOUTPUTPATH = casePath + cluster1_0_27_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_27_stdScaleOUTPUTPATH = casePath + cluster1_0_27_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_27_meanScaleINPUT;
    vector<float> cluster1_0_27_stdScaleINPUT;
    vector<float> cluster1_0_27_meanScaleOUTPUT;
    vector<float> cluster1_0_27_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_27_meanScaleINPUTPATH, cluster1_0_27_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_27_stdScaleINPUTPATH, cluster1_0_27_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_27_meanScaleOUTPUTPATH, cluster1_0_27_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_27_stdScaleOUTPUTPATH, cluster1_0_27_stdScaleOUTPUT);
    
    std::string cluster1_0_28_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_28/2492batch_2227epochs_WithEarlyStopping200/";
    std::string cluster1_0_28_meanScaleINPUTPATH = casePath + cluster1_0_28_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_28_stdScaleINPUTPATH = casePath + cluster1_0_28_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_28_meanScaleOUTPUTPATH = casePath + cluster1_0_28_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_28_stdScaleOUTPUTPATH = casePath + cluster1_0_28_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_28_meanScaleINPUT;
    vector<float> cluster1_0_28_stdScaleINPUT;
    vector<float> cluster1_0_28_meanScaleOUTPUT;
    vector<float> cluster1_0_28_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_28_meanScaleINPUTPATH, cluster1_0_28_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_28_stdScaleINPUTPATH, cluster1_0_28_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_28_meanScaleOUTPUTPATH, cluster1_0_28_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_28_stdScaleOUTPUTPATH, cluster1_0_28_stdScaleOUTPUT);
    
    std::string cluster1_0_29_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_29/54batch_1286epochs_WithEarlyStopping200/";
    std::string cluster1_0_29_meanScaleINPUTPATH = casePath + cluster1_0_29_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_29_stdScaleINPUTPATH = casePath + cluster1_0_29_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_29_meanScaleOUTPUTPATH = casePath + cluster1_0_29_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_29_stdScaleOUTPUTPATH = casePath + cluster1_0_29_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_29_meanScaleINPUT;
    vector<float> cluster1_0_29_stdScaleINPUT;
    vector<float> cluster1_0_29_meanScaleOUTPUT;
    vector<float> cluster1_0_29_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_29_meanScaleINPUTPATH, cluster1_0_29_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_29_stdScaleINPUTPATH, cluster1_0_29_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_29_meanScaleOUTPUTPATH, cluster1_0_29_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_29_stdScaleOUTPUTPATH, cluster1_0_29_stdScaleOUTPUT);
    
    std::string cluster1_0_30_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_30/213batch_2006epochs_WithEarlyStopping200/";
    std::string cluster1_0_30_meanScaleINPUTPATH = casePath + cluster1_0_30_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_30_stdScaleINPUTPATH = casePath + cluster1_0_30_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_30_meanScaleOUTPUTPATH = casePath + cluster1_0_30_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_30_stdScaleOUTPUTPATH = casePath + cluster1_0_30_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_30_meanScaleINPUT;
    vector<float> cluster1_0_30_stdScaleINPUT;
    vector<float> cluster1_0_30_meanScaleOUTPUT;
    vector<float> cluster1_0_30_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_30_meanScaleINPUTPATH, cluster1_0_30_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_30_stdScaleINPUTPATH, cluster1_0_30_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_30_meanScaleOUTPUTPATH, cluster1_0_30_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_30_stdScaleOUTPUTPATH, cluster1_0_30_stdScaleOUTPUT);
    
    std::string cluster1_0_31_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_31/1721batch_3501epochs_WithEarlyStopping200/";
    std::string cluster1_0_31_meanScaleINPUTPATH = casePath + cluster1_0_31_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_31_stdScaleINPUTPATH = casePath + cluster1_0_31_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_31_meanScaleOUTPUTPATH = casePath + cluster1_0_31_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_31_stdScaleOUTPUTPATH = casePath + cluster1_0_31_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_31_meanScaleINPUT;
    vector<float> cluster1_0_31_stdScaleINPUT;
    vector<float> cluster1_0_31_meanScaleOUTPUT;
    vector<float> cluster1_0_31_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_31_meanScaleINPUTPATH, cluster1_0_31_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_31_stdScaleINPUTPATH, cluster1_0_31_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_31_meanScaleOUTPUTPATH, cluster1_0_31_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_31_stdScaleOUTPUTPATH, cluster1_0_31_stdScaleOUTPUT);
    
    std::string cluster1_0_32_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_32/133batch_783epochs_WithEarlyStopping200/";
    std::string cluster1_0_32_meanScaleINPUTPATH = casePath + cluster1_0_32_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_32_stdScaleINPUTPATH = casePath + cluster1_0_32_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_32_meanScaleOUTPUTPATH = casePath + cluster1_0_32_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_32_stdScaleOUTPUTPATH = casePath + cluster1_0_32_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_32_meanScaleINPUT;
    vector<float> cluster1_0_32_stdScaleINPUT;
    vector<float> cluster1_0_32_meanScaleOUTPUT;
    vector<float> cluster1_0_32_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_32_meanScaleINPUTPATH, cluster1_0_32_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_32_stdScaleINPUTPATH, cluster1_0_32_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_32_meanScaleOUTPUTPATH, cluster1_0_32_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_32_stdScaleOUTPUTPATH, cluster1_0_32_stdScaleOUTPUT);
    
    std::string cluster1_0_33_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_33/1209batch_2024epochs_WithEarlyStopping200/";
    std::string cluster1_0_33_meanScaleINPUTPATH = casePath + cluster1_0_33_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_33_stdScaleINPUTPATH = casePath + cluster1_0_33_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_33_meanScaleOUTPUTPATH = casePath + cluster1_0_33_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_33_stdScaleOUTPUTPATH = casePath + cluster1_0_33_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_33_meanScaleINPUT;
    vector<float> cluster1_0_33_stdScaleINPUT;
    vector<float> cluster1_0_33_meanScaleOUTPUT;
    vector<float> cluster1_0_33_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_33_meanScaleINPUTPATH, cluster1_0_33_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_33_stdScaleINPUTPATH, cluster1_0_33_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_33_meanScaleOUTPUTPATH, cluster1_0_33_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_33_stdScaleOUTPUTPATH, cluster1_0_33_stdScaleOUTPUT);
    
    std::string cluster1_0_34_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_34/9batch_606epochs_WithEarlyStopping200/";
    std::string cluster1_0_34_meanScaleINPUTPATH = casePath + cluster1_0_34_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_34_stdScaleINPUTPATH = casePath + cluster1_0_34_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_34_meanScaleOUTPUTPATH = casePath + cluster1_0_34_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_34_stdScaleOUTPUTPATH = casePath + cluster1_0_34_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_34_meanScaleINPUT;
    vector<float> cluster1_0_34_stdScaleINPUT;
    vector<float> cluster1_0_34_meanScaleOUTPUT;
    vector<float> cluster1_0_34_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_34_meanScaleINPUTPATH, cluster1_0_34_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_34_stdScaleINPUTPATH, cluster1_0_34_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_34_meanScaleOUTPUTPATH, cluster1_0_34_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_34_stdScaleOUTPUTPATH, cluster1_0_34_stdScaleOUTPUT);
    
    std::string cluster1_0_35_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_35/2242batch_1523epochs_WithEarlyStopping200/";
    std::string cluster1_0_35_meanScaleINPUTPATH = casePath + cluster1_0_35_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_35_stdScaleINPUTPATH = casePath + cluster1_0_35_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_35_meanScaleOUTPUTPATH = casePath + cluster1_0_35_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_35_stdScaleOUTPUTPATH = casePath + cluster1_0_35_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_35_meanScaleINPUT;
    vector<float> cluster1_0_35_stdScaleINPUT;
    vector<float> cluster1_0_35_meanScaleOUTPUT;
    vector<float> cluster1_0_35_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_35_meanScaleINPUTPATH, cluster1_0_35_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_35_stdScaleINPUTPATH, cluster1_0_35_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_35_meanScaleOUTPUTPATH, cluster1_0_35_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_35_stdScaleOUTPUTPATH, cluster1_0_35_stdScaleOUTPUT);
    
    std::string cluster1_0_36_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_36/256batch_2495epochs_WithEarlyStopping200/";
    std::string cluster1_0_36_meanScaleINPUTPATH = casePath + cluster1_0_36_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_36_stdScaleINPUTPATH = casePath + cluster1_0_36_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_36_meanScaleOUTPUTPATH = casePath + cluster1_0_36_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_36_stdScaleOUTPUTPATH = casePath + cluster1_0_36_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_36_meanScaleINPUT;
    vector<float> cluster1_0_36_stdScaleINPUT;
    vector<float> cluster1_0_36_meanScaleOUTPUT;
    vector<float> cluster1_0_36_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_36_meanScaleINPUTPATH, cluster1_0_36_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_36_stdScaleINPUTPATH, cluster1_0_36_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_36_meanScaleOUTPUTPATH, cluster1_0_36_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_36_stdScaleOUTPUTPATH, cluster1_0_36_stdScaleOUTPUT);
    
    std::string cluster1_0_37_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_37/21batch_1630epochs_WithEarlyStopping200/";
    std::string cluster1_0_37_meanScaleINPUTPATH = casePath + cluster1_0_37_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_37_stdScaleINPUTPATH = casePath + cluster1_0_37_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_37_meanScaleOUTPUTPATH = casePath + cluster1_0_37_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_37_stdScaleOUTPUTPATH = casePath + cluster1_0_37_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_37_meanScaleINPUT;
    vector<float> cluster1_0_37_stdScaleINPUT;
    vector<float> cluster1_0_37_meanScaleOUTPUT;
    vector<float> cluster1_0_37_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_37_meanScaleINPUTPATH, cluster1_0_37_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_37_stdScaleINPUTPATH, cluster1_0_37_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_37_meanScaleOUTPUTPATH, cluster1_0_37_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_37_stdScaleOUTPUTPATH, cluster1_0_37_stdScaleOUTPUT);
    
    std::string cluster1_0_38_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_38/39batch_1286epochs_WithEarlyStopping200/";
    std::string cluster1_0_38_meanScaleINPUTPATH = casePath + cluster1_0_38_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_38_stdScaleINPUTPATH = casePath + cluster1_0_38_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_38_meanScaleOUTPUTPATH = casePath + cluster1_0_38_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_38_stdScaleOUTPUTPATH = casePath + cluster1_0_38_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_38_meanScaleINPUT;
    vector<float> cluster1_0_38_stdScaleINPUT;
    vector<float> cluster1_0_38_meanScaleOUTPUT;
    vector<float> cluster1_0_38_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_38_meanScaleINPUTPATH, cluster1_0_38_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_38_stdScaleINPUTPATH, cluster1_0_38_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_38_meanScaleOUTPUTPATH, cluster1_0_38_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_38_stdScaleOUTPUTPATH, cluster1_0_38_stdScaleOUTPUT);
    
    std::string cluster1_0_39_Folder = "ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_39/8736batch_4716epochs_WithEarlyStopping200/";
    std::string cluster1_0_39_meanScaleINPUTPATH = casePath + cluster1_0_39_Folder + "scalerLocal_Input_onlyMean.txt";
    std::string cluster1_0_39_stdScaleINPUTPATH = casePath + cluster1_0_39_Folder + "scalerLocal_Input_onlyStandardDeviation.txt";
    std::string cluster1_0_39_meanScaleOUTPUTPATH = casePath + cluster1_0_39_Folder + "scalerLocal_Label_onlyMean.txt";
    std::string cluster1_0_39_stdScaleOUTPUTPATH = casePath + cluster1_0_39_Folder + "scalerLocal_Label_onlyStandardDeviation.txt";
    vector<float> cluster1_0_39_meanScaleINPUT;
    vector<float> cluster1_0_39_stdScaleINPUT;
    vector<float> cluster1_0_39_meanScaleOUTPUT;
    vector<float> cluster1_0_39_stdScaleOUTPUT;
    readFromCommaDelimitedFile_Float(cluster1_0_39_meanScaleINPUTPATH, cluster1_0_39_meanScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_39_stdScaleINPUTPATH, cluster1_0_39_stdScaleINPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_39_meanScaleOUTPUTPATH, cluster1_0_39_meanScaleOUTPUT);
    readFromCommaDelimitedFile_Float(cluster1_0_39_stdScaleOUTPUTPATH, cluster1_0_39_stdScaleOUTPUT);
    
        // parentCluster1 - childCluster1
    vector<float> cluster1_1_0_meanScaleINPUT = {4.588573205906244969e-05,4.620605540689061436e-05,1.138677198929612631e-02,4.765311321259616539e-01,9.325821676303341218e-03,2.076981273952310456e-02,3.081473096478233489e-05,3.891804671954890581e-07,3.680719131265828420e-02,3.905823641706885896e-01,2.635325802551727065e+03};
    vector<float> cluster1_1_0_stdScaleINPUT = {7.202201911063713920e-06,9.700572734171753202e-06,1.342115094256292503e-03,2.010792966392165038e-02,7.229624817109904945e-04,6.475490990366624192e-04,2.958457433803181829e-06,4.935879351575727202e-08,5.899525410608166473e-03,1.321486639509419914e-02,7.066252367668460010e+01};
    vector<float> cluster1_1_0_meanScaleOUTPUT = {-3.575274239021359560e-07,-4.382373679935012656e-07,-1.725533234577340260e-05,-1.731611793376976237e-04,3.090411430209778982e-06,5.512663066851423360e-06,-1.316793329191952681e-07,-2.932073159076790959e-09,-3.190751517178764792e-04,5.013314856405602518e-04,1.580970516557557382e+00};
    vector<float> cluster1_1_0_stdScaleOUTPUT = {1.779018918929054480e-07,2.106097088692208471e-07,5.393072500325811925e-05,1.290736637445354920e-04,1.173162629861436140e-05,6.249078813127332060e-06,3.915822503006095303e-07,6.020196494875307644e-09,1.485006542544213418e-04,2.333279462381832373e-04,2.654098217539182070e+00};
    
    vector<float> cluster1_1_1_meanScaleINPUT = {5.740172554370344697e-05,5.107313767033279275e-05,1.161726131625368322e-02,4.153769422733138983e-01,1.111315243349473951e-02,2.281895526418601522e-02,4.640898337338842262e-05,6.860907987024518951e-07,4.426097432133259402e-02,4.320341864751914285e-01,2.839495684468490708e+03};
    vector<float> cluster1_1_1_stdScaleINPUT = {3.938135229668329572e-06,4.615352343541716025e-06,5.689493906968898966e-04,8.269023979308016969e-03,3.157584426391473625e-04,2.489814308836928820e-04,2.515612971545456014e-06,5.410742889149037161e-08,3.265107349297563695e-03,4.668265101172396417e-03,2.209629384773536387e+01};
    vector<float> cluster1_1_1_meanScaleOUTPUT = {-8.460135555897565842e-08,-8.973634200338594818e-08,1.732120236305299934e-06,-3.981346561379015865e-05,2.478590455444139685e-06,2.336344371174523246e-07,4.187873370665469795e-08,4.679097635763083022e-10,-6.002870470124425304e-05,9.431757964648923923e-05,2.828002651923238187e-01};
    vector<float> cluster1_1_1_stdScaleOUTPUT = {1.226435138390577117e-07,1.163452275465252486e-07,1.330296995887460474e-05,5.412454882418576957e-05,4.742385064077536269e-06,1.728818919797287537e-06,4.571408991344208411e-08,9.497057375143438361e-10,7.719058110018209057e-05,1.212850353896300032e-04,8.012740363772563601e-01};
    
    vector<float> cluster1_1_2_meanScaleINPUT = {1.266526150908119628e-04,1.911368891559828988e-04,2.299768771367521197e-02,3.994013509615385038e-01,1.191612159455128148e-02,2.266262107371794926e-02,4.402175827991453049e-05,4.869827601495726679e-07,1.049420066773504301e-01,3.728275614316239883e-01,2.427680347222222281e+03};
    vector<float> cluster1_1_2_stdScaleINPUT = {2.202919858089498546e-05,3.798388549640640952e-05,2.043692344973038148e-03,3.717230538437048259e-02,1.464013494260873668e-03,1.048169919572083898e-03,1.162312960665197627e-05,1.059276336061798296e-07,1.569075439308314363e-02,2.837650584498706621e-02,1.453244751192408444e+02};
    vector<float> cluster1_1_2_meanScaleOUTPUT = {-1.822733840811966071e-06,-1.388423076923077000e-06,2.296434294871794600e-04,-1.777997329059828992e-03,1.568736805555555683e-04,-5.353522970085469951e-05,-3.046689102564102395e-06,-3.632984642094016893e-08,-2.539843563034187811e-03,3.990585470085469301e-03,1.029909722222222435e+01};
    vector<float> cluster1_1_2_stdScaleOUTPUT = {1.501459737713599740e-06,1.937613630376629795e-06,3.164897973413117213e-04,8.962651106102142778e-04,7.586666295753679028e-05,5.440538453351809000e-05,2.281331448608954239e-06,3.622070084402927665e-08,1.030528945691135600e-03,1.619160462484118407e-03,8.294542149718319379e+00};
    
    vector<float> cluster1_1_3_meanScaleINPUT = {6.894978925718850166e-05,1.052390374201277873e-04,1.570297264376996696e-02,5.444809133386581124e-01,6.295698011182107937e-03,1.965747492012779457e-02,8.574468945686900825e-05,1.041095700479233180e-06,9.043655447284346116e-02,2.730673270766773020e-01,2.002920770766772876e+03};
    vector<float> cluster1_1_3_stdScaleINPUT = {2.076078852844630529e-05,3.821468202305073719e-05,3.100885313092136691e-03,4.226115568921154364e-02,1.199497935320997192e-03,1.592302386012277781e-03,1.706827962618015810e-05,2.974634722444209520e-07,2.389911514122726108e-02,2.041453590358095413e-02,8.288814135617349166e+01};
    vector<float> cluster1_1_3_meanScaleOUTPUT = {-7.062513538338658508e-06,3.428793929712457516e-07,4.375987619808307345e-04,-2.084876198083068441e-03,6.188962460063896756e-05,2.985111821086260326e-05,-8.940275439297124051e-06,-2.594102008785942443e-07,-2.751102715654952461e-03,4.322513178913738041e-03,1.467539536741214157e+01};
    vector<float> cluster1_1_3_stdScaleOUTPUT = {7.246649687079459028e-06,1.605146948623704389e-06,1.962388009117758383e-04,7.605916247613496656e-04,1.206413172076246275e-04,1.317820970730593818e-04,4.718080002304620861e-06,2.210431983934958059e-07,9.921474026669744976e-04,1.558867604222389592e-03,6.572855279176692989e+00};
    
    vector<float> cluster1_1_4_meanScaleINPUT = {3.442132535614133540e-05,2.846106805010281885e-05,8.536527447373341848e-03,4.765395717143390830e-01,8.662636981304915398e-03,2.116490245840343606e-02,3.917259080575807964e-05,5.533717690783324914e-07,2.618367532435969536e-02,4.036446406618059979e-01,2.731107013273509438e+03};
    vector<float> cluster1_1_4_stdScaleINPUT = {3.623408221816196260e-06,3.920375188814688119e-06,6.810413581284120851e-04,9.884666577318809363e-03,4.301190325746092626e-04,2.663476498278707699e-04,2.404142560613180070e-06,4.746958412170154891e-08,3.093770341864325070e-03,5.464642944841306346e-03,2.444841565729392485e+01};
    vector<float> cluster1_1_4_meanScaleOUTPUT = {-6.625731351654515543e-08,-7.684936997569639561e-08,-2.376257618246399568e-06,-3.039078332398571872e-05,5.196814357823942447e-07,9.943802579921506753e-07,3.304404000747801794e-08,3.441059263413720639e-10,-5.400955879603664816e-05,8.485902037764070491e-05,4.737616376892879178e-01};
    vector<float> cluster1_1_4_stdScaleOUTPUT = {7.115063640234716425e-08,7.299071668164834524e-08,8.569666981143159428e-06,3.320865516162965092e-05,2.934416448764190339e-06,1.450633597206289936e-06,3.296423622900727434e-08,9.336982554481848334e-10,4.967376308728748124e-05,7.804981270733805660e-05,1.021112427348470408e+00};
    
    vector<float> cluster1_1_5_meanScaleINPUT = {1.880621787561762188e-05,1.502824173374469616e-05,5.827761529147046371e-03,5.486013815908511448e-01,5.989790860145213780e-03,1.911465684427845688e-02,2.580088960541882735e-05,3.406322250574126059e-07,1.449823926813426436e-02,3.589980753438957728e-01,2.533188507272262996e+03};
    vector<float> cluster1_1_5_stdScaleINPUT = {4.552830030654967103e-06,5.612555308985778995e-06,1.313052199812495642e-03,1.108984975643422140e-02,6.092760767621287297e-04,3.342709189058675314e-04,2.549990303564558279e-06,4.562750069683393113e-08,4.258566181659831362e-03,7.526713269362678843e-03,4.315894246783848587e+01};
    vector<float> cluster1_1_5_meanScaleOUTPUT = {-9.346556867475469697e-08,-1.049095824537799783e-07,-1.050031617527662316e-05,-3.935848662692192310e-05,-3.638135424157366561e-06,3.712092602472798602e-06,-4.417594005892041124e-08,-9.072431278851284547e-10,-8.738618733907073594e-05,1.372968057714165713e-04,1.011220858753392182e+00};
    vector<float> cluster1_1_5_stdScaleOUTPUT = {8.006587321405450306e-08,8.213458005572783192e-08,1.379130189809882280e-05,4.742211204534749517e-05,3.330548057197583850e-06,2.599369438230112952e-06,1.559487180093235813e-07,2.632013867443980853e-09,7.619798198630154805e-05,1.197194749489077277e-04,1.699665058408598384e+00};
    
    vector<float> cluster1_1_6_meanScaleINPUT = {1.340194601170995305e-05,1.068913394505329665e-05,4.718829188109893887e-03,5.883324032727819120e-01,4.723175744182555452e-03,1.786739854676474767e-02,1.986209183305809913e-05,2.604078353700645342e-07,1.078095968983635959e-02,3.309324618826002262e-01,2.397187832457589138e+03};
    vector<float> cluster1_1_6_stdScaleINPUT = {3.181754308269059198e-06,3.951220892372397552e-06,1.109107154162791492e-03,1.229463195263047828e-02,4.942707212452379000e-04,4.939093201926616139e-04,1.666367048537128524e-06,2.437690541677457444e-08,3.205333422572160737e-03,1.056736499770028793e-02,6.242049356721998521e+01};
    vector<float> cluster1_1_6_meanScaleOUTPUT = {-8.331983125656809624e-08,-9.270382375018766087e-08,-1.382919021167993097e-05,-3.383323825251489795e-05,-5.990499624680977200e-06,4.773376369914427172e-06,-9.822732622729321951e-08,-1.450154090977330874e-09,-8.598220777661013065e-05,1.350950608016813776e-04,1.318981234048942186e+00};
    vector<float> cluster1_1_6_stdScaleOUTPUT = {5.181160812898907741e-08,5.532863390672907401e-08,1.188482527624491525e-05,3.433626984211175402e-05,3.288808235403096286e-06,2.377262576066926900e-06,1.588524854319904934e-07,2.269857255472762807e-09,5.718410217670079576e-05,8.984720537329728910e-05,1.976130856290935656e+00};
    
    vector<float> cluster1_1_7_meanScaleINPUT = {1.305524842379958178e-04,1.547561057411273684e-04,1.585629749478079109e-02,5.091286659707724427e-01,5.512398173277662135e-03,2.289547964509394684e-02,1.563787745302713935e-04,2.382193465553235911e-06,1.605214169102296418e-01,2.277643747390396545e-01,1.827468789144050106e+03};
    vector<float> cluster1_1_7_stdScaleINPUT = {3.726577607045323853e-05,4.988110339083194627e-05,2.459743374251743657e-03,5.247667400269660082e-02,9.046256848833276153e-04,3.344967121278677544e-03,2.357344709880914671e-05,6.231003058492009899e-07,4.921563102289219088e-02,2.224886234187707992e-02,6.742369767475800302e+01};
    vector<float> cluster1_1_7_meanScaleOUTPUT = {-3.263490668058456070e-05,1.639876304801670499e-06,8.598983298538621055e-04,-3.882533402922757736e-03,1.244163778705636926e-04,2.171054279749478418e-04,-2.030819269311064990e-05,-8.728482672233820675e-07,-4.785067536534446699e-03,7.518299582463467204e-03,2.468147181628392417e+01};
    vector<float> cluster1_1_7_stdScaleOUTPUT = {2.037631561494908532e-05,4.406086187081183047e-06,2.960746903969698569e-04,1.260531550415957018e-03,1.800468958329832375e-04,2.756368899589393354e-04,6.624186892817077972e-06,5.677449207026913137e-07,1.649692349372661355e-03,2.592001296146933826e-03,9.258278483882079968e+00};
    
    vector<float> cluster1_1_8_meanScaleINPUT = {4.543371950331322873e-05,3.922250043728732450e-05,1.016218276386484341e-02,4.447206328129663655e-01,9.956519703301294419e-03,2.201229557339860407e-02,4.329582480001193122e-05,6.254428698286669954e-07,3.489668728881857585e-02,4.191572235388932310e-01,2.791053280102680219e+03};
    vector<float> cluster1_1_8_stdScaleINPUT = {3.836527340886301497e-06,4.322742159139506609e-06,6.165140211571631251e-04,8.984579086849041329e-03,3.689144227708090551e-04,2.534077135825430795e-04,2.416846006982462620e-06,5.018490936146850097e-08,3.255331782791965559e-03,4.866517833950373927e-03,2.219919367726868131e+01};
    vector<float> cluster1_1_8_meanScaleOUTPUT = {-7.724310190436393023e-08,-8.501067548206077538e-08,2.937960420273405685e-07,-3.684194973434431867e-05,1.750707718942154183e-06,5.119336159035219879e-07,3.871179183332338056e-08,4.029582412990271190e-10,-5.877744761506772231e-05,9.235018804847451926e-05,3.671204704196763258e-01};
    vector<float> cluster1_1_8_stdScaleOUTPUT = {9.830907254611058966e-08,9.433695549347680439e-08,1.043009434102870595e-05,4.492267918726756520e-05,3.789141788899936754e-06,1.467001050536280585e-06,3.674807158514631334e-08,9.169788032076828570e-10,6.452476710290218961e-05,1.013821246164441976e-04,9.325428666772359598e-01};
    
    vector<float> cluster1_1_9_meanScaleINPUT = {1.639834013207547097e-04,2.908302471698113166e-04,2.463329481132075366e-02,3.967561150943396120e-01,9.378801886792452816e-03,2.494670443396226553e-02,9.854251849056603956e-05,1.091839177358490384e-06,1.752306207547169870e-01,2.992227877358490384e-01,2.085172745283018685e+03};
    vector<float> cluster1_1_9_stdScaleINPUT = {3.047253004032620739e-05,5.769287444219657238e-05,2.702861456267221466e-03,3.763838118037499125e-02,1.548386469256018494e-03,1.971026047641263185e-03,2.425172430612783687e-05,3.300058419231687976e-07,3.556123985729756076e-02,3.321276113738656083e-02,1.143187664982868768e+02};
    vector<float> cluster1_1_9_meanScaleOUTPUT = {-4.068724716981132644e-06,5.903087735849056029e-06,1.024711037735849149e-03,-5.007430188679245185e-03,4.168404056603773871e-04,-2.341647169811320473e-04,-1.060331613207547175e-05,-1.904786858490565785e-07,-6.668111320754717061e-03,1.047697075471698200e-02,2.710680188679245362e+01};
    vector<float> cluster1_1_9_stdScaleOUTPUT = {9.971680497775177920e-06,6.430962199555655855e-06,3.217712842073272073e-04,1.197160940235060230e-03,1.396660474378469863e-04,1.932503703050349620e-04,4.583277401686024152e-06,1.491626033869989637e-07,1.580801136414921411e-03,2.483742794254800105e-03,1.066722707414242777e+01};
    
    vector<float> cluster1_1_10_meanScaleINPUT = {8.531469619496286159e-05,9.315185786374343758e-05,1.602743389200942184e-02,3.989474796158725134e-01,1.227586649755390419e-02,2.293520089690161134e-02,3.551589403877514239e-05,4.644773784200036216e-07,6.725623302228664335e-02,4.187879026091682610e-01,2.733168778764268609e+03};
    vector<float> cluster1_1_10_stdScaleINPUT = {1.333635668408391122e-05,1.900098104099990598e-05,1.683534322520146859e-03,2.465674236626950316e-02,8.214282821738609066e-04,8.452748006296854043e-04,3.843626558071368371e-06,7.576451369693793882e-08,1.029896001125226238e-02,1.573926284132758091e-02,8.838388874374723514e+01};
    vector<float> cluster1_1_10_meanScaleOUTPUT = {-8.628545298061242651e-07,-9.199458235187534345e-07,1.542993295886936389e-05,-4.157197861931509952e-04,3.053994383040405715e-05,-1.876245696684329658e-07,-1.902643957238629937e-07,-4.059964667512230762e-09,-6.488297336473999562e-04,1.019443558615691766e-03,2.288545026272875926e+00};
    vector<float> cluster1_1_10_stdScaleOUTPUT = {5.720061528618425399e-07,5.404391101783195349e-07,1.342274339109848888e-04,3.545872299858310642e-04,3.641397801364892677e-05,1.785579902309204257e-05,7.533027251131771417e-07,1.079904516129754011e-08,3.897519532482520647e-04,6.123759123677949929e-04,3.984622073291463451e+00};
    
    vector<float> cluster1_1_11_meanScaleINPUT = {2.584189951772779243e-05,2.091548968166222227e-05,7.153789531071292652e-03,5.115990695005718791e-01,7.337698526877621530e-03,2.018229140487990542e-02,3.259432275066717518e-05,4.432888127906976059e-07,1.966557200724361812e-02,3.829622330156309817e-01,2.642034035646206576e+03};
    vector<float> cluster1_1_11_stdScaleINPUT = {4.050506426123788601e-06,4.803876908551229091e-06,9.926931134543084522e-04,1.046473576130967260e-02,5.088021408510092804e-04,3.024546589611503637e-04,3.006247889863944471e-06,5.653545008086304671e-08,3.656648565659080530e-03,6.822676909472464093e-03,3.601146280681638956e+01};
    vector<float> cluster1_1_11_meanScaleOUTPUT = {-8.711375524208919597e-08,-1.013281738467403881e-07,-7.326471978650401727e-06,-3.708137628669448416e-05,-1.451949294700722731e-06,2.450522302706820925e-06,1.035211399161265884e-08,-1.162994281357225875e-10,-7.584069386199008677e-05,1.191624285169652744e-04,7.060112466641251805e-01};
    vector<float> cluster1_1_11_stdScaleOUTPUT = {8.345263268868659777e-08,8.542735845059388311e-08,1.189917849071861009e-05,4.155960438725145453e-05,3.219666835311765654e-06,2.276081166466187642e-06,9.262591762364644534e-08,1.986446240765898628e-09,6.648922219190699697e-05,1.044688801074994286e-04,1.442851536933652756e+00};
    
    vector<float> cluster1_1_12_meanScaleINPUT = {6.973665851141982942e-05,6.305511554807514843e-05,1.280090272255786539e-02,3.884192136818675478e-01,1.211390291444172825e-02,2.359905157509238280e-02,4.890661100536177993e-05,7.416361985394898306e-07,5.373659274569358296e-02,4.429649556583808989e-01,2.880985019791449758e+03};
    vector<float> cluster1_1_12_stdScaleINPUT = {4.275416029187097071e-06,4.857035045960750727e-06,4.943150205078945900e-04,7.307288685871142324e-03,2.855446113143462463e-04,2.167663228975303465e-04,1.774333627467160278e-06,4.025252485331992059e-08,3.445948264282953487e-03,3.393034062121452147e-03,1.486463646094053814e+01};
    vector<float> cluster1_1_12_meanScaleOUTPUT = {-8.728985208495523599e-08,-8.173718380280918641e-08,4.641506123836364383e-06,-4.024529336301133124e-05,3.286722733303364003e-06,-2.416727886755561247e-07,4.129823576495870623e-08,4.815184701922125960e-10,-5.440717535991931012e-05,8.548443547768124233e-05,2.164345785682172396e-01};
    vector<float> cluster1_1_12_stdScaleOUTPUT = {1.342014726132555232e-07,1.134537857465670102e-07,1.306238226543449234e-05,5.597928265177320323e-05,5.510257290955273878e-06,1.496783019790377593e-06,5.025667482210810937e-08,7.418267678580917965e-10,7.369912414256334912e-05,1.157989726624204194e-04,6.431702445080151875e-01};
    
    vector<float> cluster1_1_13_meanScaleINPUT = {6.198950952581664536e-05,8.892704238145415145e-05,1.630576326659641598e-02,5.045677884088514142e-01,8.657990084299261105e-03,1.961682233930453143e-02,3.946947076923077222e-05,4.381515344573234596e-07,5.846830177028451009e-02,3.400146596417281120e-01,2.319246280295047200e+03};
    vector<float> cluster1_1_13_stdScaleINPUT = {1.214915600567216474e-05,2.127703577602005512e-05,2.119416171020355698e-03,3.148290343048071316e-02,1.192067191751275228e-03,8.688108300119511216e-04,9.264062404806133483e-06,9.698118819700536509e-08,1.172383125035658842e-02,2.392614173234527616e-02,1.153063163978118268e+02};
    vector<float> cluster1_1_13_meanScaleOUTPUT = {-1.155600990516332851e-06,-6.816003793466806993e-07,8.791981032665962365e-05,-8.859671232876707454e-04,4.620032244467860822e-05,-7.349125395152787355e-06,-2.498717934668071343e-06,-3.505553508956796414e-08,-1.336492876712328708e-03,2.099896311907270378e-03,7.931555321390938218e+00};
    vector<float> cluster1_1_13_stdScaleOUTPUT = {1.297820763210994768e-06,9.001791319682136916e-07,2.309441354305034715e-04,5.549147285182624194e-04,3.908265308202283776e-05,2.807190360759184708e-05,2.468487103854813868e-06,4.529187586371820198e-08,5.875174114764909750e-04,9.231134814749552111e-04,5.464125475514455488e+00};
    
    vector<float> cluster1_1_14_meanScaleINPUT = {2.720513228772774330e-05,3.263402307493983988e-05,9.307764485218288780e-03,5.817450409075283213e-01,5.881673146270196065e-03,1.751500209694053026e-02,2.865249072705396916e-05,3.383221272774148454e-07,2.727985462358198734e-02,3.148610021485046540e-01,2.258835868855276658e+03};
    vector<float> cluster1_1_14_stdScaleINPUT = {6.405912612757392673e-06,1.021813652751069278e-05,1.682964220386830648e-03,2.550949191955531256e-02,8.807964174953618374e-04,7.535227250988257765e-04,7.987392657769641142e-06,8.058610625412831225e-08,7.560981728721083948e-03,2.028830692539463146e-02,1.059583472808238014e+02};
    vector<float> cluster1_1_14_meanScaleOUTPUT = {-3.522678669645927610e-07,-2.691458061189411915e-07,5.368614644207567025e-07,-2.755960811275347255e-04,2.194565142660706554e-06,4.662435544860777547e-06,-9.686770453764182557e-07,-1.278257339291852899e-08,-4.722580268133379309e-04,7.420047267102096878e-04,3.383594018563079064e+00};
    vector<float> cluster1_1_14_stdScaleOUTPUT = {5.229459348454221836e-07,2.046499471121002735e-07,6.713018312530494823e-05,1.870766281428349698e-04,1.579120676880528236e-05,1.126760656018423516e-05,1.002019270308551571e-06,2.049795768875851363e-08,2.326905219340977987e-04,3.655978063302229718e-04,3.188565719740049875e+00};
    
    
        // parentCluster1 - childCluster2
    vector<float> cluster1_2_0_meanScaleINPUT = {1.318637043951324242e-03,4.313407508661417245e-04,3.155053325955619378e-03,9.806591662133141638e-03,7.869100796277738591e-03,4.289775388403722911e-02,4.271563474588404312e-06,1.937699454717251219e-07,4.441427495204008924e-01,3.616074456120257352e-01,2.847159614030064859e+03};
    vector<float> cluster1_2_0_stdScaleINPUT = {1.624262032826934328e-04,5.742097181021470046e-05,9.595061711729369882e-04,3.632214237190446900e-03,1.334957083421664222e-03,8.798052899142386630e-04,1.398505866229299369e-06,4.644782859122577929e-08,2.145621769873977402e-02,1.854760296681567250e-02,7.582797660043154053e+01};
    vector<float> cluster1_2_0_meanScaleOUTPUT = {-2.656611309949891917e-06,-4.602277165354329904e-07,-1.366698356478167235e-05,-8.681322090193271577e-05,-6.828037222619866569e-07,2.822510236220469575e-05,-2.661113672154616709e-08,-4.372049420186113275e-10,-1.323188546886183573e-04,2.079053972798853764e-04,1.305451968503937188e+00};
    vector<float> cluster1_2_0_stdScaleOUTPUT = {4.071575954819398419e-06,1.913016452936198101e-06,9.675004670906544541e-06,8.584767481712574219e-05,1.919370119826228633e-05,1.903270238658361828e-05,3.196422634262888379e-08,8.598054982437726861e-10,1.018989280189010432e-04,1.601104262311043224e-04,2.985662363802684016e+00};
    
    vector<float> cluster1_2_1_meanScaleINPUT = {7.448294428188034560e-04,4.093666671457017302e-04,8.870891882434421213e-03,4.269653846593369356e-02,1.396094437018439993e-02,3.974427870660549728e-02,1.590297421521946305e-05,4.872219157475543833e-07,3.432716443771102188e-01,4.314268471128041571e-01,3.031843357631374147e+03};
    vector<float> cluster1_2_1_stdScaleINPUT = {5.772587501965381455e-05,5.260462650615651018e-05,1.111631423574346682e-03,5.945486799927656059e-03,5.799209792410652334e-04,8.251586727069584867e-04,2.005404586669089758e-06,7.064966547361142133e-08,1.359324440650647864e-02,1.160555479762360315e-02,6.291881981544860025e+01};
    vector<float> cluster1_2_1_meanScaleOUTPUT = {-2.618922846506796014e-06,-4.405533027443510851e-07,4.772753700978269307e-06,-1.646186581248376961e-04,2.429693186737078689e-05,1.448192018007097557e-05,-2.814979482295903785e-08,5.545151069171496814e-11,-2.117847632239632676e-04,3.327668080685656387e-04,7.019729893515711527e-01};
    vector<float> cluster1_2_1_stdScaleOUTPUT = {4.483645917540893385e-06,1.208782154064891227e-06,3.880533432064038412e-05,2.315372119492976877e-04,4.479719477399834678e-05,2.276890877958977506e-05,8.154297884400926854e-08,2.004096672999756833e-09,2.605968583724100804e-04,4.094705450344619476e-04,2.042550718443561397e+00};
    
    vector<float> cluster1_2_2_meanScaleINPUT = {2.059353541947773428e-03,4.847778647908563675e-04,1.348399684855940963e-03,2.860422306929121493e-03,4.153917265656004165e-03,4.088461495753630687e-02,1.474547587784744858e-06,9.483214279307882524e-08,5.225804227716486228e-01,2.910070528216525121e-01,2.552710207556155183e+03};
    vector<float> cluster1_2_2_stdScaleINPUT = {2.570177954217811849e-04,1.067633239425064669e-04,7.256741310316500940e-04,1.779311014375434003e-03,1.238111274610868406e-03,1.330580928603964600e-03,7.850827121034892982e-07,3.040353984776758366e-08,2.077663032194329920e-02,1.906449133185744022e-02,8.372238835225762443e+01};
    vector<float> cluster1_2_2_meanScaleOUTPUT = {-6.330172632748630386e-06,4.552520041273115075e-07,-1.820605214699579555e-05,-8.588957345821096134e-05,-1.082374474164616142e-05,5.824555520279391135e-05,-2.239961270735772790e-08,-4.528193269307087595e-10,-1.094991666005238663e-04,1.720660766727518222e-04,2.182920469878562031e+00};
    vector<float> cluster1_2_2_stdScaleOUTPUT = {1.046634027377518501e-05,5.046974057797553876e-06,1.262667980418251248e-05,1.091886411959766567e-04,1.196361128064772477e-05,4.888267782813712873e-05,1.703486468946054264e-08,4.385779303789336938e-10,1.270260401237997632e-04,1.995903526551805348e-04,4.391031991305847093e+00};
    
    vector<float> cluster1_2_3_meanScaleINPUT = {2.675780415717540252e-03,6.404572893376554894e-04,1.099401467583669117e-03,1.982769439197476675e-03,2.927777465393376077e-03,3.637653648589451311e-02,1.260317473103206720e-06,9.973960491501665657e-08,5.691312154371823695e-01,2.473149443665673686e-01,2.306784059926405916e+03};
    vector<float> cluster1_2_3_stdScaleINPUT = {3.253151555153817255e-04,1.492949133731494228e-04,7.466581982140558247e-04,1.535222248152285111e-03,1.120221221886335715e-03,1.679297417392991215e-03,8.222805844135546542e-07,3.642507538971042025e-08,2.016373288385779616e-02,1.811932578241124900e-02,7.984177338609623575e+01};
    vector<float> cluster1_2_3_meanScaleOUTPUT = {-2.065301647100052136e-05,5.943454573330996969e-06,-4.485451235325039646e-05,-1.519136937532854443e-04,-3.431233397581917425e-05,1.496439591729455273e-04,-3.920091444717014709e-08,2.341034781846854450e-10,-1.683473366041699990e-04,2.645294375328544035e-04,3.771452164009111208e+00};
    vector<float> cluster1_2_3_stdScaleOUTPUT = {2.059427934356157061e-05,1.083129752097214338e-05,3.306185863892308578e-05,1.449703869314499774e-04,2.838946586897096583e-05,1.014293946714871361e-04,2.643024803058430376e-08,1.448713620702275772e-09,1.816661443543027407e-04,2.854297847937336554e-04,6.275008512154671259e+00};
    
    vector<float> cluster1_2_4_meanScaleINPUT = {9.512677657529962751e-04,4.356362078165711225e-04,6.216047099114122010e-03,2.478746630119854633e-02,1.155035489379885490e-02,4.139811830745179777e-02,9.776576379364252642e-06,3.456956467743616632e-07,3.869576308494007133e-01,4.042663821573735938e-01,2.967497313809275511e+03};
    vector<float> cluster1_2_4_stdScaleINPUT = {8.350619679778239872e-05,5.966350678224450707e-05,1.164910279758922963e-03,5.333656054742700811e-03,8.833379349774246820e-04,9.934293966730948621e-04,1.744216763087451170e-06,5.703861534434812077e-08,1.576130620754943867e-02,1.338545931273688039e-02,6.826936482488417823e+01};
    vector<float> cluster1_2_4_meanScaleOUTPUT = {-3.365933423658154812e-06,-3.944979051589370664e-07,-3.837620635747786841e-06,-1.575407816571130722e-04,1.855046941115164239e-05,2.379480771235018590e-05,-4.255496717040125656e-08,-5.139395726941114694e-10,-2.119367795726942113e-04,3.330001875977072964e-04,9.411522668056279128e-01};
    vector<float> cluster1_2_4_stdScaleOUTPUT = {5.096236650778390433e-06,1.373846539945893156e-06,2.773205995956198869e-05,1.891823608597337019e-04,3.749594660941484920e-05,2.621326264788948195e-05,7.633689362306568297e-08,2.046751295994829307e-09,2.082905579335808189e-04,3.272821788868942585e-04,2.509131412684825424e+00};
    
    vector<float> cluster1_2_5_meanScaleINPUT = {8.332919677113010673e-04,9.692329415954415838e-04,2.068275698005698007e-02,8.205008770180437228e-02,1.407225849715099640e-02,3.219376723646723282e-02,2.587298378442545017e-05,4.689485607787274606e-07,3.616721576448242992e-01,3.738825166191833138e-01,2.500237642450142175e+03};
    vector<float> cluster1_2_5_stdScaleINPUT = {2.061473099357884360e-04,2.928771556123742586e-04,4.461559801753868515e-03,2.923230005623967537e-02,2.055156573770882192e-03,1.790092326500950480e-03,1.171498152077984751e-05,1.723511901516377774e-07,4.960559313751354560e-02,3.255708299786654047e-02,1.992866733776212413e+02};
    vector<float> cluster1_2_5_meanScaleOUTPUT = {-7.446864197530864610e-06,-1.699949002849002918e-05,-1.221405982905982631e-04,-1.571645370370370210e-03,2.266706885090218190e-04,9.881671415004756708e-05,-1.291540432098765486e-06,-2.016388152896486210e-08,-2.437748812915479287e-03,3.830367996201329648e-03,1.687890788224121863e+01};
    vector<float> cluster1_2_5_stdScaleOUTPUT = {1.213278439054706939e-05,1.545693037321256561e-05,2.805336075267431790e-04,1.463742018021899158e-03,1.710343331741094792e-04,2.715169755314366848e-04,1.896856307581239730e-06,3.316783640394517216e-08,2.295355281547712019e-03,3.606537024688329009e-03,1.110940505252841781e+01};
    
    vector<float> cluster1_2_6_meanScaleINPUT = {6.048114243100765697e-04,3.765387121622399791e-04,1.117103365529757350e-02,6.305098503341591276e-02,1.559179735409344653e-02,3.810664688886328255e-02,2.197285653626778780e-05,6.035125759059744819e-07,3.065240326669355642e-01,4.500203089099498732e-01,3.066855363254018812e+03};
    vector<float> cluster1_2_6_stdScaleINPUT = {3.761591225746724456e-05,3.478862663508096900e-05,1.200780011056801124e-03,8.086613919464630609e-03,4.309103927043830698e-04,7.887303065259596360e-04,1.953540551225998815e-06,6.781232466331511020e-08,1.075510018165915481e-02,8.124726148619341309e-03,4.756417439775609068e+01};
    vector<float> cluster1_2_6_meanScaleOUTPUT = {-1.877897102033761380e-06,-3.970116955695109538e-07,1.142256438324595358e-05,-1.597902848994642224e-04,2.550412369649134167e-05,6.822251829233182616e-06,6.684234026617379661e-10,7.823508814887363849e-10,-1.994569193985136566e-04,3.133895690499508414e-04,3.680731117128537289e-01};
    vector<float> cluster1_2_6_stdScaleOUTPUT = {3.365815722307945702e-06,9.916746977456176697e-07,4.669138309876331495e-05,2.493881562433652153e-04,4.769087096176103139e-05,1.445177045604582431e-05,5.936164520968181009e-08,1.523406154063190194e-09,2.845984029089472555e-04,4.471732477438799722e-04,1.729505591895043048e+00};
    
    vector<float> cluster1_2_7_meanScaleINPUT = {1.455940182207931437e-03,1.315672785637727769e-03,1.405068442658092241e-02,7.878745058949625235e-02,5.711561028938906374e-03,3.419261875669881573e-02,7.542282529474813365e-05,2.139845948553054975e-06,5.420467427652733150e-01,1.960326795284030033e-01,1.788939228295819930e+03};
    vector<float> cluster1_2_7_stdScaleINPUT = {7.283463174267566960e-04,1.855287627020992208e-04,6.774354877392699953e-03,3.495250280504946100e-02,2.407801799365217460e-03,2.443250110326325442e-03,2.497382563797276758e-05,8.123731241526498072e-07,7.839698308016081196e-02,5.175358449269611139e-02,1.472414165182854617e+02};
    vector<float> cluster1_2_7_meanScaleOUTPUT = {-1.618958703108252866e-04,1.005288413719185309e-04,1.243851875669882119e-03,-8.618226152197212830e-03,5.728210182207931975e-04,2.490827438370845628e-04,-1.346322561629153336e-05,-4.074855798499464311e-07,-1.160203751339764291e-02,1.822984351554126151e-02,4.525070739549838805e+01};
    vector<float> cluster1_2_7_stdScaleOUTPUT = {1.923457114829867185e-04,3.956699600514135262e-05,6.975831014298206978e-04,2.029167086446552297e-03,2.335158229398425487e-04,1.470097972642067869e-03,4.638719249419893711e-06,2.402731303675305525e-07,2.511712513179145592e-03,3.946409835626849515e-03,1.198477371501555133e+01};
    
    vector<float> cluster1_2_8_meanScaleINPUT = {2.337397564125887235e-03,1.474715382390394446e-03,5.293696120611241993e-03,1.037951318755685019e-02,4.613959565035474081e-03,3.052258686556303183e-02,8.328988726396215943e-06,4.406154256867382204e-07,5.669711449881754683e-01,2.418222335819537883e-01,2.046721968346370886e+03};
    vector<float> cluster1_2_8_stdScaleINPUT = {6.226591026353705963e-04,2.533839282329192221e-04,3.777898995901435124e-03,9.163944987230806041e-03,2.350102121308172889e-03,2.165704649103344925e-03,7.477261982309304157e-06,2.770218516885359497e-07,5.178257257783264178e-02,4.558434399363263390e-02,1.886357251643433983e+02};
    vector<float> cluster1_2_8_meanScaleOUTPUT = {-1.382738220847734944e-05,3.199510642168466794e-07,-1.562683880298344622e-04,-8.998753487356739777e-04,2.274880589412406427e-05,1.090016372566855263e-04,-8.774789585228307411e-07,-2.609469801710023805e-08,-1.642934327815171467e-03,2.581782062943423824e-03,1.305296525377478467e+01};
    vector<float> cluster1_2_8_stdScaleOUTPUT = {5.345922996526574037e-05,3.491178413387889323e-05,1.064167289908915292e-04,1.074369954360637975e-03,9.608676673118505401e-05,3.682417201583913086e-04,1.432209463060893565e-06,4.153053083800084851e-08,2.000639306012438282e-03,3.143546226898224268e-03,9.226836930937469816e+00};
    
    vector<float> cluster1_2_9_meanScaleINPUT = {1.439963978354978245e-03,6.986654237208574526e-04,5.662850828248057466e-03,1.629966497053148000e-02,8.951150444374902926e-03,3.905824294580920869e-02,6.018070614405674942e-06,2.103664197569498853e-07,4.614162715798257874e-01,3.379727585667344769e-01,2.642727853231106110e+03};
    vector<float> cluster1_2_9_stdScaleINPUT = {2.331097892865916042e-04,1.098737246689164370e-04,2.080729021643180215e-03,7.577232210858406841e-03,1.728978801873423503e-03,1.341982068590883218e-03,2.107300135575426635e-06,3.762248352470532851e-08,2.944056917811130672e-02,2.276759307250557363e-02,9.852470556551777747e+01};
    vector<float> cluster1_2_9_meanScaleOUTPUT = {-1.984934684191310642e-05,2.130348615240180871e-06,-1.197660460021905838e-05,-4.905383664528242468e-04,5.176699055964115333e-05,1.309759557711365229e-04,-9.022185677776037524e-08,-1.770079017368174055e-09,-5.898498409221294937e-04,9.268622542116515973e-04,4.565398737808376239e+00};
    vector<float> cluster1_2_9_stdScaleOUTPUT = {1.316356410185465006e-05,7.692407199004773662e-06,5.472211577214327135e-05,2.542585597189668035e-04,5.323906141630394391e-05,4.857978261116969375e-05,6.026291052264777632e-08,1.786620763168325760e-09,2.529525900529173065e-04,3.974796033918891951e-04,4.406371583789909785e+00};



    // Declare Max,Min of OUTPUT (MaxMinVar - deltaY deltaT) standardized to drive the prediction
    // Child of parentCluster0
    vector<float> cluster0_0_maxOUTPUT = {0.000000000000000000e+00,2.140399999999998176e-07,1.780100000000001473e-05,3.700000000006475886e-05,6.709999999999995048e-06,1.285999999999995480e-04,7.278600000000000412e-05,1.425199999999997806e-06,0.000000000000000000e+00,4.609999999999891962e-04,4.492499999999995453e+01};
    vector<float> cluster0_0_minOUTPUT = {-1.351200000000000209e-05,-1.166390000000000110e-06,-1.531200000000000790e-04,-2.459999999999684661e-04,-5.908499999999995353e-05,0.000000000000000000e+00,-8.712999999999982478e-06,-5.694599999999997960e-06,-2.940000000000164704e-04,0.000000000000000000e+00,-2.704899999999975080e+01};
    
    vector<float> cluster0_1_maxOUTPUT = {1.469000000000002368e-07,2.407199999999999585e-06,1.989499999999998214e-04,1.000000000028755665e-06,9.263000000000001267e-05,4.924000000000004762e-04,6.800000000001357910e-09,1.290000000000139268e-10,-6.800000000000382128e-06,2.186999999999994504e-03,6.016000000000008185e+01};
    vector<float> cluster0_1_minOUTPUT = {-6.221100000000000458e-05,-2.367800000000001284e-06,-2.061200000000006083e-04,-1.485999999999987331e-03,-1.235999999999999686e-04,-3.020000000000105933e-05,-1.616100000000005076e-05,-6.095389999999999420e-06,-1.391999999999976589e-03,1.099999999998324540e-05,-4.212999999999988177e+01};
    
    vector<float> cluster0_2_maxOUTPUT = {0.000000000000000000e+00,2.031900000000000654e-05,9.834799999999994675e-05,1.046309999999999987e-26,5.695499999999997223e-05,7.948900000000003532e-04,3.951899999999998535e-05,1.258799999999998858e-06,0.000000000000000000e+00,1.673199999999999688e-03,2.530999999999994543e+01};
    vector<float> cluster0_2_minOUTPUT = {-1.102100000000003424e-04,-9.509999999999846267e-07,-1.700000000000000664e-05,-1.458999999999988084e-03,-9.406000000000011249e-06,8.478170000000000856e-18,-5.552000000000003764e-06,-2.071400000000001886e-06,-1.065000000000093650e-03,0.000000000000000000e+00,-2.347660000000000764e+02};
    
    vector<float> cluster0_3_maxOUTPUT = {1.440000000000035002e-05,1.185980000000000324e-04,1.474089999999999949e-03,-2.868000000000054533e-08,7.023400000000000823e-04,3.841399999999998288e-03,-3.091999999999931006e-11,6.357000000000035020e-10,5.999999999994898303e-05,1.061339999999999506e-02,9.936000000000012733e+01};
    vector<float> cluster0_3_minOUTPUT = {-5.847299999999998853e-04,-1.027100000000006480e-05,-6.208799999999996527e-05,-9.338999999999986201e-03,-1.138119999999999735e-04,-4.530000000000158900e-05,-2.791699999999997005e-05,-6.038310000000000129e-06,-6.754999999999955484e-03,-9.399999999998298605e-05,-5.210999999999967258e+01};
    
    vector<float> cluster0_4_maxOUTPUT = {0.000000000000000000e+00,5.410000000000071869e-07,9.411999999999970195e-07,1.000000000139777967e-06,1.782000000000011060e-07,2.835999999999997377e-04,3.307440000000001117e-04,1.798499999999999806e-06,0.000000000000000000e+00,7.385999999999851018e-04,9.111499999999978172e+01};
    vector<float> cluster0_4_minOUTPUT = {-3.654999999999977711e-05,-4.441700000000001875e-06,-6.355200000000003121e-05,-6.459999999999799236e-04,-5.988000000000000267e-05,0.000000000000000000e+00,-9.900000000000023798e-07,7.500000000006531365e-18,-4.699999999999704414e-04,0.000000000000000000e+00,-8.013599999999996726e+01};
    
    vector<float> cluster0_5_maxOUTPUT = {2.250000000000020809e-08,4.129999999999907942e-08,5.945999999999989488e-05,0.000000000000000000e+00,1.888000000000019871e-05,1.245000000000030804e-04,1.720000000000044518e-08,3.320000000000058846e-10,-6.210000000000416576e-06,8.920000000000039009e-04,2.094000000000005457e+01};
    vector<float> cluster0_5_minOUTPUT = {-9.302600000000001363e-06,-5.587000000000019522e-07,-5.375999999999991896e-05,-4.020000000001244800e-04,-7.233999999999973091e-05,-1.030000000000301508e-05,-8.775399999999997330e-06,-9.652899999999998246e-07,-5.673000000000136267e-04,8.999999999981245224e-06,-2.135000000000036380e+01};
    
    vector<float> cluster0_6_maxOUTPUT = {0.000000000000000000e+00,2.624600000000000587e-05,2.445999999999999824e-04,4.000000000004000356e-06,1.610460000000000841e-04,1.624800000000000896e-03,1.787699999999999706e-04,7.380400000000001369e-06,0.000000000000000000e+00,3.838099999999997070e-03,8.295500000000004093e+01};
    vector<float> cluster0_6_minOUTPUT = {-2.097400000000003602e-04,-5.094299999999999659e-06,-1.583799999999998490e-04,-3.064999999999984404e-03,-4.853699999999997253e-05,0.000000000000000000e+00,-2.736200000000006769e-05,-3.016379999999999062e-05,-2.442999999999972971e-03,0.000000000000000000e+00,-6.879999999999995453e+01};
    
    vector<float> cluster0_7_maxOUTPUT = {0.000000000000000000e+00,1.282710000000000057e-04,1.550580000000000187e-03,7.600000000007600676e-05,7.272400000000000912e-04,4.168699999999997408e-03,2.209800000000000154e-04,9.079900000000000937e-06,0.000000000000000000e+00,1.079739999999999867e-02,1.231700000000000728e+02};
    vector<float> cluster0_7_minOUTPUT = {-6.006599999999998225e-04,-1.189930000000000311e-05,-5.458100000000003053e-04,-9.371999999999991449e-03,-1.456539999999999441e-04,9.999999999940611950e-09,-6.348600000000002202e-05,-3.343870000000000224e-05,-6.873000000000017984e-03,9.999999999940611950e-08,-4.530999999999994543e+01};
    
    vector<float> cluster0_8_maxOUTPUT = {8.110000000000408549e-06,9.141699999999999566e-05,7.227800000000001238e-04,-4.069999999999988137e-08,3.865100000000000653e-04,2.835399999999994869e-03,-3.974999999999999198e-11,-7.404999999999934621e-12,2.200000000007751311e-05,6.665800000000013381e-03,5.661000000000012733e+01};
    vector<float> cluster0_8_minOUTPUT = {-4.304899999999995189e-04,-7.005999999999993570e-06,-5.838000000000002042e-05,-5.996000000000001329e-03,-2.916599999999995758e-05,-2.279999999999990368e-05,-2.152099999999998589e-05,-3.606300000000001369e-06,-4.244000000000025530e-03,-3.500000000003500311e-05,-3.798000000000001819e+01};
    
    vector<float> cluster0_9_maxOUTPUT = {0.000000000000000000e+00,7.420200000000000547e-06,6.549399999999992554e-05,2.999999999975244691e-06,4.248399999999996797e-05,6.739599999999994900e-04,9.196899999999995920e-05,6.423999999999991349e-06,0.000000000000000000e+00,1.558700000000010077e-03,4.150400000000001910e+01};
    vector<float> cluster0_9_minOUTPUT = {-8.417999999999967176e-05,-2.384199999999999975e-06,-7.703400000000002173e-05,-1.243999999999967354e-03,-3.012799999999997988e-05,1.999999999988122390e-08,-1.022200000000016065e-05,-1.666199999999999734e-05,-9.919999999999928875e-04,1.999999999849344512e-07,-4.075000000000000000e+01};
    
    vector<float> cluster0_10_maxOUTPUT = {1.326949999999999601e-75,1.513999999999959823e-12,5.105729999999999717e-17,4.000000000004000356e-06,1.445400000000000028e-19,1.550000000000118991e-06,8.740899999999996220e-06,2.394999999999966058e-07,2.638229999999999903e-80,1.170000000000163964e-05,3.364240000000002055e+02};
    vector<float> cluster0_10_minOUTPUT = {-1.099999999999972528e-07,-1.111107999999999840e-07,-4.453500000000014196e-06,-9.000000000036756376e-06,-3.786519999999999789e-06,0.000000000000000000e+00,-1.612999999999999634e-06,0.000000000000000000e+00,-8.000000000008000711e-06,0.000000000000000000e+00,-1.507399999999995543e+01};
    
    vector<float> cluster0_11_maxOUTPUT = {6.299000000000018126e-05,2.155220000000001093e-04,2.678519999999998472e-03,-7.962000000000009489e-07,9.851599999999996818e-04,5.251300000000003881e-03,-1.023999999999996464e-09,2.486000000000013129e-09,9.000000000003449685e-05,1.773600000000000176e-02,1.276900000000000546e+02};
    vector<float> cluster0_11_minOUTPUT = {-8.426300000000000283e-04,-2.818999999999998590e-05,-2.991199999999999415e-04,-1.386599999999998944e-02,-1.329199999999999132e-04,-3.166000000000002146e-04,-4.204100000000004014e-05,-1.044505999999999991e-05,-1.128699999999993597e-02,-1.410000000000022347e-04,-6.534999999999990905e+01};
    
    vector<float> cluster0_12_maxOUTPUT = {1.134300000000000304e-06,2.364000000000002167e-04,3.028970000000000620e-03,-4.700000000001924860e-05,1.121849999999999757e-03,5.882100000000001216e-03,-1.441999999999977046e-07,-1.563999999999973506e-09,-1.785999999999992455e-04,1.972499999999999254e-02,1.284799999999997908e+02};
    vector<float> cluster0_12_minOUTPUT = {-9.465800000000002511e-04,-9.140999999999972281e-06,-4.189900000000001609e-04,-1.593299999999997496e-02,-1.560599999999999661e-04,-1.617000000000007320e-04,-7.120699999999999773e-05,-2.245669999999999456e-05,-1.255499999999998284e-02,2.800000000000024691e-04,-4.912000000000011823e+01};
    
    vector<float> cluster0_13_maxOUTPUT = {5.270000000000205347e-09,2.009200000000001024e-06,2.236600000000005251e-04,8.999999999925734073e-06,9.511999999999997020e-05,5.218999999999987538e-04,1.421600000000005498e-05,1.983000000000011338e-07,-2.599999999994967448e-06,2.253000000000032754e-03,1.139900000000000091e+02};
    vector<float> cluster0_13_minOUTPUT = {-6.532600000000004506e-05,-2.150799999999999804e-06,-2.416700000000002527e-04,-1.577000000000050584e-03,-1.203000000000000510e-04,-9.100000000001468026e-06,-1.667599999999997383e-05,-5.672499999999998629e-06,-1.432999999999989837e-03,3.999999999976244780e-06,-5.119999999999981810e+01};
    
    // Child of parentCluster1
    // parentCluster1 - chilCluster0 - grandChild //It should be maxVar, minVar
    vector<float> cluster1_0_0_maxOUTPUT = {1.720000000000247806e-07,3.270000000000258377e-07,1.505999999999938215e-04,-4.999999999921733718e-06,7.959999999999911591e-05,1.150000000000456213e-05,4.596999999999982732e-07,7.091000000000179103e-09,-9.999999999732443015e-07,9.490000000000331504e-04,3.400000000000091394e+00};
    vector<float> cluster1_0_0_minOUTPUT = {-2.389999999999981776e-06,-1.550999999999998999e-06,-5.509999999999889986e-05,-5.450000000000176925e-04,-2.200000000004281864e-06,-2.299999999999872269e-05,-1.956999999999886300e-07,-6.265999999999958303e-09,-6.040000000000072004e-04,1.999999999890978299e-06,-1.225000000000000000e+01};
    
    vector<float> cluster1_0_1_maxOUTPUT = {1.800000000000152437e-07,3.299999999999917583e-07,8.719999999999908380e-05,-9.999999999732443015e-07,5.149999999999946287e-05,5.800000000000248553e-06,1.677000000000017995e-07,3.408000000000158631e-09,0.000000000000000000e+00,4.790000000000072520e-04,1.630000000000109139e+00};
    vector<float> cluster1_0_1_minOUTPUT = {-1.603999999999993664e-06,-4.410000000000047563e-07,-2.060000000000256071e-05,-3.029999999999977156e-04,-6.000000000033756109e-07,-1.529999999999934529e-05,-9.300000000000063424e-09,-8.079999999999631920e-10,-3.049999999999720144e-04,0.000000000000000000e+00,-1.083999999999969077e+01};
    
    vector<float> cluster1_0_2_maxOUTPUT = {6.200000000002752788e-08,1.210000000000078201e-07,8.069999999999952212e-05,-9.999999999732443015e-07,4.159999999999927645e-05,6.700000000001842523e-06,2.910000000000011102e-07,4.854000000000368911e-09,-1.999999999641177430e-07,6.030000000000201865e-04,3.320000000000164153e+00};
    vector<float> cluster1_0_2_minOUTPUT = {-1.072999999999980875e-06,-6.040000000000234609e-07,-3.459999999999921472e-05,-3.369999999999761533e-04,-2.000000000003734901e-06,-1.069999999999890483e-05,-5.599999999985174129e-09,-5.659999999998477054e-10,-3.829999999999944560e-04,0.000000000000000000e+00,-9.139999999999874447e+00};
    
    vector<float> cluster1_0_3_maxOUTPUT = {1.220000000000235653e-07,2.879999999999810325e-07,7.370000000000120866e-05,-2.000000000002000178e-06,7.640000000000077285e-05,1.720000000000193596e-05,1.100999999999974720e-07,4.331000000000014099e-09,0.000000000000000000e+00,6.990000000000052812e-04,4.239999999999781721e+00};
    vector<float> cluster1_0_3_minOUTPUT = {-4.387000000000011530e-06,-1.185000000000009830e-06,-3.500000000000030864e-05,-4.018000000000076523e-04,-2.500000000002500222e-06,-1.280000000000031282e-05,-1.419999999999725518e-08,-1.552999999999775538e-09,-4.440000000000000045e-04,0.000000000000000000e+00,-1.470000000000027462e+01};
    
    vector<float> cluster1_0_4_maxOUTPUT = {-7.227899999999999017e-05,9.661199999999990780e-05,3.594499999999997003e-03,-3.340999999999927361e-03,9.619800000000004086e-04,3.338899999999998813e-03,-3.149000000000001191e-05,-1.026269999999999408e-06,-3.781000000000007012e-03,2.260400000000001297e-02,9.873999999999999488e+01};
    vector<float> cluster1_0_4_minOUTPUT = {-5.257410000000000338e-04,-7.344000000000002869e-06,6.395999999999988500e-04,-1.501700000000000257e-02,-2.877999999999995145e-05,6.831000000000025637e-04,-5.594700000000001170e-05,-4.226500000000001801e-06,-1.438599999999995264e-02,5.942000000000002835e-03,1.300000000000000000e+01};
    
    vector<float> cluster1_0_5_maxOUTPUT = {-1.901000000000007930e-06,-5.339999999999999695e-06,7.290000000000074198e-05,-3.559999999999951550e-04,2.827000000000003122e-04,2.204999999999950327e-04,2.295000000000017573e-07,5.413999999999998055e-09,-1.001000000000001888e-03,4.758999999999957708e-03,4.970000000000027995e+01};
    vector<float> cluster1_0_5_minOUTPUT = {-1.215300000000010031e-05,-2.744699999999999996e-05,-5.933999999999974018e-04,-2.020000000000049100e-03,2.749999999999975026e-05,-1.850000000000115441e-05,-1.703300000000001336e-06,-1.577399999999998958e-08,-3.028000000000002911e-03,1.573000000000046583e-03,-2.400000000000090949e+00};
    
    vector<float> cluster1_0_6_maxOUTPUT = {1.490000000000150059e-07,2.550000000000035407e-07,8.580000000000392868e-05,-9.999999999732443015e-07,6.659999999999999254e-05,1.129999999999881269e-05,1.436999999999965818e-07,4.207000000000191130e-09,0.000000000000000000e+00,6.169999999998677627e-04,2.410000000000308784e+00};
    vector<float> cluster1_0_6_minOUTPUT = {-2.714999999999976547e-06,-8.579999999999568874e-07,-2.750000000000321632e-05,-3.709999999999824549e-04,-9.000000000015939694e-07,-1.410000000000300072e-05,-1.300000000001495107e-08,-1.477000000000007204e-09,-3.920000000000034026e-04,0.000000000000000000e+00,-1.103999999999996184e+01};
    
    vector<float> cluster1_0_7_maxOUTPUT = {1.329999999999799225e-07,2.480000000000016913e-07,9.089999999999792690e-05,0.000000000000000000e+00,5.130000000000064386e-05,6.800000000001249489e-06,2.555999999999980271e-07,4.530000000000002348e-09,0.000000000000000000e+00,6.039999999999933226e-04,3.990000000000236913e+00};
    vector<float> cluster1_0_7_minOUTPUT = {-1.561000000000048031e-06,-6.069999999999892756e-07,-2.890000000000183749e-05,-3.550000000000220189e-04,-8.000000000021878499e-07,-1.430000000000181296e-05,-1.340000000000227562e-08,-1.445999999999998522e-09,-3.849999999999965104e-04,0.000000000000000000e+00,-9.010000000000216502e+00};
    
    vector<float> cluster1_0_8_maxOUTPUT = {5.299999999999423434e-08,1.019999999999932636e-07,5.880000000000120563e-05,-9.999999999732443015e-07,2.820000000000426671e-05,5.399999999999156323e-06,2.226000000000137326e-07,4.072000000000170400e-09,-1.999999999779955838e-07,4.409999999999691402e-04,2.309999999999944986e+00};
    vector<float> cluster1_0_8_minOUTPUT = {-7.770000000000097767e-07,-5.179999999999974122e-07,-2.909999999999718706e-05,-2.370000000000427863e-04,-2.100000000003141021e-06,-9.499999999999092504e-06,-5.000000000010963556e-10,-5.689999999999305165e-10,-2.810999999999924670e-04,0.000000000000000000e+00,-8.280000000000200089e+00};
    
    vector<float> cluster1_0_9_maxOUTPUT = {1.760000000000064464e-07,2.889999999999967248e-07,3.242000000000001825e-04,-1.239999999999574776e-04,2.256999999999953217e-04,6.099999999999856215e-05,5.915999999999961654e-07,1.012099999999996205e-08,-4.083000000000003293e-04,3.386999999999972932e-03,7.744999999999980389e+01};
    vector<float> cluster1_0_9_minOUTPUT = {-7.402999999999983162e-06,-5.641999999999984267e-06,-2.768000000000006566e-04,-1.676999999999984059e-03,-6.700000000000109493e-06,-5.929999999999824301e-05,-1.790199999999995371e-06,-2.865400000000004271e-08,-2.156000000000019012e-03,6.419999999999759233e-04,-2.719999999999981455e+01};
    
    vector<float> cluster1_0_10_maxOUTPUT = {-1.929159999999999805e-04,2.250619999999999401e-04,3.207699999999998660e-03,-6.034999999999902422e-03,1.133619999999999246e-03,5.573899999999999688e-03,-3.589899999999998951e-05,-4.053569999999998359e-06,-5.893000000000009342e-03,2.185100000000000930e-02,1.055100000000000051e+02};
    vector<float> cluster1_0_10_minOUTPUT = {-9.112499999999999507e-04,8.726999999999986071e-06,1.139599999999999294e-03,-1.643500000000000169e-02,2.341599999999996961e-04,1.540300000000001607e-03,-6.787300000000001915e-05,-9.886399999999999060e-06,-1.390700000000000443e-02,9.259999999999990461e-03,2.732000000000016371e+01};
    
    vector<float> cluster1_0_11_maxOUTPUT = {2.900000000002293105e-08,5.399999999998288114e-08,1.859999999999708769e-05,0.000000000000000000e+00,9.100000000001468026e-06,6.999999999993122834e-07,4.629999999999987858e-08,7.020000000000018151e-10,0.000000000000000000e+00,1.040000000000484981e-04,6.700000000000727596e-01};
    vector<float> cluster1_0_11_minOUTPUT = {-2.409999999999998949e-07,-1.190000000000034611e-07,-3.100000000002406386e-06,-6.699999999998373923e-05,-3.000000000016878055e-07,-2.999999999999531243e-06,-6.999999999947586343e-10,-4.000000000216293917e-12,-6.599999999999661693e-05,0.000000000000000000e+00,-2.270000000000437002e+00};
    
    vector<float> cluster1_0_12_maxOUTPUT = {3.419999999999368218e-08,6.860000000000132896e-08,6.610000000000122722e-05,-9.999999999732443015e-07,3.189999999999963698e-05,7.800000000002251272e-06,2.582000000000105044e-07,5.081999999999886291e-09,-2.999999999669932830e-07,6.079999999999973230e-04,3.899999999999636202e+00};
    vector<float> cluster1_0_12_minOUTPUT = {-8.771000000000055445e-07,-6.260999999999972750e-07,-4.270000000000315210e-05,-3.160000000000384723e-04,-4.099999999999937028e-06,-9.100000000001468026e-06,-2.930000000000326007e-08,-1.972999999999934354e-09,-3.869999999999985106e-04,0.000000000000000000e+00,-1.529999999999972538e+01};
    
    vector<float> cluster1_0_13_maxOUTPUT = {7.800000000000840115e-08,1.469999999999835154e-07,1.180000000000000493e-04,0.000000000000000000e+00,5.819999999999957152e-05,8.100000000000466243e-06,3.665000000000040296e-07,5.597000000000337911e-09,0.000000000000000000e+00,7.579999999998698890e-04,3.480000000000017746e+00};
    vector<float> cluster1_0_13_minOUTPUT = {-1.612999999999999634e-06,-8.329999999999968315e-07,-4.030000000000005800e-05,-4.440000000000000045e-04,-2.000000000003734901e-06,-1.610000000000152975e-05,-5.000000000146488828e-10,-6.640000000000117691e-10,-4.819999999999962661e-04,0.000000000000000000e+00,-8.590000000000147296e+00};
    
    vector<float> cluster1_0_14_maxOUTPUT = {2.174499999999998916e-05,1.002400000000001380e-04,3.468999999999999861e-03,-5.579000000000000625e-03,9.497499999999999649e-04,1.987899999999986900e-03,-1.614099999999997980e-05,-2.473400000000002018e-07,-6.316000000000016046e-03,2.452899999999999525e-02,9.538999999999987267e+01};
    vector<float> cluster1_0_14_minOUTPUT = {-3.678900000000001115e-04,-4.722999999999988492e-06,1.336999999999998129e-03,-1.469000000000000861e-02,1.447499999999999135e-04,-1.243799999999996514e-03,-3.913799999999998340e-05,-1.992120000000000080e-06,-1.561100000000003978e-02,9.922999999999987386e-03,2.549000000000000909e+01};
    
    vector<float> cluster1_0_15_maxOUTPUT = {1.469999999999835154e-07,2.420000000000156401e-07,1.094000000000025643e-04,-1.000000000001000089e-06,9.329999999999756511e-05,1.580000000001025029e-05,1.511999999999995010e-07,5.359999999999936823e-09,0.000000000000000000e+00,8.600000000000273008e-04,4.700000000000273737e+00};
    vector<float> cluster1_0_15_minOUTPUT = {-4.337999999999998108e-06,-1.134000000000019975e-06,-3.970000000000015183e-05,-5.110000000000113366e-04,-1.299999999999218447e-06,-1.509999999999706191e-05,-1.489999999999879008e-08,-1.040000000000014813e-09,-5.470000000000196927e-04,0.000000000000000000e+00,-1.359999999999990727e+01};
    
    vector<float> cluster1_0_16_maxOUTPUT = {1.110000000000130112e-07,4.369999999999959854e-07,1.016000000000002876e-04,-2.099999999977119745e-06,1.129999999999985047e-04,2.560000000000062565e-05,1.237000000000001878e-07,5.173999999999991439e-09,0.000000000000000000e+00,1.009000000000037645e-03,4.469999999999799911e+00};
    vector<float> cluster1_0_16_minOUTPUT = {-6.694000000000013328e-06,-1.791999999999971789e-06,-4.879999999999989191e-05,-5.835000000000007932e-04,-3.500000000000031288e-06,-1.090000000000812372e-05,-5.980000000000237513e-08,-2.985000000000023090e-09,-6.419999999999759233e-04,0.000000000000000000e+00,-1.694000000000005457e+01};
    
    vector<float> cluster1_0_17_maxOUTPUT = {-1.516410000000000208e-04,1.829319999999999080e-04,3.566499999999999792e-03,-5.163000000000028678e-03,1.074980000000000553e-03,5.121000000000000552e-03,-3.192900000000001228e-05,-1.753059999999999738e-06,-5.174999999999985167e-03,2.414899999999997604e-02,1.016999999999998039e+02};
    vector<float> cluster1_0_17_minOUTPUT = {-7.949300000000001157e-04,1.698999999999998472e-06,1.008700000000002997e-03,-1.632600000000001064e-02,1.555099999999993293e-04,1.238899999999997425e-03,-6.181599999999999226e-05,-5.866109999999998627e-06,-1.536900000000002153e-02,8.131000000000001074e-03,2.499000000000000909e+01};
    
    vector<float> cluster1_0_18_maxOUTPUT = {1.849999999999854968e-07,3.340000000000005291e-07,1.115999999999999073e-04,-9.999999999732443015e-07,7.419999999999649098e-05,9.700000000001372496e-06,2.136000000000143270e-07,4.899000000000234649e-09,0.000000000000000000e+00,7.209999999999717720e-04,2.300000000000181455e+00};
    vector<float> cluster1_0_18_minOUTPUT = {-2.629999999999993031e-06,-7.000000000000171207e-07,-3.199999999999730838e-05,-4.400000000000237055e-04,-6.000000000033756109e-07,-1.539999999999874802e-05,-2.629999999999667863e-08,-2.988000000000000021e-09,-4.590000000000149516e-04,0.000000000000000000e+00,-1.169000000000005457e+01};
    
    vector<float> cluster1_0_19_maxOUTPUT = {4.400000000001517075e-08,8.100000000002853182e-08,2.749999999999975026e-05,0.000000000000000000e+00,1.370000000000190510e-05,8.999999999981245224e-07,6.369999999999059791e-08,1.007000000000056597e-09,0.000000000000000000e+00,1.460000000000905018e-04,5.500000000001818989e-01};
    vector<float> cluster1_0_19_minOUTPUT = {-3.659999999999622756e-07,-1.670000000000273431e-07,-3.700000000002312550e-06,-9.500000000001174172e-05,-4.000000000010939250e-07,-4.300000000002218714e-06,-7.000000000150873217e-10,-5.000000000032138572e-12,-9.300000000000974154e-05,0.000000000000000000e+00,-2.980000000000017746e+00};
    
    vector<float> cluster1_0_20_maxOUTPUT = {1.559999999999896973e-07,2.890000000000238828e-07,8.610000000000214704e-05,0.000000000000000000e+00,4.889999999999755653e-05,5.999999999999062487e-06,2.120999999999974854e-07,3.850999999999999213e-09,0.000000000000000000e+00,5.330000000000056914e-04,2.430000000000291038e+00};
    vector<float> cluster1_0_20_minOUTPUT = {-1.453000000000001377e-06,-4.939999999999989972e-07,-2.330000000000040711e-05,-3.239999999999909619e-04,-6.999999999958428365e-07,-1.430000000000181296e-05,-1.000000000015745238e-09,-7.209999999999969932e-10,-3.390000000000060174e-04,0.000000000000000000e+00,-7.910000000000308340e+00};
    
    vector<float> cluster1_0_21_maxOUTPUT = {1.740000000000291396e-07,8.199999999999008018e-08,3.416000000000009307e-04,-2.239999999999742197e-04,2.685000000000014307e-04,1.168000000000002505e-04,7.558999999999972859e-07,1.143300000000007167e-08,-5.439999999999888284e-04,3.161000000000024901e-03,5.394999999999981810e+01};
    vector<float> cluster1_0_21_minOUTPUT = {-1.470899999999990610e-05,-1.112900000000002338e-05,-3.127000000000025592e-04,-1.585000000000002856e-03,2.800000000000718157e-06,-4.619999999999970674e-05,-4.359000000000004026e-07,-1.286299999999994783e-08,-2.011999999999986022e-03,8.540000000000214087e-04,-2.606999999999970896e+01};
    
    vector<float> cluster1_0_22_maxOUTPUT = {7.999999999998566829e-08,1.550000000000010571e-07,6.820000000000089879e-05,0.000000000000000000e+00,3.579999999999902704e-05,5.099999999997467670e-06,2.463999999999981830e-07,3.858999999999797353e-09,0.000000000000000000e+00,4.989999999998606661e-04,2.180000000000291038e+00};
    vector<float> cluster1_0_22_minOUTPUT = {-9.389999999999855251e-07,-5.080000000000296952e-07,-2.510000000000358827e-05,-2.819999999999489582e-04,-1.399999999998624567e-06,-1.069999999999890483e-05,-4.299999999999941890e-08,-2.997000000000036697e-09,-3.179999999999988392e-04,0.000000000000000000e+00,-1.057999999999992724e+01};
    
    vector<float> cluster1_0_23_maxOUTPUT = {1.739999999999749295e-07,1.740000000000291396e-07,3.143999999999993480e-04,-8.600000000000274092e-05,2.732999999999972105e-04,7.420000000000342988e-05,4.676000000000020960e-07,1.032600000000011675e-08,-1.740000000000074820e-04,2.554999999999973959e-03,8.230000000000018190e+00};
    vector<float> cluster1_0_23_minOUTPUT = {-1.570200000000003364e-05,-6.136999999999972752e-06,-1.670000000000004814e-04,-1.489999999999991115e-03,-3.600000000002906007e-06,-4.019999999999718243e-05,-1.331000000000004705e-07,-5.383000000000041485e-09,-1.626000000000016321e-03,2.739999999999964686e-04,-2.823000000000001464e+01};
    
    vector<float> cluster1_0_24_maxOUTPUT = {9.699999999999583933e-08,1.940000000000052576e-07,1.904000000000003183e-04,-4.299999999995974387e-05,1.041999999999987381e-04,2.170000000000296692e-05,5.231999999999953676e-07,9.035000000000054103e-09,-1.116000000000172410e-04,1.690000000000024816e-03,2.181999999999970896e+01};
    vector<float> cluster1_0_24_minOUTPUT = {-2.987999999999992398e-06,-2.554999999999978079e-06,-1.208000000000007543e-04,-8.879999999999997921e-04,-6.899999999998920885e-06,-3.089999999999690217e-05,-7.626999999999918675e-07,-1.594799999999997843e-08,-1.075999999999993628e-03,1.750000000000362377e-04,-2.725000000000000000e+01};

    vector<float> cluster1_0_25_maxOUTPUT = {-2.295759999999999988e-04,1.797199999999999395e-04,3.753700000000002174e-03,-1.225689999999999939e-02,9.983600000000002195e-04,4.382400000000002439e-03,-2.369499999999998574e-05,-9.355300000000009134e-07,-1.090099999999994025e-02,2.448200000000000376e-02,1.205599999999999596e+02};
    vector<float> cluster1_0_25_minOUTPUT = {-7.138299999999999333e-04,3.428900000000017264e-05,2.173130000000000114e-03,-1.642499999999999516e-02,6.393600000000002753e-04,1.138400000000004686e-03,-4.512599999999998774e-05,-3.984250000000000012e-06,-1.558099999999995600e-02,1.712599999999999192e-02,2.436999999999989086e+01};
    
    vector<float> cluster1_0_26_maxOUTPUT = {4.003400000000010493e-05,7.943899999999994195e-05,2.749200000000000255e-03,-6.329000000000029047e-03,1.002729999999998553e-03,1.582000000000041435e-04,-8.513099999999996470e-06,-9.932100000000009905e-08,-8.201000000000013834e-03,2.455200000000001478e-02,8.024000000000002331e+01};
    vector<float> cluster1_0_26_minOUTPUT = {-1.318320000000000212e-04,3.482000000000018500e-06,1.239499999999997548e-03,-1.195100000000001543e-02,3.652599999999975159e-04,-1.562499999999994449e-03,-2.767199999999999865e-05,-1.018040000000000082e-06,-1.562600000000003223e-02,1.288499999999997980e-02,2.226999999999998536e+01};
    
    vector<float> cluster1_0_27_maxOUTPUT = {5.399999999998288114e-08,1.009999999999910709e-07,4.110000000000225262e-05,0.000000000000000000e+00,1.970000000000096674e-05,1.400000000002094014e-06,1.044999999999987718e-07,1.490000000000154501e-09,0.000000000000000000e+00,2.270000000001436992e-04,1.250000000000000000e+00};
    vector<float> cluster1_0_27_minOUTPUT = {-4.949999999999876374e-07,-2.469999999999859461e-07,-6.900000000000656456e-06,-1.430000000000042348e-04,-5.000000000005000445e-07,-6.400000000000156411e-06,-6.000000000148682573e-10,-4.000000000004535680e-12,-1.440000000000052620e-04,0.000000000000000000e+00,-4.530000000000200089e+00};
    
    vector<float> cluster1_0_28_maxOUTPUT = {4.500000000000381094e-08,8.800000000000322321e-08,5.780000000000020554e-05,-9.999999999732443015e-07,2.740000000000033736e-05,5.700000000000842434e-06,2.230000000000010836e-07,4.189000000000224486e-09,-2.999999999669932830e-07,4.330000000000167049e-04,4.610000000000127329e+00};
    vector<float> cluster1_0_28_minOUTPUT = {-7.459999999999959068e-07,-5.274000000000045770e-07,-3.079999999999923077e-05,-2.380000000000160037e-04,-2.800000000000718157e-06,-9.699999999997903049e-06,-1.369999999999954696e-07,-5.137000000000133945e-09,-2.754000000000089710e-04,0.000000000000000000e+00,-1.164000000000032919e+01};
    
    vector<float> cluster1_0_29_maxOUTPUT = {-8.200000000001717200e-08,-6.590000000000219814e-07,3.655000000000012948e-04,-2.200000000000534590e-04,2.537000000000025346e-04,1.045000000000039089e-04,2.738999999999974962e-07,6.657999999999979283e-09,-7.819999999999910356e-04,5.439999999999999523e-03,7.288000000000010914e+01};
    vector<float> cluster1_0_29_minOUTPUT = {-7.586999999999980045e-06,-1.427700000000003966e-05,-5.119000000000026307e-04,-2.433000000000018481e-03,8.299999999999280176e-06,-1.073000000000011309e-04,-3.446400000000001426e-06,-3.167399999999996982e-08,-3.463000000000021616e-03,1.229000000000035620e-03,-7.820000000000164597e+00};
    
    vector<float> cluster1_0_30_maxOUTPUT = {2.219999999999717594e-07,3.740000000000339745e-07,3.164999999999973390e-04,-6.900000000001349498e-05,2.467999999999984095e-04,4.749999999999893197e-05,7.012999999999995366e-07,1.219400000000000980e-08,-1.420000000000032347e-04,2.332000000000001173e-03,7.119999999999891749e+00};
    vector<float> cluster1_0_30_minOUTPUT = {-1.130899999999998439e-05,-3.861999999999984369e-06,-1.272000000000009234e-04,-1.391000000000003345e-03,-1.300000000002688106e-06,-4.370000000000067597e-05,-1.082000000000000689e-07,-3.474999999999996375e-09,-1.484999999999986548e-03,2.240000000001129976e-04,-3.974000000000024357e+01};
    
    vector<float> cluster1_0_31_maxOUTPUT = {2.889999999998883046e-08,5.769999999999777043e-08,8.099999999999774047e-05,-9.999999999177333621e-07,3.779999999999929250e-05,9.699999999997903049e-06,2.737000000000038868e-07,5.632999999999955216e-09,-2.999999999739322828e-07,7.480000000000263131e-04,4.210000000000036380e+00};
    vector<float> cluster1_0_31_minOUTPUT = {-1.092899999999990841e-06,-7.662999999999929850e-07,-5.360000000000087595e-05,-3.859999999999975105e-04,-5.200000000000343237e-06,-1.209999999999752940e-05,-5.159999999999794742e-08,-2.611999999999997184e-09,-4.758000000000123242e-04,0.000000000000000000e+00,-1.051000000000021650e+01};
    
    vector<float> cluster1_0_32_maxOUTPUT = {1.599999999999984681e-07,2.789999999999747977e-07,3.209999999999983700e-04,-9.199999999998099943e-05,2.189999999999969478e-04,4.329999999999611937e-05,7.550000000000019828e-07,1.215400000000007197e-08,-2.310000000000089759e-04,2.514999999999878444e-03,9.409999999999852704e+00};
    vector<float> cluster1_0_32_minOUTPUT = {-8.162999999999996214e-06,-4.739000000000051528e-06,-1.844999999999971934e-04,-1.419000000000003592e-03,-3.400000000004093768e-06,-4.089999999999997094e-05,-1.033499999999995907e-06,-2.233600000000002544e-08,-1.599999999999990536e-03,3.630000000000022098e-04,-2.427999999999974889e+01};
    
    vector<float> cluster1_0_33_maxOUTPUT = {1.339999999999956942e-07,2.099999999999996834e-07,1.118999999999981256e-04,-9.999999999732443015e-07,9.769999999999917639e-05,1.829999999999887272e-05,1.629999999999982964e-07,5.800999999999722198e-09,0.000000000000000000e+00,8.879999999999997921e-04,5.579999999999927240e+00};
    vector<float> cluster1_0_33_minOUTPUT = {-4.705999999999991874e-06,-1.307999999999995142e-06,-4.490000000000049507e-05,-5.290000000000016911e-04,-1.800000000003187939e-06,-1.650000000000262368e-05,-1.589999999999420984e-08,-1.939000000000160498e-09,-5.660000000000108304e-04,0.000000000000000000e+00,-1.138000000000010914e+01};
    
    vector<float> cluster1_0_34_maxOUTPUT = {-3.033400000000002501e-05,8.069899999999994005e-05,3.476699999999998802e-03,-2.674999999999982947e-03,8.701500000000000901e-04,1.975300000000006651e-03,-2.233000000000000813e-05,-4.966599999999995782e-07,-2.934999999999993170e-03,2.393699999999998607e-02,9.240000000000007674e+01};
    vector<float> cluster1_0_34_minOUTPUT = {-3.510559999999999809e-04,-8.198000000000005196e-06,5.462999999999995637e-04,-1.454199999999999937e-02,-1.052900000000000846e-04,-8.490000000000580416e-05,-4.795600000000001316e-05,-3.058120000000000970e-06,-1.523500000000000028e-02,4.612000000000004984e-03,-5.470000000000027285e+00};
    
    vector<float> cluster1_0_35_maxOUTPUT = {1.809999999999767524e-07,3.209999999999585243e-07,1.175999999999989554e-04,-9.999999999732443015e-07,8.019999999999553907e-05,1.169999999999643547e-05,2.242999999999971844e-07,5.628999999999950680e-09,0.000000000000000000e+00,8.199999999999874056e-04,2.359999999999672582e+00};
    vector<float> cluster1_0_35_minOUTPUT = {-3.056999999999994194e-06,-8.510000000000093011e-07,-3.799999999999983946e-05,-4.880000000000161986e-04,-7.000000000027816245e-07,-1.539999999999874802e-05,-1.400000000016622530e-09,-7.169999999997808027e-10,-5.219999999999946905e-04,0.000000000000000000e+00,-1.361000000000012555e+01};
    
    vector<float> cluster1_0_36_maxOUTPUT = {2.429999999999772282e-07,4.470000000000179125e-07,2.190000000000004443e-04,-4.399999999998848598e-05,1.512999999999965761e-04,3.020000000000106272e-05,6.284999999999957613e-07,1.084499999999993598e-08,-8.899999999997798561e-05,1.733000000000040064e-03,1.415999999999985448e+01};
    vector<float> cluster1_0_36_minOUTPUT = {-5.448999999999981202e-06,-3.227000000000015013e-06,-1.067999999999971614e-04,-9.740000000000025330e-04,-1.200000000003281775e-06,-3.260000000000068399e-05,-1.412999999999981220e-07,-6.740000000000019325e-09,-1.102999999999992875e-03,1.410000000000022347e-04,-2.104999999999972715e+01};
    
    vector<float> cluster1_0_37_maxOUTPUT = {2.956800000000011061e-05,4.864399999999992254e-05,1.844700000000004669e-03,-2.755999999999980687e-03,9.113999999999996019e-04,3.000000000006469290e-06,-3.711400000000000160e-06,-4.138399999999992244e-08,-4.491999999999995996e-03,2.016799999999996373e-02,6.425000000000000000e+01};
    vector<float> cluster1_0_37_minOUTPUT = {-9.969999999999987553e-06,-2.504100000000006061e-05,-2.384000000000066350e-04,-9.043999999999994752e-03,3.762999999999996057e-04,-1.161300000000003996e-03,-1.545069999999999083e-05,-2.745830000000000970e-07,-1.283600000000001407e-02,7.059000000000037467e-03,2.159999999999854481e+00};
    
    vector<float> cluster1_0_38_maxOUTPUT = {3.572999999999987644e-06,1.622000000000005816e-06,7.953999999999981918e-04,-5.239999999999688267e-04,5.402999999999988758e-04,2.249000000000000998e-04,-9.853999999999990696e-07,-7.904000000000121598e-09,-1.513000000000014550e-03,1.028299999999998833e-02,7.995000000000027285e+01};
    vector<float> cluster1_0_38_minOUTPUT = {-9.930000000000008265e-06,-3.283599999999995463e-05,-6.273000000000077125e-04,-4.703999999999985970e-03,9.379999999999803805e-05,-2.547999999999994714e-04,-7.146300000000003051e-06,-8.025799999999991041e-08,-6.544999999999995266e-03,2.377999999999991232e-03,6.360000000000127329e+00};
    
    vector<float> cluster1_0_39_maxOUTPUT = {9.300000000000064748e-08,1.740000000000291396e-07,7.810000000000108522e-05,0.000000000000000000e+00,4.049999999999540079e-05,3.199999999998343482e-06,1.757999999999992581e-07,2.912999999999729689e-09,0.000000000000000000e+00,4.230000000000067040e-04,1.150000000000090727e+00};
    vector<float> cluster1_0_39_minOUTPUT = {-1.119999999999989065e-06,-4.559999999999970423e-07,-1.400000000000359121e-05,-2.680000000000459792e-04,-6.000000000033756109e-07,-1.090000000000812372e-05,-1.199999999995854990e-09,-6.019999999999944056e-10,-2.689999999999915224e-04,0.000000000000000000e+00,-9.130000000000109139e+00};

    
    // parentCluster1 - chilCluster1 - grandChild
    vector<float> cluster1_1_0_maxOUTPUT = {4.289999999999919962e-08,1.285000000000107129e-07,1.367999999999994221e-04,-2.499999999999725004e-05,1.077800000000000421e-04,2.390000000000030989e-05,2.407999999999994563e-07,4.392000000000003859e-09,-1.140999999999989245e-04,1.659999999999994813e-03,3.971000000000003638e+01};
    vector<float> cluster1_1_0_minOUTPUT = {-1.254300000000005931e-06,-3.313800000000002052e-06,-1.708000000000022001e-04,-7.590000000000097754e-04,-1.397000000000030162e-05,-2.910000000000064635e-05,-3.065600000000003734e-06,-3.414599999999996708e-08,-1.056900000000013384e-03,1.799999999999579714e-04,-3.250999999999976353e+01};
    
    vector<float> cluster1_1_1_maxOUTPUT = {1.219999999999964602e-08,2.790000000000019027e-08,5.909999999999942399e-05,-9.999999998622219991e-07,2.409999999999912212e-05,1.380000000000131291e-05,2.544000000000021721e-07,4.949000000000026647e-09,-1.999999999988122655e-07,7.900000000001238280e-04,6.420000000000072760e+00};
    vector<float> cluster1_1_1_minOUTPUT = {-8.899999999999999491e-07,-7.715999999999978301e-07,-7.990000000000079016e-05,-3.660000000000329656e-04,-1.029999999999954732e-05,-8.700000000000374101e-06,-3.178999999999991078e-07,-7.515999999999946335e-09,-5.024999999999960054e-04,0.000000000000000000e+00,-1.657000000000016371e+01};
    
    vector<float> cluster1_1_2_maxOUTPUT = {2.056999999999997416e-06,3.956000000000001596e-06,8.197999999999990017e-04,-1.680000000000014815e-04,3.487999999999998046e-04,5.050000000000192546e-05,2.713999999999987906e-07,5.238999999999984907e-09,-6.051000000000111845e-04,7.898999999999991098e-03,9.034000000000014552e+01};
    vector<float> cluster1_1_2_minOUTPUT = {-1.115799999999998871e-05,-7.393999999999976980e-06,-3.883000000000011442e-04,-3.809999999999979636e-03,-2.199999999997342970e-06,-2.245999999999949155e-04,-1.158859999999998422e-05,-2.911859999999999976e-07,-5.028000000000004688e-03,9.510000000000351505e-04,-2.205999999999994898e+01};
    
    vector<float> cluster1_1_3_maxOUTPUT = {3.546599999999997519e-06,7.881999999999989926e-06,8.900999999999976205e-04,-7.129999999999637713e-04,3.847400000000006566e-04,3.271999999999997133e-04,-1.479899999999998951e-06,-1.598699999999989030e-08,-1.115799999999999908e-03,8.853999999999973003e-03,4.455999999999994543e+01};
    vector<float> cluster1_1_3_minOUTPUT = {-3.144039999999999801e-05,-2.942099999999992973e-06,2.290000000000104452e-05,-4.156999999999965410e-03,-1.366600000000002535e-04,-3.023000000000019270e-04,-2.135300000000000037e-05,-9.972499999999998540e-07,-5.635000000000028875e-03,1.752999999999949043e-03,-1.961000000000012733e+01};
    
    vector<float> cluster1_1_4_maxOUTPUT = {-3.999999999941008209e-10,3.300000000000460097e-09,1.770000000000069790e-05,0.000000000000000000e+00,2.025000000000116984e-05,7.599999999999967892e-06,1.522000000000016937e-07,2.973000000000009069e-09,-3.999999999976245309e-07,3.509999999999902087e-04,1.035999999999967258e+01};
    vector<float> cluster1_1_4_minOUTPUT = {-3.769000000000065050e-07,-4.523000000000058170e-07,-3.846000000000057706e-05,-1.550000000000162359e-04,-8.450000000000124079e-06,-5.100000000000937117e-06,-6.335000000000000544e-07,-1.506300000000001054e-08,-2.235000000000014753e-04,0.000000000000000000e+00,-2.057999999999992724e+01};
    
    vector<float> cluster1_1_5_maxOUTPUT = {-1.700000000000339271e-09,-1.899999999999083954e-09,3.401999999999918978e-05,0.000000000000000000e+00,3.385000000000019937e-05,1.490000000000171573e-05,8.530000000000748052e-08,1.532000000000043100e-09,-1.700000000000312372e-06,7.389999999999897736e-04,2.015000000000009095e+01};
    vector<float> cluster1_1_5_minOUTPUT = {-4.257999999999985321e-07,-6.157000000000049640e-07,-9.479999999999903814e-05,-3.090000000000037161e-04,-1.393000000000054087e-05,-1.040000000000068647e-05,-1.078900000000000800e-06,-1.815300000000001372e-08,-4.702999999999998848e-04,2.000000000002000178e-06,-2.768000000000029104e+01};
    
    vector<float> cluster1_1_6_maxOUTPUT = {-6.449999999999743428e-09,-5.669999999998541333e-09,1.819000000000039335e-05,0.000000000000000000e+00,2.263000000000004930e-05,1.340000000000368843e-05,4.109999999999863426e-08,7.510000000000310108e-10,-6.349999999999585143e-06,4.680000000000240066e-04,2.203000000000020009e+01};
    vector<float> cluster1_1_6_minOUTPUT = {-3.209000000000022978e-07,-4.821000000000000090e-07,-6.483000000000009588e-05,-1.849999999999907816e-04,-1.767999999999995270e-05,-6.400000000000156411e-06,-1.108399999999997723e-06,-1.298700000000003549e-08,-2.979000000000002479e-04,1.000000000001000089e-05,-1.835999999999967613e+01};
    
    vector<float> cluster1_1_7_maxOUTPUT = {8.817999999999984013e-06,2.496900000000000776e-05,1.761499999999999178e-03,-1.628999999999991349e-03,6.521300000000007646e-04,8.928000000000025109e-04,-5.053999999999995996e-06,-7.928999999999996421e-08,-2.017900000000003025e-03,1.605100000000000970e-02,5.575000000000000000e+01};
    vector<float> cluster1_1_7_minOUTPUT = {-1.192689999999999994e-04,-7.695000000000000017e-06,1.603999999999997789e-04,-7.531000000000009041e-03,-1.427099999999998856e-04,-6.099000000000034949e-04,-3.384699999999998951e-05,-2.646550000000000097e-06,-1.021599999999994908e-02,3.171000000000007146e-03,-2.769999999999982254e+00};
    
    vector<float> cluster1_1_8_maxOUTPUT = {4.700000000003530307e-09,1.499999999999900604e-08,3.769999999999815166e-05,0.000000000000000000e+00,2.560000000000062565e-05,1.140000000000168826e-05,2.259000000000007192e-07,4.242999999999967253e-09,-2.999999999947489115e-07,6.079999999999973230e-04,1.000000000000000000e+01};
    vector<float> cluster1_1_8_minOUTPUT = {-6.867000000000014043e-07,-6.630999999999970902e-07,-6.410000000000096176e-05,-2.770000000000271702e-04,-9.299999999998545541e-06,-5.699999999997373834e-06,-5.567999999999943979e-07,-1.391699999999992206e-08,-3.870000000000053952e-04,0.000000000000000000e+00,-1.975000000000000000e+01};
    
    vector<float> cluster1_1_9_maxOUTPUT = {1.560899999999997879e-05,3.559399999999995770e-05,1.859799999999998477e-03,-2.354999999999995985e-03,8.391100000000004415e-04,1.898999999999997912e-04,-3.354700000000003643e-06,-2.949499999999995739e-08,-3.750000000000003331e-03,1.883999999999999911e-02,5.539000000000010715e+01};
    vector<float> cluster1_1_9_minOUTPUT = {-4.171200000000000992e-05,-5.912000000000007940e-06,4.849999999999993205e-05,-8.624000000000020538e-03,1.571899999999997605e-04,-8.980000000000029625e-04,-2.505400000000000780e-05,-8.127700000000002032e-07,-1.199099999999997390e-02,5.892000000000007474e-03,2.000000000000000000e+00};
    
    vector<float> cluster1_1_10_maxOUTPUT = {4.824999999999941098e-07,1.085200000000007838e-06,4.170000000000007034e-04,-5.899999999997574529e-05,1.686000000000014148e-04,3.659999999999774545e-05,3.696000000000040507e-07,7.175999999999983491e-09,-1.807000000000058288e-04,3.373999999999987686e-03,5.883999999999968367e+01};
    vector<float> cluster1_1_10_minOUTPUT = {-3.596999999999986059e-06,-3.665000000000000062e-06,-2.790999999999974057e-04,-1.653999999999877790e-03,-1.190000000000218830e-05,-7.419999999999996043e-05,-4.996400000000001833e-06,-6.428899999999997435e-08,-2.146799999999976505e-03,2.840000000000064695e-04,-7.432000000000014950e+01};
    
    vector<float> cluster1_1_11_maxOUTPUT = {-1.199999999999243122e-09,0.000000000000000000e+00,3.220000000000132478e-05,0.000000000000000000e+00,7.834999999999960052e-05,1.410000000000300072e-05,1.308000000000089798e-07,2.405000000000106570e-09,-1.199999999996342881e-06,7.130000000000192824e-04,2.053000000000020009e+01};
    vector<float> cluster1_1_11_minOUTPUT = {-4.563999999999978135e-07,-1.136899999999999228e-06,-8.709999999999967768e-05,-2.979999999999094484e-04,-1.375999999999981405e-05,-2.900000000000125039e-05,-1.906399999999999230e-06,-3.819500000000003199e-08,-4.539000000000001909e-04,1.999999999946489027e-06,-2.965999999999985093e+01};
    
    vector<float> cluster1_1_12_maxOUTPUT = {2.239999999999490662e-08,4.720000000000862828e-08,6.200000000000129019e-05,-9.999999999177333621e-07,2.950000000000001232e-05,1.050000000000009259e-05,2.560999999999856239e-07,5.302999999999952426e-09,-1.999999999988122655e-07,6.299999999999638138e-04,5.390000000000326530e+00};
    vector<float> cluster1_1_12_minOUTPUT = {-8.499000000000002187e-07,-6.318999999999693352e-07,-5.849999999999952460e-05,-3.130000000000076623e-04,-7.399999999999421777e-06,-9.500000000002561951e-06,-5.393000000000171177e-07,-1.549199999999999076e-08,-4.006999999999968920e-04,0.000000000000000000e+00,-1.922000000000025111e+01};
    
    vector<float> cluster1_1_13_maxOUTPUT = {8.499000000000002187e-07,2.003000000000014534e-06,6.088999999999990254e-04,-9.199999999998099943e-05,2.013800000000010026e-04,9.399999999999686384e-05,-2.750000000000270132e-08,3.009999999999442633e-10,-4.200999999999996404e-04,5.093999999999986560e-03,7.175999999999976353e+01};
    vector<float> cluster1_1_13_minOUTPUT = {-7.113599999999998265e-06,-3.301000000000014643e-06,-2.608000000000020024e-04,-2.541999999999989147e-03,-5.431000000000012207e-05,-1.300999999999975787e-04,-1.132579999999999920e-05,-2.767260000000001712e-07,-3.242099999999997761e-03,6.610000000000227889e-04,-3.250000000000000000e+01};
    
    vector<float> cluster1_1_14_maxOUTPUT = {2.210000000000034745e-07,4.808999999999973777e-07,2.970999999999997948e-04,-1.899999999999124611e-05,8.281000000000000166e-05,9.610000000000173959e-05,-4.199999999999044992e-09,-1.730000000000108797e-10,-1.515000000000023272e-04,2.479999999999982219e-03,3.823999999999978172e+01};
    vector<float> cluster1_1_14_minOUTPUT = {-6.141000000000001851e-06,-1.299599999999997052e-06,-1.428000000000019531e-04,-1.153999999999988368e-03,-6.768000000000053108e-05,-4.900000000000390155e-05,-8.012199999999997590e-06,-2.405929999999999892e-07,-1.578599999999999448e-03,2.380000000000160037e-04,-2.974000000000024002e+01};
    
    // parentCluster1 - chilCluster2 - grandChild
    vector<float> cluster1_2_0_maxOUTPUT = {4.499999999999296230e-07,7.686000000000020940e-06,1.804000000000041681e-05,-2.099999999999671574e-06,1.419799999999998841e-04,1.091000000000008630e-04,3.503999999999992201e-08,1.761999999999986264e-09,-2.999999999864222389e-06,8.159999999999834053e-04,2.617999999999983629e+01};
    vector<float> cluster1_2_0_minOUTPUT = {-2.082000000000016997e-05,-4.352000000000110121e-06,-7.333999999999986363e-05,-4.518000000000021998e-04,-2.316000000000036779e-05,-1.329999999998693339e-05,-1.792299999999994681e-07,-4.913999999999986960e-09,-5.200000000000204459e-04,4.999999999977244869e-06,-4.361000000000012733e+01};
    
    vector<float> cluster1_2_1_maxOUTPUT = {7.400000000008094547e-08,1.877999999999862418e-06,1.916000000000001036e-04,-1.400000000002094014e-06,2.428000000000013481e-04,1.631999999999952933e-04,9.310000000000085351e-08,4.304999999999984617e-09,0.000000000000000000e+00,2.259999999999984244e-03,1.348000000000001819e+01};
    vector<float> cluster1_2_1_minOUTPUT = {-2.659400000000000999e-05,-1.367199999999994635e-05,-2.034999999999988207e-04,-1.297899999999983789e-03,-1.370000000000017037e-05,-1.409999999999606013e-05,-4.149000000000000425e-07,-9.785999999999979235e-09,-1.437999999999994838e-03,-9.999999999732445133e-07,-4.146999999999979991e+01};
    
    vector<float> cluster1_2_2_maxOUTPUT = {2.540000000000094266e-06,2.501000000000000618e-05,-5.170000000001171922e-07,-1.221999999999996093e-06,1.256700000000004688e-04,2.839000000000035939e-04,-9.229999999999878171e-10,2.784000000000006930e-09,5.000000000032756020e-06,1.172000000000006370e-03,5.786000000000012733e+01};
    vector<float> cluster1_2_2_minOUTPUT = {-5.829000000000012123e-05,-8.059999999999946547e-06,-8.018000000000000821e-05,-6.541700000000007925e-04,-8.540000000000001583e-05,6.400000000003625011e-06,-1.261299999999999257e-07,-2.488000000000015397e-09,-7.460000000000244214e-04,-7.999999999980245136e-06,-8.305000000000018190e+01};
    
    vector<float> cluster1_2_3_maxOUTPUT = {6.850000000000085187e-06,3.132899999999997059e-05,-1.174999999999987903e-06,-1.516000000000017334e-06,4.728000000000023850e-05,3.935000000000049569e-04,-1.231999999999994091e-09,4.002000000000011616e-09,8.500000000000174083e-05,1.269999999999993356e-03,3.015000000000009095e+01};
    vector<float> cluster1_2_3_minOUTPUT = {-6.894999999999991414e-05,-1.762000000000009219e-05,-1.386279999999999067e-04,-6.457199999999998011e-04,-1.308299999999999654e-04,9.700000000001374190e-06,-2.106399999999995621e-07,-5.363999999999994298e-09,-8.080000000000309157e-04,-1.349999999999962341e-04,-9.867000000000007276e+01};
    
    vector<float> cluster1_2_4_maxOUTPUT = {4.999999999991990018e-08,3.890000000000099975e-06,1.495400000000000895e-04,-1.399999999998624567e-06,2.078000000000010394e-04,1.449000000000033594e-04,4.798999999999697740e-08,2.283999999999995835e-09,0.000000000000000000e+00,1.926999999999956525e-03,1.382999999999992724e+01};
    vector<float> cluster1_2_4_minOUTPUT = {-2.960000000000006896e-05,-8.389000000000030981e-06,-1.229999999999998456e-04,-1.115099999999993874e-03,-2.050000000000141986e-05,-1.629999999999687255e-05,-3.868000000000011078e-07,-9.417999999999985469e-09,-1.226000000000004864e-03,0.000000000000000000e+00,-4.419999999999981810e+01};
    
    vector<float> cluster1_2_5_maxOUTPUT = {6.681000000000004643e-05,6.739000000000007137e-05,1.442599999999998744e-03,-3.252999999999936498e-04,8.701999999999997931e-04,3.644000000000008344e-04,2.980999999999997378e-07,7.307000000000053453e-09,-5.350000000000076916e-04,1.950700000000005208e-02,1.010699999999997090e+02};
    vector<float> cluster1_2_5_minOUTPUT = {-3.092999999999997661e-05,-4.776999999999993057e-05,-6.170999999999988994e-04,-8.282000000000011575e-03,1.129999999999534155e-05,-1.442100000000015592e-03,-1.105459999999999408e-05,-2.857090000000002193e-07,-1.241500000000000936e-02,8.409999999999806519e-04,-3.202999999999974534e+01};
    
    vector<float> cluster1_2_6_maxOUTPUT = {8.599999999994462768e-08,6.969999999999697791e-07,2.900000000000020617e-04,-1.899999999999124611e-06,2.728000000000035952e-04,1.345999999999986096e-04,3.373999999999944318e-07,8.021999999999990703e-09,0.000000000000000000e+00,2.757000000000009443e-03,1.069000000000005457e+01};
    vector<float> cluster1_2_6_minOUTPUT = {-2.168699999999994330e-05,-1.196500000000006586e-05,-2.117000000000021642e-04,-1.491999999999993332e-03,-7.800000000003984302e-06,-3.510000000000318421e-05,-3.618000000000005001e-07,-7.917000000000003990e-09,-1.755000000000062066e-03,0.000000000000000000e+00,-2.680999999999994543e+01};
    
    vector<float> cluster1_2_7_maxOUTPUT = {7.061000000000003038e-05,1.849400000000001910e-04,2.964600000000001262e-03,-4.568499999999999645e-03,9.756599999999997219e-04,3.803600000000000730e-03,-6.080200000000003213e-06,-8.062999999999989548e-08,-5.163000000000028678e-03,2.459700000000000775e-02,1.037000000000000455e+02};
    vector<float> cluster1_2_7_minOUTPUT = {-6.291199999999999397e-04,2.515000000000004211e-05,-6.816999999999934223e-05,-1.315879999999999828e-02,6.588999999999987228e-05,-1.698699999999997434e-03,-2.654200000000000439e-05,-1.329970000000002108e-06,-1.565500000000003000e-02,8.114000000000010093e-03,6.839999999999918145e+00};
    
    vector<float> cluster1_2_8_maxOUTPUT = {8.711000000000005197e-05,1.631299999999998290e-04,6.158699999999992652e-04,-1.213000000000000753e-05,5.311400000000011251e-04,1.872200000000007886e-03,4.185999999999929090e-08,5.804999999999991431e-09,9.300000000012076384e-05,1.561600000000001875e-02,6.538000000000010914e+01};
    vector<float> cluster1_2_8_minOUTPUT = {-3.686099999999996844e-04,-4.765999999999993332e-05,-4.312000000000005065e-04,-6.087099999999998068e-03,-1.280800000000000341e-04,-1.493700000000000583e-03,-1.005560000000000245e-05,-3.290199999999998585e-07,-9.939000000000031143e-03,-1.460000000000072351e-04,-9.200000000000000000e+01};
    
    vector<float> cluster1_2_9_maxOUTPUT = {2.419999999999939561e-06,2.533799999999996645e-05,1.360100000000006443e-04,-6.606999999999967066e-05,2.043000000000010086e-04,2.977000000000049051e-04,4.279999999999898035e-08,2.738999999999929434e-09,-1.019999999999354756e-04,2.254000000000033754e-03,2.654000000000041837e+01};
    vector<float> cluster1_2_9_minOUTPUT = {-6.039000000000000964e-05,-2.829000000000004254e-05,-2.504999999999989874e-04,-1.228899999999998049e-03,-2.496000000000008628e-05,1.139999999999474767e-05,-4.593000000000008372e-07,-8.659000000000051266e-09,-1.435000000000019593e-03,1.609999999999667253e-04,-6.882999999999992724e+01};
    
    
    // Declare PCA parameters for each cluster: mean, eigenVal, eigenVec then Load
    // Child of parentCluster0

    
    
    std::string cluster0_0_pcaMeanLoadPATH = casePath + cluster0_0_Folder + "PCA_mean_cluster0_0.txt";
    std::string cluster0_0_pcaEigenValLoadPATH = casePath + cluster0_0_Folder + "PCA_eigenValues_cluster0_0.txt";
    std::string cluster0_0_pcaEigenVecLoadPATH = casePath + cluster0_0_Folder + "PCA_eigenVectors_cluster0_0.txt";
    vector<float> cluster0_0_pcaMeanLoad;
    vector<float> cluster0_0_pcaEigenValLoad;
    vector<float> cluster0_0_pcaEigenVecLoad;
    readFromCommaDelimitedFile_Float(cluster0_0_pcaMeanLoadPATH, cluster0_0_pcaMeanLoad);
    readFromCommaDelimitedFile_Float(cluster0_0_pcaEigenValLoadPATH, cluster0_0_pcaEigenValLoad);
    readFromCommaDelimitedFile_Float(cluster0_0_pcaEigenVecLoadPATH, cluster0_0_pcaEigenVecLoad);
    cv::PCA pcaANN0_0;
    pcaANN0_0.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_0_pcaMeanLoad.data());
    pcaANN0_0.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_0_pcaEigenValLoad.data());
    pcaANN0_0.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_0_pcaEigenVecLoad.data());
    
 
    vector<float> cluster0_1_pcaMeanLoad = {7.673427830722997308e-17,2.131878427753041611e-16,-3.469723888674746609e-17,-2.153564202057258783e-15,1.191883518489474210e-16,4.328814178418734690e-16,2.068489241325329709e-17,7.189668250090461446e-17,1.439601786503031855e-16,8.937875286307352020e-16,-2.279341693021718453e-15};
    vector<float> cluster0_1_pcaEigenValLoad = {6.616298106128359890e+00,3.076718213907095656e+00,8.359514386961905963e-01,3.804537018331293208e-01,5.384670363067607657e-02,2.028383272258930253e-02,1.319325167258979248e-02,3.325137472157260483e-03,1.871738239861615069e-04,6.922703412439564048e-07,1.788943554807545308e-10};
    vector<float> cluster0_1_pcaEigenVecLoad = {2.707073685129749441e-01,3.139515816643486112e-01,2.450230922535014400e-01,2.691306954886172886e-01,-2.117563982781087706e-01,-2.245473828342053058e-01,3.652255083589264206e-01,3.088916532460596609e-01,3.345341673702323382e-01,-3.603856968094026336e-01,-3.603155473444880630e-01,2.751947575273304136e-01,3.116929965838119987e-01,3.065448858273230881e-01,-4.057657438328210464e-01,4.392688952707540784e-01,4.264317864979872974e-01,1.698962110879246590e-01,2.038851431765388023e-01,2.080569810935476716e-01,1.996205350673172507e-01,2.003211046651391380e-01,5.312320554479397217e-01,-2.067266262737680882e-01,-5.767036351097056812e-01,-6.194142962422908433e-02,-1.964603442958166302e-01,3.890899178601926051e-02,8.094556076918667242e-02,4.923357559405004413e-01,-1.262283805742651366e-01,1.196283309319007698e-01,1.390359064020872948e-01,-2.476600725416329696e-01,-5.178935826106644685e-02,-2.970479232347158494e-01,-1.694616988153506421e-01,-4.277675469803471908e-01,5.261917654339837158e-01,1.518315171769563654e-01,-1.871144069210987360e-01,5.358549053808328022e-01,-1.139158397457084859e-01,-3.135055764512316434e-02,6.404638111903430131e-01,2.643469453574137096e-01,-7.854688568384241010e-02,4.770702856021101154e-03,-1.122874511074934412e-01,-3.212203806665700490e-02,-2.842850351179798118e-01,-6.427990811691306483e-01,7.120961972384727556e-02,-3.130596817341486926e-02,5.883506199502835411e-03,1.739002204245368999e-01,-5.921922729265399754e-01,-1.317363970180980282e-01,5.114168471107418540e-02,5.597965858692389718e-01,-8.620976984315280311e-02,2.753928687913443918e-01,-2.299442331587020494e-01,2.915476858162202034e-01,-1.747706221061815779e-01,-1.844785273154796457e-01,-3.410873988520465860e-02,1.524669095002335051e-01,-8.513084446722549159e-02,-3.224000373359808130e-02,-1.029269634820873663e-01,-7.275415483066265121e-02,8.036951438220517607e-01,-3.442923314956474190e-01,-3.690245948432358536e-01,1.949993787794543076e-01,1.129142459578688917e-01,2.418565403948531312e-01,-5.605172712119360634e-01,6.276791444445033452e-01,-6.441974715963927345e-02,-4.287573674960283854e-01,1.209769223736826133e-01,5.100401516949149006e-02,-3.175150656369401386e-02,-7.737456514111318295e-02,7.965164773945000720e-02,1.215965392873919193e-01,-4.080052168882573882e-02,2.115903767674425645e-02,8.800109216900508374e-03,2.551158819649612108e-01,2.274396178153836878e-02,-1.929629338144980555e-01,5.401807206715336651e-02,2.728121185848420222e-04,2.511212699653009861e-01,-2.852495408661082088e-01,8.646541831553764546e-01,-5.266208733281878274e-02,-1.583093908963859042e-02,-1.842452768518118220e-02,-8.108372726570691746e-01,-1.057692227634773330e-01,-4.740796448621601433e-01,-5.028361478198934732e-03,4.903044885339989266e-06,2.337503997350141513e-02,-3.196373707737366066e-01,2.238696241536633838e-02,-5.395560588732377372e-02,-1.299059854048631446e-02,6.779449974077812747e-06,2.695587811446212463e-04,-9.224087382028194060e-02,-4.460537911923622700e-01,-3.296728183140395282e-03,-2.140812282368788312e-04,4.958628611806842335e-01,7.372629851972802850e-01,-1.034409816478327625e-05};
    cv::PCA pcaANN0_1;
    pcaANN0_1.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_1_pcaMeanLoad.data());
    pcaANN0_1.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_1_pcaEigenValLoad.data());
    pcaANN0_1.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_1_pcaEigenVecLoad.data());
    
    vector<float> cluster0_2_pcaMeanLoad = {1.074809506492739103e-15,-3.179353039360647541e-17,-1.339135622910334544e-17,-4.455032889289936767e-17,4.857648828204154886e-18,1.411343916302558655e-17,4.673845899569402871e-17,2.792054011165991537e-17,9.071987406186677736e-16,-1.638099838855169519e-15,3.552866847907696589e-15};
    vector<float> cluster0_2_pcaEigenValLoad = {4.467414181964063147e+00,3.804680334169145084e+00,1.806576873373419989e+00,6.783513253113854224e-01,1.882584395300730962e-01,5.065838737636962907e-02,3.422178737224136017e-03,4.274873577952627052e-04,2.785400124642014100e-04,1.959314259453515562e-09,5.168744423849999972e-11};
    vector<float> cluster0_2_pcaEigenVecLoad = {-3.522066769269136532e-01,-1.815228972049459655e-02,2.163438209704494353e-01,4.232120085557457001e-01,2.105718520990409737e-01,-1.121534521158470132e-01,3.372934121584412193e-01,3.034618470172884552e-01,-4.116398743958597506e-01,-2.914792718663537507e-01,-3.640405275916299699e-01,-1.119422379499508263e-01,4.528246121505316579e-01,3.596802814392978109e-01,-1.038842438314609706e-01,3.701364104863550941e-01,4.140400240882946004e-01,2.113125146128706500e-01,2.372240015658276802e-01,4.764217678908413273e-02,3.634358133049901407e-01,3.139160523981682771e-01,4.679845161130214426e-01,-1.765753194762741396e-01,3.055139815032957840e-01,-2.940375448827101112e-01,2.932787023776045610e-01,-3.888475505060023374e-01,2.436517294132948264e-01,3.098756489684047488e-01,3.579492600004952063e-01,-2.120521099642114493e-01,-6.570472272218849663e-02,3.666970608224363968e-03,2.258944492842704099e-01,4.201740148237794181e-01,5.130909009063992082e-02,4.099276302633431124e-01,-1.272869426655970637e-01,-5.180963186382711028e-01,-5.086791528330761869e-01,-2.620936928711692024e-02,-1.785562519070539311e-01,-1.605903352526148187e-01,-1.140086004055010788e-01,-8.185976169342272790e-01,2.269170541550827314e-01,6.151600617659768594e-02,2.427880833291866658e-01,1.776813334241398867e-01,-2.184989061765702512e-01,5.369273513000760029e-02,-1.088057559278423486e-01,2.643751256197777177e-01,1.968505043712125147e-01,-6.835876898540116722e-03,1.564915454258912209e-01,-9.730587043125484004e-02,1.040154474563625454e-02,-3.227171905708596522e-02,-1.225338732988834681e-02,-6.817991097079401097e-01,7.018489695898554315e-01,-1.243659629465460048e-03,-6.500601160654673194e-02,-5.501002403801506790e-02,-9.643218847801300619e-02,-1.180230847550937934e-01,1.481572511911199291e-02,-1.548481044120337269e-01,-1.726390573393149150e-02,6.493718640832326638e-01,1.087767936848766000e-02,-1.295610522155094327e-02,2.432707797407563655e-01,-6.863349354787320333e-01,-8.341614356863140400e-03,-4.650855344242146167e-02,5.115272256812863211e-02,-1.613447802321657520e-01,1.888211627510933965e-01,1.625195243420540780e-01,-2.867096779262830464e-01,1.609809540631982130e-03,-5.148537819174782600e-03,-1.405060766357488500e-01,-3.832428210596919849e-01,8.113406388299342353e-01,-1.342561145121079838e-02,1.618827505684805948e-02,6.831754984988064328e-01,4.901524223410935049e-02,-6.913074240297963913e-01,-7.301147183392739382e-02,-3.277165107295713226e-02,3.448152880658846009e-02,-4.140354221583668337e-02,-6.713578699860367482e-02,1.967368376857455969e-01,-7.461194820461645172e-01,-3.018830468743893478e-02,-4.265890348892662312e-04,-5.653624333505933297e-01,-1.127361537282087428e-03,-3.169750558076929736e-01,-1.867444642362130506e-03,-2.247241127876651245e-04,1.489651809195340626e-01,-9.533297586529855538e-03,1.343910133944864558e-04,2.510279005745016945e-01,1.010512505581159966e-02,-2.849762275773717055e-04,-5.791787341262917277e-01,3.040729824963522452e-04,8.471811065044437816e-02,1.810862908795789759e-04,4.220603172903928605e-05,-7.647224892278702280e-01,-9.724721816887942072e-02,-5.154724787412351929e-06};
    cv::PCA pcaANN0_2;
    pcaANN0_2.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_2_pcaMeanLoad.data());
    pcaANN0_2.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_2_pcaEigenValLoad.data());
    pcaANN0_2.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_2_pcaEigenVecLoad.data());
    
    vector<float> cluster0_3_pcaMeanLoad = {1.874809117110972110e-16,2.329127940199239561e-16,1.618882793187886985e-16,1.785532492486640079e-18,-6.844541221198787754e-17,7.242318182024977984e-16,4.315036856842713878e-18,1.974005366693563150e-17,-2.977871412469385247e-15,6.455691922835030446e-16,2.331111865190891212e-16};
    vector<float> cluster0_3_pcaEigenValLoad = {5.906143381133048820e+00,3.890874082603214212e+00,1.071533684866112335e+00,8.747235443951266454e-02,2.798021769083098090e-02,9.454936476816722113e-03,5.108752741556189109e-03,1.312077175050733709e-03,4.253443173037805528e-04,2.310742061699096700e-06,2.727572039200737364e-10};
    vector<float> cluster0_3_pcaEigenVecLoad = {4.095891548516286118e-01,-1.180898602926750002e-01,-1.408816341099946023e-01,2.958795248363709635e-02,-3.827392235988936187e-01,-3.999365170895663457e-01,3.280895463660534611e-02,1.659021686084484817e-02,4.085003965379684909e-01,-4.057883084954400643e-01,-3.977958123163028992e-01,-7.816627925241473535e-04,1.109256748319807362e-01,4.644621208229921527e-01,4.997262372413256992e-01,1.059408637369211731e-01,-5.796350845594228779e-02,4.992541304062425578e-01,4.938486432321793629e-01,-2.368774936705870388e-02,-7.260136079814166754e-02,-9.320428460087402944e-02,-5.110554414465572765e-02,-8.940246439654727650e-01,-1.247028608395382432e-01,1.354157676401670229e-01,-2.268201779401209650e-01,1.782804240257850059e-01,1.367676481838694669e-01,1.476767796129732080e-01,-9.557188889097717466e-02,5.634848428229807110e-02,1.678262927780957980e-01,-2.008452161338157571e-01,3.875471924750739094e-01,-5.047771883631299028e-01,9.068762484792450285e-02,-5.784532518286610303e-01,1.914906575284460455e-01,7.970516954548037547e-02,3.847162059895981034e-01,-8.772572246040444277e-02,6.399767839300163352e-02,9.495421355830312160e-02,2.501545526654553320e-01,-7.790691836597953002e-02,-2.873555548942847149e-01,-2.139275750201226345e-01,4.162544929982314734e-01,-3.091538923235641612e-01,-2.507744278399691162e-01,6.604193772304465249e-01,-7.460052751765409995e-02,1.682360161845193047e-01,3.550907153644388553e-02,3.394834875586583145e-01,4.758329159390319030e-02,1.379328868671548525e-01,1.320326904136355783e-01,-3.351993294452851879e-01,-4.892332559834193240e-01,3.534088407969684931e-02,-2.080430687258474354e-01,-4.094555698195008198e-01,5.026019224000208840e-01,1.718355539730098691e-01,-4.290884070834242309e-02,-2.219515114029394637e-02,6.263620809755444663e-01,-3.850178742111577401e-01,-4.113332278987027468e-01,1.101419849463851908e-01,-4.024301470031422245e-01,3.259221247649263797e-01,6.809926142765007628e-02,-6.563304596078499767e-03,5.399874521568429758e-02,-6.390763764789222923e-02,-1.564306416725969387e-02,-7.525091807583552360e-03,6.909811546059219101e-01,1.728434370830535943e-02,2.341894641297296784e-02,-7.058551067512537358e-01,-8.330438266244818632e-03,-6.461220964243834242e-02,-7.380816319333625974e-02,-9.689746777173803560e-02,-1.450829500062436606e-01,-8.252024425505030680e-02,-9.353133807018937373e-03,-1.192152133868951414e-01,-2.044049796412943792e-02,1.309207925060841826e-01,1.696872540675118876e-02,1.708916934827524325e-02,-3.057938847903461932e-01,3.067585721742425164e-01,-8.672328590953766181e-01,2.376386724863272237e-01,2.542662008119002393e-02,2.053536498781461349e-03,1.404680273854913564e-01,1.523038471959523889e-02,2.870049043748640338e-01,2.061543279925092970e-03,-9.757727170761817123e-04,6.602422336493715127e-01,6.355421133263501332e-01,-2.651976334366288809e-02,-7.266447835060517724e-01,-8.803577492521111325e-02,1.107914849008054253e-04,1.293622587980196564e-03,-2.148761385415273034e-02,-5.666757023471512555e-01,-3.844912506436465056e-04,1.317711332951801568e-05,3.229171283121723413e-01,1.958996317028920686e-01,1.433769790387242954e-04};
    cv::PCA pcaANN0_3;
    pcaANN0_3.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_3_pcaMeanLoad.data());
    pcaANN0_3.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_3_pcaEigenValLoad.data());
    pcaANN0_3.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_3_pcaEigenVecLoad.data());
    
    vector<float> cluster0_4_pcaMeanLoad = {5.649692912408085057e-16,-1.591836462758793573e-18,-2.009693534232977011e-17,1.258877335965079310e-16,3.913264637615367629e-18,-3.183672925517587454e-17,4.510203311149915508e-18,7.959182313793968634e-18,8.635712810466455768e-17,-1.152489599037366636e-15,-4.296631919063110544e-16};
    vector<float> cluster0_4_pcaEigenValLoad = {5.488150227899236455e+00,3.366187883938348335e+00,1.754189103342430389e+00,1.869360523041923017e-01,1.369356030868149887e-01,5.688501100544909178e-02,9.948267494315385720e-03,8.869964928743120317e-04,8.622006849404634287e-05,6.685332171063017913e-12,5.355016906270135434e-12};
    vector<float> cluster0_4_pcaEigenVecLoad = {3.923809635875047941e-01,1.978009884109109273e-01,1.790002491526468953e-01,-3.942303614939195455e-01,1.713850640592196051e-01,1.831117963402549287e-01,2.314605700752838946e-01,1.790532038508793056e-01,3.937347052863923724e-01,3.993827765602986357e-01,3.954527095205173093e-01,-2.128572790603029674e-01,3.659934806546930042e-01,4.235212959330182381e-01,2.075647307250836349e-01,3.978265545981967133e-01,4.084074514913861309e-01,2.850565281046441024e-01,2.649527341791115265e-01,-2.090084809999070425e-01,-1.912077133110763050e-01,-2.037705106701846181e-01,3.725409526175858105e-02,3.755924997604754845e-01,3.151353617024703069e-01,-3.308026974228317485e-02,4.046246140788285484e-01,-3.209906471546354889e-01,-4.526931049378385419e-01,-5.322499772996449607e-01,3.418543611560753009e-02,2.159505398024430187e-02,2.292719338657276187e-02,-8.204770639695877985e-03,5.645770842309483228e-01,-4.200276083116907810e-01,1.358715147244610698e-02,6.288107042508640776e-02,-5.270249828837054729e-01,5.238476650045598149e-02,4.651942128371803764e-01,-1.108643733558221066e-02,-4.898417816672012010e-02,-3.458403457530116742e-02,1.609571384750155612e-02,-3.288284721710095226e-01,1.479593568593958186e-01,-1.537404584675822194e-02,2.484204946115565749e-01,2.058261084975943067e-02,-6.651404024834619566e-01,6.028688620894209205e-01,1.507170045480107565e-02,2.389816423088550815e-02,2.621348896981325061e-02,-2.196201657814396760e-03,-4.607511149492100055e-01,3.370031560938643866e-01,7.889548949616950746e-03,2.885028211893514438e-01,-6.134871850347564104e-01,4.557329905829347050e-01,7.314563228259805816e-02,-5.977350299906549445e-03,-3.567813020524793904e-02,-1.087706836255046550e-02,-3.894547931793584938e-03,-2.142586500376518766e-01,-6.122977104874233190e-01,2.647905138830753628e-03,7.045756197461718884e-01,2.002692672121220430e-01,8.513762951159940806e-02,-1.707285434103295030e-01,-2.168785316411123924e-04,-4.440048475211158530e-02,6.526776236332224035e-02,2.164367801870357433e-01,-2.791463459727924756e-02,-3.845975241265900402e-02,-2.168745876682731111e-01,4.924138847112745354e-02,2.177716483414618778e-02,5.245493538115720764e-03,-8.657435585413540344e-03,2.151699636298564922e-01,2.446380536021924845e-01,-8.914677996802505833e-01,-2.844487201591917036e-01,-8.576356829965413060e-04,-3.169221910674929060e-02,2.629754686276675191e-01,2.979830444163078518e-02,-3.810809715738701364e-02,1.056324871258961309e-02,-4.463171992370319752e-03,-3.321896860883529201e-01,8.576206591166201099e-01,2.434842043596030167e-02,6.429339430375619058e-01,1.676480655731929037e-04,-4.330108877858109772e-06,-1.421811666474750713e-01,6.244984087645549971e-05,5.726040251468516966e-03,8.435215869194205790e-04,1.586033478435195038e-04,-7.518128334027013304e-01,-3.412283729800551918e-02,1.189278682906190102e-06,5.078136470722579565e-01,1.325297384131400591e-04,2.571393237554147831e-05,8.145603746860183847e-01,6.191598059375482918e-05,5.087876566913452671e-03,1.015199936582060437e-03,1.570505459776258171e-04,2.790399871335366710e-01,2.695213491217549745e-02,-2.552205674766397567e-07};
    cv::PCA pcaANN0_4;
    pcaANN0_4.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_4_pcaMeanLoad.data());
    pcaANN0_4.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_4_pcaEigenValLoad.data());
    pcaANN0_4.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_4_pcaEigenVecLoad.data());
    
    vector<float> cluster0_5_pcaMeanLoad = {-3.308423237660040093e-16,1.994207682779273217e-17,-2.239397151973445978e-16,4.932394821956111946e-15,-1.024238142647125116e-15,-2.400077984118694172e-15,-1.395945377945491129e-16,-8.271058094150100232e-17,4.249950799365664022e-17,2.939004437407486062e-16,4.694561036837764597e-16};
    vector<float> cluster0_5_pcaEigenValLoad = {7.341566688681914421e+00,2.874018915630935034e+00,6.602945729345638393e-01,8.397627367493308570e-02,2.330473886628432398e-02,1.500025982893484627e-02,1.589425477169821447e-03,2.981847078920380140e-04,2.008453315056151736e-04,3.154234989456650272e-06,3.529791253030685699e-10};
    vector<float> cluster0_5_pcaEigenVecLoad = {2.493713775414557743e-01,2.973696070512208967e-01,2.712145407998435287e-01,2.969809354332334506e-01,-1.294474125307693013e-01,-3.119436852578182373e-01,3.351731704993677341e-01,3.254255191891093912e-01,3.446080366939384687e-01,-3.400496785615866324e-01,-3.477548399721878680e-01,4.174501128145501339e-01,3.303632410282623666e-01,3.617129207848873151e-01,-3.359622609745508415e-01,5.406481823966610145e-01,2.582019018420699252e-01,5.057033576425688098e-02,2.797540131890854931e-02,1.752728526886304095e-01,2.188678153960342543e-01,1.787632505264273586e-01,2.108551387250810066e-02,-1.969746835804422336e-01,-3.422464224325399984e-01,-2.018807464138221708e-01,-2.054116154014321849e-01,3.639908507363927015e-01,4.876416760014402607e-01,5.625417566522170620e-01,1.568888184381879991e-01,1.394232530697378514e-01,1.728701175237574994e-01,6.788549957661018652e-01,-2.694414190215683180e-01,-2.060936245949843149e-01,1.153731908259696126e-01,9.449707230605235153e-02,-2.386077929060753944e-01,-2.761151117660698984e-01,3.302188644065287559e-01,-3.992580315063903873e-01,1.198726244516890201e-02,8.576836843943324087e-03,3.789749646880342659e-01,1.387282069769617543e-01,-3.216606969521975667e-01,-4.637566252228118163e-02,-3.927051919894320453e-01,2.597483657765634057e-01,-4.062755027644410211e-01,-2.559647401079545026e-01,5.215511864084199090e-01,-8.257646370523304136e-02,-2.042862267334030410e-02,-8.130070449713394654e-02,-5.705212151235576901e-01,-1.704627205232549236e-01,3.773594866813864690e-02,5.587773187217642823e-01,-1.023171285709119915e-01,-2.283072412579330301e-02,-4.686035624605154604e-02,5.076417005466735688e-01,-1.629317842388079973e-01,-1.665812519897683364e-01,-3.470906722179236126e-01,6.057996563544389840e-02,2.356025243604757402e-01,-3.707261873283445447e-02,-5.987380318042419269e-03,7.126063707362614852e-02,-6.356498079357163489e-01,6.224672634465124865e-01,1.471232523953606153e-01,-1.388581455164370100e-02,2.251749822943573467e-02,1.595068840605414484e-01,-5.260390762414913768e-01,6.184346343453269723e-01,6.145617128354480263e-02,-3.341142700160134593e-01,4.472383898124877855e-02,3.328567898712189027e-02,-1.078803943480473732e-01,1.129607356045644606e-01,-8.221218811750063971e-02,4.070682147777630600e-01,-7.560512896308237141e-02,2.560222890337413570e-01,-2.533533501420919820e-01,2.822659543103149260e-01,1.540240207036391029e-01,-2.819383772403074029e-01,1.801920620879808241e-02,3.159973467564565486e-02,1.404909750879963504e-01,-2.018728778179645356e-01,7.873043932198031669e-01,1.411878344678061011e-02,5.270342553094648115e-03,3.630744383337351083e-02,8.102251830249481701e-01,1.299203217375268227e-01,4.638740651887927613e-01,-1.141881226293683200e-03,-1.350096565997359506e-03,-2.304793278596272213e-03,3.271035245315613293e-01,-5.409448138372063841e-02,-1.410426940229037029e-02,-1.820819168211204597e-02,5.353526788807073159e-06,1.189149744324252727e-04,-1.452547383226767685e-01,-5.166383565415675339e-01,-1.411116198072353244e-03,-3.589729392965173476e-05,2.874708847312270610e-01,7.929778588225787628e-01,-5.212099856522619268e-06};
    cv::PCA pcaANN0_5;
    pcaANN0_5.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_5_pcaMeanLoad.data());
    pcaANN0_5.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_5_pcaEigenValLoad.data());
    pcaANN0_5.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_5_pcaEigenVecLoad.data());
    
    vector<float> cluster0_6_pcaMeanLoad = {2.473638830912161750e-16,-3.242324829914320723e-17,3.734138146811436826e-17,6.116700437557465851e-16,4.608472932406310377e-17,-1.890748973848913045e-16,3.140319104928252687e-16,2.929021531742825009e-16,1.384363410525215706e-16,7.723290606088045284e-17,3.133032981714961822e-16};
    vector<float> cluster0_6_pcaEigenValLoad = {4.418193149527215979e+00,3.642005861877806172e+00,1.217104694675829935e+00,9.142608682945064791e-01,5.483033407638790990e-01,2.080197241913691042e-01,4.975911131638310891e-02,2.911174311495123845e-03,5.701642351831593628e-04,2.308914145782606589e-10,2.154856515045167269e-12};
    vector<float> cluster0_6_pcaEigenVecLoad = {-3.096559871065603375e-01,2.009303499371753732e-01,3.616180209867114748e-01,2.274727720545849929e-01,3.517940988914921574e-01,4.552869848170214562e-01,1.427664557445106341e-01,1.370629827859292521e-02,-2.713675448782781330e-01,4.163298131999125240e-01,2.874759140611648500e-01,3.883080956340603240e-01,3.586870053523754098e-01,2.716045785845991323e-01,-4.442491665843972815e-01,2.975375318817920500e-01,-5.680759587490270823e-02,3.143731553596016970e-01,1.033337516621309071e-01,4.221736212261362198e-01,-7.741420152497416329e-02,2.528765113838947198e-01,-5.318776837047619471e-02,2.818799094569041652e-01,2.769699213704053808e-01,1.099396602895073433e-01,2.670971397630209632e-01,-1.500338890880766052e-01,-4.933396044274369202e-02,-7.082851826966819475e-01,-6.595366934705827744e-02,-2.698047722326576414e-01,-3.921969153969186994e-01,1.593610666256206621e-01,-1.763631077667288105e-01,-3.615478238734916305e-02,-1.997943183469678974e-01,-5.959466137583327439e-02,8.395721968649610912e-04,-5.058282057693406220e-01,-5.242262346411232787e-01,1.417430459703636902e-01,3.477518292180164505e-01,4.764716083255659540e-01,-8.330680259422094946e-03,5.055193707127560998e-01,4.751599676776498832e-02,2.214662535600071466e-02,1.142127908599566977e-01,-4.815183619633910117e-02,-7.447683141923894246e-01,4.004542396111797631e-01,-1.327183652863972267e-02,-4.998124571022104223e-02,-9.247516043171362388e-02,-5.263904063798270638e-02,6.407087001884285149e-01,-5.208268297158594740e-01,-5.552627443507435721e-03,-3.884135583595202390e-01,2.583553367041440119e-01,1.905873177744832336e-01,-2.251692942533804476e-01,-1.028589959205896028e-03,2.437734161418680587e-02,1.009824381099821700e-01,1.591085770971775379e-02,2.238189296385116600e-01,6.154575507910257925e-02,1.541668612159699525e-01,-1.213720840915376159e-01,-7.748723742478214049e-01,1.753896239067226082e-01,3.894767040791331097e-02,-1.926751596971311709e-01,4.827410012228438574e-01,6.706130387562531103e-02,1.843472909313544073e-02,5.927530073721087867e-02,6.574248290615974932e-01,-5.569622403165998964e-02,-7.278463678276314575e-01,1.458620064404517469e-01,-2.685668348463112962e-02,8.412390902262293149e-03,4.957790356078069921e-02,-2.882835692824571409e-03,-8.088717533336617360e-02,-1.517528374124073043e-01,2.697720139413325308e-02,8.904646542990179992e-02,2.600766435732849713e-01,-6.638242445487924082e-02,-2.142077814042965545e-01,-1.394706498577669498e-03,-3.613503859658700242e-04,-1.597847897923964922e-01,-6.181188618089233922e-01,6.654159536413175591e-01,-4.136593321794228562e-01,-2.020453251065511008e-03,-9.689188929989668011e-04,-7.770765275038131747e-01,-2.121494572852418957e-03,-9.552824228811034046e-02,-1.199187318870745776e-03,-4.643998712082469797e-04,-4.587768809536389436e-01,-7.365445321387638355e-02,4.196664674919916275e-05,-7.263118297462277662e-01,-3.549464398540952848e-03,3.334281270342520242e-06,3.966374929969214425e-03,-2.761247340189665594e-03,-1.455890326710247706e-01,-1.300960713406699044e-03,-6.191541592073706093e-04,6.692696173230597845e-01,5.757697184469219576e-02,1.341227393300671622e-06};
    cv::PCA pcaANN0_6;
    pcaANN0_6.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_6_pcaMeanLoad.data());
    pcaANN0_6.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_6_pcaEigenValLoad.data());
    pcaANN0_6.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_6_pcaEigenVecLoad.data());
    
    vector<float> cluster0_7_pcaMeanLoad = {-3.433102912436361956e-17,4.638341168929977962e-17,-8.692324395317596835e-17,1.362284453551875372e-16,1.051844296576246976e-16,1.957599107516904118e-16,-7.282560858934154840e-16,2.030643850334699034e-16,1.093845023696479139e-16,3.316231323927890015e-16,7.669697995868467505e-17};
    vector<float> cluster0_7_pcaEigenValLoad = {5.199644966000552593e+00,2.967314793510543947e+00,1.490737590638555377e+00,7.326409573211104531e-01,4.028195989972682689e-01,1.643971394447976409e-01,3.883461194979991732e-02,3.081577955539563114e-03,1.094200395247509235e-03,1.938877667581937802e-10,6.801752275979793288e-12};
    vector<float> cluster0_7_pcaEigenVecLoad = {-3.274226690728583300e-01,1.838091620042778540e-01,4.035332658508904435e-01,2.289296655105987066e-01,3.929067271183019905e-01,4.203286168377817211e-01,1.096011998552328254e-01,1.547638096034925984e-02,-2.744975535823902524e-01,3.989451311136892331e-01,2.568088609344691964e-01,3.802794883480600796e-01,4.189402125199724880e-01,1.482095795790703552e-01,-4.897632813814843389e-01,2.140479554195222345e-01,9.011887274366922607e-02,-2.774633674210707709e-02,-1.109815189625180942e-01,4.476833723379442520e-01,1.478903982561458920e-02,3.877868551696340704e-01,3.165192193088226663e-02,1.075878678368172303e-01,-4.438762361746836221e-02,-6.215479561409387871e-02,2.384690720571666298e-02,9.506435825293216291e-02,6.959873663573535874e-01,6.661196229033152783e-01,7.852598521189342595e-02,-1.732548371907761120e-01,-8.767145762134730125e-02,-6.629016849896349206e-02,3.724238209728792381e-01,1.372080659267702896e-01,8.215800264947099862e-02,1.822379771821019401e-01,-1.308718464770107981e-03,3.414823749232221428e-01,-5.601470215540894637e-01,-2.734011572014935498e-02,-3.742956009292817132e-01,-4.763382730418105893e-01,-1.276583147991314504e-01,6.457567547110656392e-01,-1.805289015615910153e-01,1.026778089864547466e-01,-4.634318487163544692e-02,1.413831860998953083e-01,-5.310914339162463582e-01,3.738360778075549007e-01,-7.482390518228421161e-02,-1.606829735719041974e-01,-2.195497586475419483e-01,1.112939430488718295e-01,-2.558706271504985752e-01,5.851453173124490093e-01,-3.865591460741343161e-02,4.462344212947326194e-01,-2.938817256970751579e-01,-2.837171649921798045e-01,2.976246706455866198e-01,6.351295810343762782e-02,-1.973239417826163078e-01,-2.841063580997704174e-01,6.686463177589771489e-02,3.918517877638987845e-01,1.467454171087516912e-01,1.124523362013402222e-01,-1.584444689465297207e-01,-7.410090369822235346e-01,1.530684976526758834e-01,3.925938720889877304e-02,-1.484570346514369199e-01,4.306342359563267719e-01,3.385127297793583123e-02,-1.212905248122017263e-02,-2.889634807951599674e-02,-6.131723558090508286e-01,8.173663749842986770e-02,7.286889934539259039e-01,-2.575825017252424964e-01,1.453735440066256102e-02,-8.028038678138262052e-03,-6.991170146727171408e-02,2.870385223460990200e-03,1.176801077000968754e-01,1.404503250694895122e-01,-5.716358355791862494e-02,-1.479274472866459189e-01,-2.560595409955870871e-01,9.236631916255978736e-02,2.077342995246834467e-01,-3.445781739964479205e-03,4.883698969474429240e-03,1.482509904065285877e-01,6.408469126606535227e-01,-6.365320817066455472e-01,-4.262809118109314177e-01,-8.993518113305641604e-03,-3.960978060661497074e-03,-7.744396138562839038e-01,-7.097347738595567029e-03,-1.150079962110382159e-01,-1.067506650708374954e-03,-1.839205597066361690e-04,-4.465008197782061039e-01,-7.609156812720062335e-02,4.757343157741462746e-05,-7.127713422533071830e-01,-1.502309257787248428e-02,9.130407730259056294e-05,2.057567443954519404e-02,-9.020174150598980062e-03,-1.672851075328929127e-01,-1.112544900987144300e-03,-2.354347189653120047e-04,6.778022506128682512e-01,6.184738219518119695e-02,9.317238703336520072e-06};
    cv::PCA pcaANN0_7;
    pcaANN0_7.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_7_pcaMeanLoad.data());
    pcaANN0_7.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_7_pcaEigenValLoad.data());
    pcaANN0_7.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_7_pcaEigenVecLoad.data());
    
    vector<float> cluster0_8_pcaMeanLoad = {5.170269387027756317e-16,-4.944798992706245010e-17,2.674545367124132494e-17,5.442388828450269645e-18,-1.178665923418658329e-16,3.486238786681572831e-16,-1.072928083323053101e-17,6.841860241480338741e-18,9.014150868150346982e-16,9.438657196769467405e-17,-7.572695312729374743e-16};
    vector<float> cluster0_8_pcaEigenValLoad = {5.187897515240114110e+00,4.748553165606925752e+00,8.146026350650882319e-01,1.952401298007707120e-01,2.386928520032543383e-02,1.958623495488433230e-02,9.674805557428061906e-03,5.818019767293775620e-04,2.347816091168770415e-04,3.759594825374104427e-07,8.538762448244535328e-10};
    vector<float> cluster0_8_pcaEigenVecLoad = {2.725099099158751481e-01,7.842899231765839557e-03,3.209264801775323361e-01,3.424126153022017394e-01,1.921685158376720270e-01,-3.460322888448207346e-01,3.445371986063994196e-01,3.085288457439731014e-01,2.152932311422137701e-01,-3.735796562711280466e-01,-3.859542523339338782e-01,-3.579723814154798789e-01,2.736142804565976361e-01,2.882391352597153955e-01,2.783802435398840536e-01,3.974832645786965379e-01,2.790308492468326906e-01,2.732591581338908449e-01,2.748865290002365236e-01,-3.913577042105934045e-01,2.332256260040634355e-01,2.068193983503305022e-01,3.769207142035210789e-02,-8.733526229518653317e-01,-5.227023016522019949e-02,1.497609904415828086e-01,-1.145387088516632568e-01,3.408149677296890695e-02,1.465460178368930000e-01,3.110783476114535318e-01,-1.870353803802377590e-01,1.203369650435069382e-01,1.693653326436476148e-01,-4.376018214276824331e-02,3.390020326408402784e-01,-5.701570096875674398e-01,1.164146309618778324e-01,-4.518144364309798489e-01,-1.703628949313496302e-02,1.634468794796344882e-01,5.565351493685312123e-01,-4.765740092740140821e-02,-3.301123312188702398e-03,-3.709967690763531917e-02,-4.382995342266420846e-01,-1.016942547751977510e-01,2.036699494668751387e-01,6.521090215453484440e-02,-3.083605906603507085e-01,5.704378021284070011e-01,3.311988675994327613e-02,-2.062029082276216601e-03,3.121542560765370733e-01,-4.743751501738466270e-01,-8.808578344549093664e-02,2.157865270286551951e-02,-6.481599133431568960e-03,1.612284394979549007e-01,-3.540163279965442555e-01,2.527139142778065395e-01,5.450516388354403885e-02,-5.788927231033965670e-01,6.398630391660662386e-01,1.875179649497702161e-01,-2.272514155605706576e-02,3.337861709194284848e-02,1.151377661119513812e-01,1.371842205399383674e-01,6.417866698699679073e-01,-2.377481291780657313e-02,-6.539962089268601675e-01,-1.705495328875952510e-01,-8.481718358566399385e-02,7.022357143503916987e-02,-1.656340299788532089e-01,2.235581290894461670e-01,9.556178657367142559e-02,-5.970508736219356377e-02,-6.548041181757058293e-03,-8.179040471044574101e-02,6.968318633534382744e-01,-2.544779525945213908e-02,-6.369764653111836816e-02,-6.438917532157391044e-01,-9.110412480047423711e-02,-2.261809713654795162e-01,-1.159224842139295608e-01,-1.092278516963536422e-01,-1.352276259680252335e-01,-9.789264357139433603e-02,6.602777597844893161e-03,-1.776808648352033726e-01,-2.169245486326842193e-02,1.577962494583295128e-01,-2.052218112383271537e-02,9.268374624401734541e-03,-2.472542936024361426e-01,3.246252411616543099e-01,-8.649409913847256881e-01,-2.123453695152293097e-01,-2.492241481129382416e-02,-3.703087125236964768e-03,-3.488865470230615440e-01,-3.698614307418507125e-03,-2.797364469061088266e-01,-2.632103133996023265e-03,2.459512300295422387e-04,-6.292507991977421833e-01,-5.984797038583197226e-01,1.204614385509929914e-02,-7.221411828547095180e-01,-8.919818436960404162e-02,1.873437109705339905e-04,1.628183479892293672e-02,-5.428153063869058277e-03,-5.799007572540458844e-01,-7.677110410201476963e-04,-3.204774586690513089e-05,3.081355645587162129e-01,1.975555301813754217e-01,7.429883486164216551e-05};
    cv::PCA pcaANN0_8;
    pcaANN0_8.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_8_pcaMeanLoad.data());
    pcaANN0_8.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_8_pcaEigenValLoad.data());
    pcaANN0_8.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_8_pcaEigenVecLoad.data());
    
    vector<float> cluster0_9_pcaMeanLoad = {-2.522391101721037081e-16,-2.967518943201220349e-17,-6.647242432770733829e-17,2.587676518471463972e-16,3.086219700929268793e-17,9.258659102787806997e-17,-1.305708335008536830e-16,2.023847919263232136e-16,-1.187007577280488140e-16,1.709290911283902773e-16,-1.495629547373415081e-16};
    vector<float> cluster0_9_pcaEigenValLoad = {4.402702309079725929e+00,3.729670592646992855e+00,1.373497027981868346e+00,7.657474378756423672e-01,5.219815082609142731e-01,1.405518654356828212e-01,6.674457886944057394e-02,1.947046521093347745e-03,8.341035817695301125e-04,3.308069536568244826e-10,4.294521311893438425e-12};
    vector<float> cluster0_9_pcaEigenVecLoad = {4.413119705314887398e-01,2.657806703581768737e-01,1.901021821251684119e-01,-4.482864663504185776e-01,2.004358891607011528e-01,-2.474444811641988429e-01,2.854494370864689157e-01,-6.423235139750414768e-02,4.500885919626886889e-01,-3.236732027471370121e-01,5.612671872679628193e-02,-1.601602815231573662e-01,3.735687936168620715e-01,4.422744260211640688e-01,8.176786694521512300e-02,4.421655844182801331e-01,3.902806629772160307e-01,2.202609072703215487e-01,-8.303694552639587223e-02,-1.153232395772142427e-01,3.192618781544691031e-01,3.376912653887403915e-01,1.516421707119890161e-01,-6.715148947099600085e-02,-1.694228612867575701e-01,-2.338644801498582226e-01,-1.529300557153840112e-01,2.164412062271735548e-01,-1.780927367317048371e-01,6.521178165905996416e-01,1.920101208962967099e-01,1.896033365804692949e-01,5.376543959333965894e-01,1.396320726177951443e-01,-6.596662241940681563e-03,-1.263999732599349890e-01,-1.293775204999887407e-01,-1.191075601671666151e-01,-1.859480913893496179e-01,-3.830298225266397516e-01,-6.636428748811804557e-01,8.517243868813317853e-02,3.453073784370933041e-01,4.305291261599389907e-01,9.250152721510843459e-03,3.845212068967904795e-01,2.290073148258249258e-01,4.710150017410268813e-02,2.589091038177451787e-01,-2.454966836058752877e-01,-7.533185833140512155e-01,2.412792938649519492e-01,-3.446930042026179891e-02,-4.953830740556894319e-02,-2.018555589310264964e-01,-6.603146200946273525e-02,7.664836581281754269e-01,-4.756401873385415757e-01,2.869721995715175666e-02,-3.250588337600068267e-01,2.240141660630949050e-01,6.189054845879485289e-02,-7.204411490794945805e-02,-1.665165275558472269e-02,-1.154386382933132310e-01,-5.114475895303238762e-02,-9.572597006138215334e-04,-2.066492840425442901e-01,3.758974544274186480e-02,-1.403916617038472037e-01,8.561913721102865082e-02,7.057281944677640251e-01,-3.459002840805561751e-01,-2.446176181219667234e-01,1.701831466484881317e-01,-4.691093514795733888e-01,-4.773631348585451878e-02,8.568656569751906260e-02,7.142021692855440862e-02,5.852221960835559678e-01,-1.441520152829026125e-01,-6.670199937186335193e-01,1.575084476389485011e-01,-2.430182144040607395e-02,-6.474896003735551749e-03,1.025648836535272418e-01,2.601242367956360657e-01,-2.752287829149956955e-01,-1.685455131931249129e-01,4.570981483746623664e-02,3.178006170614965376e-01,2.680584792555589235e-01,-3.190496334705645864e-01,-2.151804418552252796e-01,-3.435336380413834753e-03,-3.155988461594379235e-03,-1.823151632748833684e-01,-5.729736816975613545e-01,5.357198247709208383e-01,-4.135371776163529467e-01,-1.234650842299814212e-03,-5.052307621082239263e-04,-7.781585222456030015e-01,-1.342433655907375586e-03,-8.743977841395957074e-02,-1.679035853129957684e-03,-1.171855741378647568e-03,-4.602951555279493068e-01,-6.269926040850022642e-02,2.284875107101431714e-05,7.251831180951272549e-01,2.170474874938804494e-03,1.707812025293862495e-06,2.093837033484398716e-03,1.699586479615329982e-03,1.332975738494437956e-01,1.830319508086988888e-03,1.571493662902469224e-03,-6.737513347106058870e-01,-4.881124497074879054e-02,-1.451118611681970608e-06};
    cv::PCA pcaANN0_9;
    pcaANN0_9.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_9_pcaMeanLoad.data());
    pcaANN0_9.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_9_pcaEigenValLoad.data());
    pcaANN0_9.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_9_pcaEigenVecLoad.data());
    
    vector<float> cluster0_10_pcaMeanLoad = {-5.235368235350515165e-17,-1.466408441289526796e-17,-3.761941246958453831e-18,3.004331198522477557e-15,-5.221799044285615150e-17,-2.099949293078301013e-17,3.784400597686564015e-17,5.083299714795602480e-17,-1.001967784357815103e-16,-1.880596300967091805e-16,-2.996826032154167176e-16};
    vector<float> cluster0_10_pcaEigenValLoad = {6.139039304862964563e+00,3.521979489180557810e+00,8.955881063268051889e-01,2.173895388818236629e-01,1.989295112733848736e-01,2.261162606098974376e-02,3.681817716880994226e-03,6.486598866809616159e-04,1.898954179085172100e-04,2.420770012757020123e-11,4.284326542218480352e-12};
    vector<float> cluster0_10_pcaEigenVecLoad = {1.560820390440334493e-01,2.677770429110244432e-01,3.366741479043424135e-01,-2.043670329772576399e-01,3.326946571419071574e-01,3.364014307964057759e-01,3.633183335158219340e-01,3.443512269331870379e-01,1.705908759768123006e-01,3.726687375801122637e-01,3.261987353053414918e-01,-4.863289428153927396e-01,1.644081937935608084e-01,2.303317876178714307e-01,4.577492120671235454e-01,2.371250176944749988e-01,2.064240499675941976e-01,1.205388084027266271e-01,1.857636360288097144e-01,-4.784850207494816265e-01,-7.502216330898685281e-02,-3.023473108292345501e-01,1.314852789387430110e-01,6.404294166160127144e-01,2.814257577882711692e-01,-7.471239788957513561e-02,2.523169818085962413e-01,-3.909561447365610398e-01,4.512002455129916767e-02,-3.592756157262745331e-01,1.200588369238999031e-01,-3.243671571364536987e-01,-1.432684758437068329e-01,-6.590723597278390355e-02,1.971014498328599873e-01,2.483580869561080595e-02,2.538940150927402814e-02,2.261000543736421953e-01,2.499745949748690688e-01,-7.761526236082775254e-01,-2.817148253457912865e-01,-7.074705132462660861e-02,3.605982905685402584e-01,1.585082726905109873e-01,-6.048526856687667236e-02,6.677344608937351156e-01,-4.717545691748486480e-01,4.004798901930884530e-02,-5.119293601229433222e-01,1.408104115127799538e-01,6.682007422000138530e-02,1.513847202693558713e-01,-5.651988932115162290e-02,1.114329538409312287e-01,3.771880661998524426e-02,1.085685438357526372e-01,7.908474890853446626e-02,-6.310561273878888267e-02,-7.726943751310277886e-02,1.720582099719987490e-01,-1.601305589095353421e-01,-4.543929318445129595e-01,7.606208296007388459e-01,1.216414330059402277e-01,-3.282340046856938032e-01,-9.596136171795674463e-02,1.465227571166158316e-02,8.345807416794767328e-03,7.119862885501000438e-01,-2.615486577300487128e-02,-6.449142427364894514e-01,1.451895564164154273e-01,-1.945532006101903244e-01,6.005585374365383922e-02,3.951909295801726840e-02,-1.099632065348520177e-01,1.183011034057081896e-03,1.822839902336222950e-01,-6.326209301676403648e-03,-1.379837625258304237e-02,-2.139545533492673568e-01,3.990665183779956542e-03,2.177953764286965910e-01,-1.172872859875763191e-03,-1.206621770744754039e-02,1.898392039401983200e-01,3.039438648796423115e-01,-8.629872901154630460e-01,-3.898923992286172646e-02,5.762005023227009456e-03,1.418835487991431388e-01,9.430793337847508118e-02,-1.034159221773448267e-01,-7.121040388555204270e-01,-1.518469510467043010e-02,1.823680352201421107e-01,-1.677016273920366729e-01,6.235961660138567009e-01,-3.391174285791491438e-02,3.828881761637104031e-01,1.901517968644354146e-06,8.728270860935953980e-05,8.243235545827839461e-01,1.133064956160754989e-04,4.585231983265643935e-02,5.494349059373224587e-04,1.818452733236204145e-04,4.098342449255767406e-01,6.180957011051632644e-02,-1.537109813389227932e-06,-7.214424156907937036e-01,-1.995158754549266627e-06,-4.727581063710865284e-07,-5.904772468563795375e-03,-1.677201971518653086e-04,-7.556709039925843530e-02,-6.428678272853165145e-04,-2.840667390950956457e-04,6.861864222206973674e-01,5.406719158227626942e-02,-2.380498029920338049e-07};
    cv::PCA pcaANN0_10;
    pcaANN0_10.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_10_pcaMeanLoad.data());
    pcaANN0_10.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_10_pcaEigenValLoad.data());
    pcaANN0_10.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_10_pcaEigenVecLoad.data());
    
    vector<float> cluster0_11_pcaMeanLoad = {7.318342375245708754e-16,1.715058181946644188e-16,7.890571863708894928e-17,3.260566885830121819e-19,-4.434370964728965867e-17,-3.955067632511938153e-16,2.673664846380700171e-17,4.173525613862555929e-17,-2.260551021946023449e-15,-2.804087521813905140e-17,4.773469920855298232e-16};
    vector<float> cluster0_11_pcaEigenValLoad = {5.509194127380848016e+00,4.095094118150444551e+00,1.091892701200585236e+00,1.784525510189869102e-01,8.315692464810622853e-02,2.607902208075846273e-02,1.550831086725472548e-02,1.284520007132664400e-03,3.466590850140451496e-04,7.028057536538043809e-07,2.034804337053091356e-10};
    vector<float> cluster0_11_pcaEigenVecLoad = {3.212843030684387480e-01,1.231058926733257647e-01,2.125766224152826067e-01,2.553895740977598638e-01,-1.699531274337666709e-01,-3.916691222885213541e-01,2.626303798878766305e-01,2.351807028809629330e-01,3.332346029571150448e-01,-4.197083517377487305e-01,-4.212301430130435120e-01,-2.946118456124028895e-01,-1.851614418652764230e-02,3.989785099705721594e-01,3.870219130116820949e-01,4.317950138637555169e-01,1.699707584996839049e-01,3.786718054307952608e-01,3.908864609277091784e-01,-2.965654285032931492e-01,5.150551786425334316e-02,4.202111610350488941e-02,-2.331470670706373149e-01,9.053772001683531023e-01,1.753257289515287864e-01,-1.328984782651692342e-01,1.333314411555772405e-01,5.475577006764665439e-02,-1.452266752333369326e-01,-1.383428137948385372e-01,7.835267081959840230e-02,-1.508281836682567011e-02,-1.008059147833753194e-01,-3.048118009941184689e-02,3.294284480752421862e-01,-5.493333596341821723e-01,1.608885694858542270e-01,-4.012903372186369944e-01,-1.242955039923201166e-01,1.765981096683827412e-01,4.707764261471795719e-01,-2.759669230676555784e-01,2.090883667518317335e-01,1.171289584595308214e-01,4.395080107095897248e-01,9.420003541843149919e-02,-3.085819698416226650e-02,-4.135297962351658363e-02,4.968110175920988913e-01,-6.014187532482164755e-01,-2.488995045938070805e-02,-9.911049858223905384e-02,-2.531646001336491647e-01,3.233797423980022123e-01,8.753220851522972024e-02,1.023300247783467537e-01,3.918167442228732977e-03,6.698560010046084034e-01,-3.701628600543437064e-02,-5.573768102735205954e-01,-1.367876429353742096e-01,-1.928742740132100564e-01,4.500515797264032641e-02,-2.530564289134177303e-01,2.731565702068179391e-01,1.793827213220581529e-01,8.325577218619424624e-02,-5.752312582456488993e-02,6.056465383293928306e-02,-4.267979021886030289e-01,2.075055677552955780e-01,5.287952686228099275e-02,-4.094655066178962133e-01,7.343077826351154247e-01,2.254514115246807893e-01,-8.914432215917563471e-04,1.952384178616356492e-02,-9.280483448869045193e-02,-4.838251211083992309e-02,-9.670140272965857542e-02,5.874409277217571557e-01,4.942117171119339569e-02,-5.589584351289957759e-02,-7.241474127764985225e-01,8.250015155554143650e-03,-1.950468217862971754e-01,-1.175091500404026185e-01,-2.296353448762737393e-01,-5.984853602885412821e-02,-1.035789313359173347e-01,-1.674180496616405403e-02,-2.568974762619846697e-01,-4.131073680763567429e-02,1.029013562360848594e-01,7.404643420548570609e-02,-2.044305044676911209e-03,-2.570380251895789669e-01,3.628473653919132014e-01,-8.389897971474501448e-01,-2.743998048591302363e-01,-6.519542610401160565e-02,-1.273691069634311050e-02,-3.809388392455843042e-01,-1.965160259268890902e-02,-3.020942929487853701e-01,-3.953714672615691109e-04,-3.274415697001820330e-04,-5.468646562046638460e-01,-6.200068156894572580e-01,7.801333734407504134e-03,6.757466339357023344e-01,1.635643598536077881e-01,-1.761545088343276265e-04,-2.964319554352925958e-03,2.781944244272083894e-02,5.577383406071987348e-01,8.748177356850397532e-04,1.007383549054607024e-04,-3.695616202134978656e-01,-2.611164833216442216e-01,-7.922717879218154572e-05};
    cv::PCA pcaANN0_11;
    pcaANN0_11.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_11_pcaMeanLoad.data());
    pcaANN0_11.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_11_pcaEigenValLoad.data());
    pcaANN0_11.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_11_pcaEigenVecLoad.data());
    
    vector<float> cluster0_12_pcaMeanLoad = {1.483951033484165937e-17,1.214141754668863135e-16,-4.316948461044846318e-16,1.983098199292476273e-16,2.563188148745377640e-17,3.959451166614570257e-16,1.773996008210616467e-16,3.102806706375983183e-17,-1.349046394076514436e-18,-3.372615985191286417e-17,-4.327066309000420243e-16};
    vector<float> cluster0_12_pcaEigenValLoad = {6.812038458544678932e+00,2.688263391380850020e+00,8.397824174130692487e-01,4.043935224103705761e-01,1.904737466393713885e-01,4.249788322058983131e-02,1.903998834662640194e-02,4.274837363419402292e-03,2.800214719366998783e-04,7.003765338098227093e-08,1.755415970592168647e-11};
    vector<float> cluster0_12_pcaEigenVecLoad = {3.460053029370367961e-01,3.362786149309235917e-01,1.291204945029375550e-02,-3.121377139550217117e-01,-1.002956303135115468e-01,2.836107311737086079e-01,3.483771397952129534e-01,3.295023076673549989e-01,3.742633348374894697e-01,-3.411331386427496337e-01,-3.045042287304199347e-01,8.998640437856510188e-02,2.235891920329242388e-01,4.405302916966394866e-01,-3.252127034208548984e-01,5.607161626624882489e-01,3.218212458118307473e-01,-1.510367422902580692e-01,-1.711633249290880066e-01,1.080394037016760428e-01,2.446316798642914070e-01,3.169895860588444192e-01,3.709732254879984925e-01,2.002879536974423447e-01,-7.296213632628244516e-01,-2.417596186814028603e-01,-4.046281589044223304e-02,-7.491095798379528159e-02,-2.745004319408313465e-01,-8.811125078954511192e-02,1.021162434995383922e-01,1.878002124799267036e-01,3.088833709979290076e-01,-2.072550915820819961e-01,7.656527776000640606e-02,-1.642631134930478201e-02,-3.744671057326381947e-02,-4.211747192650199256e-01,5.043096006421747823e-01,-2.536800195984362793e-01,-6.242348755925855031e-01,1.067985818283818389e-01,-1.927604411807564144e-01,-1.233265217031088157e-01,3.108551749411701537e-01,4.373546159312867165e-01,3.711033198188789517e-01,3.967939677233682516e-02,-1.636686157828808330e-01,-5.863704467757174799e-01,-3.053540879651029938e-01,-2.392655881015872399e-01,5.183955264015029096e-03,-5.578273619355511581e-02,-2.203461532380938115e-01,-5.104407355757020204e-01,7.209626843524904460e-01,-2.560129321013689951e-01,2.222784688800287234e-01,2.459407842754920692e-01,1.703204583168583738e-02,8.727421618661714009e-02,6.051185349155908944e-02,-1.531020062898107159e-01,-1.384552341110800375e-02,-9.500193723117129896e-02,-1.384062705777108493e-01,1.831134042661449746e-01,2.304911817445650657e-01,-2.636335940092509808e-02,-5.127777069148705680e-01,1.833067911802686023e-01,-3.708237593674123533e-01,5.737366997335486829e-01,-8.075555047086079019e-02,2.133506120686120000e-01,2.796884225809427860e-01,-3.636541248355333600e-02,-1.900385188468576569e-01,-1.204565022552789577e-01,2.586494915870008598e-02,3.694949015179007090e-01,9.730999152271313513e-02,-6.856500902763589256e-01,2.715073322854375526e-01,8.280028797714916733e-02,-2.305624812162302417e-01,-4.444560874670789863e-01,-3.381635031932920393e-02,1.386845885795251997e-02,4.497501474795146531e-02,2.118160510947773578e-01,7.846426486086763297e-02,-1.089674432725565995e-01,-8.724528113204588209e-02,2.997679282015108110e-02,1.785028735659457688e-01,-7.283819584112783962e-01,6.023544503824688201e-01,4.057941970489407635e-01,7.267544134543163503e-02,1.517176534278178932e-02,7.998401522999508684e-01,4.701434554346282241e-02,2.984370229659322749e-01,3.642828215547690238e-03,3.815077984502262425e-04,2.160801984862605607e-01,2.282431217621650743e-01,-9.498699754903463729e-04,-3.848831915791948166e-01,-6.900432227755036452e-02,-6.790405017109790840e-06,-5.219200636090934060e-04,-3.747071103350190641e-02,-2.606274122786502723e-01,-2.829758774307711625e-03,-2.849471063738473063e-04,8.432214458757796294e-01,2.583444636016508644e-01,1.719609772974543485e-05};
    cv::PCA pcaANN0_12;
    pcaANN0_12.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_12_pcaMeanLoad.data());
    pcaANN0_12.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_12_pcaEigenValLoad.data());
    pcaANN0_12.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_12_pcaEigenVecLoad.data());
    
    vector<float> cluster0_13_pcaMeanLoad = {5.632662210301287174e-18,-7.780114677978652760e-17,-3.562658848015563893e-16,-2.354804845294082060e-15,3.641868160347926203e-16,6.301540847774564944e-17,-9.575525757512188581e-17,-1.045562922787176446e-16,-1.450410519152581546e-16,-1.580665832765798662e-16,-7.516083636870779874e-16};
    vector<float> cluster0_13_pcaEigenValLoad = {5.111626051671445126e+00,4.730366685939897842e+00,6.838402845164680555e-01,3.033079427599973954e-01,1.089543756504505745e-01,4.156728323692594762e-02,1.233227258201212082e-02,8.014153319417051391e-03,2.633332548451504970e-04,1.235232350299668536e-07,1.102447648642588890e-10};
    vector<float> cluster0_13_pcaEigenVecLoad = {2.066678439833392195e-02,2.593224710842643166e-01,3.672693143692868367e-01,-4.306723052534608964e-01,4.150443799190500771e-01,3.988927219891029718e-01,9.631357661232605241e-03,-1.782481475764637613e-01,1.097851398400682132e-01,3.304131175956311339e-01,3.570593016456744540e-01,4.309134935337023964e-01,3.388864490463944223e-01,1.948647662514315093e-01,-2.433370893557117165e-02,1.594242961448062712e-02,5.633648517530091826e-02,4.530846357563949045e-01,3.839812052665703135e-01,3.943682851505638798e-01,-2.871790784423160492e-01,-2.583635965428416892e-01,-1.783775429680828917e-01,-2.125009131334761880e-01,-2.478896958630636693e-01,-2.222186960782776555e-01,-3.916042212260111843e-01,4.920993224484869755e-01,-1.963807072343534688e-02,-2.817362057367732153e-01,5.408176460960349985e-01,-2.010685672596626838e-01,-6.328914702067629794e-02,4.875163685475971675e-01,-3.305443894513255820e-01,-4.934296409555109508e-01,-2.240756014876488511e-01,-1.586832213749164028e-02,1.173572068126906703e-01,8.157356850678990079e-03,4.170885459135101891e-01,-4.992406702311819044e-02,2.754779268130650993e-01,3.048788208028798130e-01,4.254508389378400257e-01,6.266582984024062775e-01,-3.227969424583845282e-01,1.673489699363100297e-02,-2.522467492179365500e-01,-9.814826588927821893e-02,-2.518269145116919239e-01,-4.215787229825214144e-01,-5.581492643003177490e-02,3.956142100445877302e-02,5.220830083613051120e-02,-2.724948109913808425e-01,3.244695151214105344e-01,-1.006528953544475885e-01,-3.368913042092845644e-02,9.327701223605007474e-02,1.323452478625799789e-01,-6.628756739219866523e-01,5.541877417791299942e-01,1.480415625703977445e-01,-8.396738151476047796e-02,-8.654042767339584219e-02,4.015799040585799062e-01,-3.463245910888789192e-01,1.911797458532488517e-02,4.715402460452870759e-02,5.490406430469714216e-01,-9.448365986448509224e-02,-3.972369709449986575e-01,-2.755225441014707566e-01,2.346632150688000851e-01,-2.310213869891520333e-01,-2.523558606995902620e-01,-3.222961705573564872e-01,2.125166292960306291e-01,-6.382013691431207558e-01,2.156391096376382432e-02,5.386866299688315429e-01,1.344009892931553526e-03,3.653512723806778828e-01,-8.077271231116264771e-02,2.713235498684789249e-02,-3.838065292080927032e-02,-1.039026309806369841e-01,4.245092798389240446e-02,-1.565878786939831416e-02,-8.532812699500507076e-04,-2.726427668595071685e-01,-6.576367006444862329e-02,1.743509803183451723e-01,-4.318059464405160988e-03,-1.254361294980681565e-02,-2.410073607764716686e-01,4.544724587841281749e-01,-7.899930622623322352e-01,9.070882311342448601e-02,8.236708485444641653e-03,1.492573591181684499e-02,7.974336152039531722e-01,5.080524574662215187e-02,4.604129024396231840e-01,5.264032993374336000e-03,5.879833954579695779e-04,1.180366580205381571e-01,3.564294151568528912e-01,-4.131303807808887722e-03,1.181627544066044394e-01,9.665859454984692886e-03,-9.714624992971192038e-06,-4.944410073371814044e-04,5.490320649177825307e-02,5.507456032447060057e-01,4.824992427956014546e-03,7.893098312669881607e-04,-6.201555771751026125e-01,-5.431316276805981946e-01,6.245260098333709003e-06};
    cv::PCA pcaANN0_13;
    pcaANN0_13.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster0_13_pcaMeanLoad.data());
    pcaANN0_13.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster0_13_pcaEigenValLoad.data());
    pcaANN0_13.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster0_13_pcaEigenVecLoad.data());
    
    // Child of parentCluster1 : Not necessary
    // GrandChild of parentCluster1 - childCluster0 - grandChild
    vector<float> cluster1_0_0_pcaMeanLoad = {-1.613598302934085840e-15,-1.983619663181382046e-16,9.423264179956737334e-15,-2.518273424623894363e-15,6.332993546789951958e-15,1.244587491165670684e-14,-1.599209698764585113e-15,-3.650823882114397808e-15,-9.309092278965257809e-16,-3.427291897060682196e-14,1.499245707843733951e-14};
    vector<float> cluster1_0_0_pcaEigenValLoad = {6.469922224120733922e+00,4.248250994998482355e+00,2.547806103321559323e-01,2.369878856799673139e-02,2.051700200212929620e-03,8.819661192379986848e-04,3.928055897994220608e-04,2.151025389696110219e-04,1.236388338309353433e-05,6.534760849301095498e-07,5.017067711542458018e-09};
    vector<float> cluster1_0_0_pcaEigenVecLoad = {3.855826458490477782e-01,3.617616923532742113e-01,1.930486338609646302e-01,-3.840311243359321725e-01,3.856485512794021742e-01,3.807011049106334699e-01,-9.432580233847932816e-02,4.365801448857554307e-02,3.827809610647058269e-01,1.947050483948374877e-01,2.163653993766562478e-01,8.732146272104769624e-02,1.895756600706383632e-01,3.839417725097299949e-01,8.665111189829724503e-02,-6.345600438284953538e-04,-9.439515988132572699e-02,-4.633038045478103939e-01,-4.810956012904314405e-01,1.012372171346483801e-01,-4.174482280577277993e-01,-4.024799279209598790e-01,1.344385805836455783e-01,-8.645447148548620134e-03,-7.201140317924876744e-01,-2.139807703224035906e-01,-3.838987405717111390e-01,3.082694233488765256e-01,-3.309940789871733680e-01,-1.066628733872981016e-01,1.571787042391413480e-01,-7.394884251480225712e-02,-1.548664902368594165e-01,-1.846600175206143946e-01,-1.049285520843126762e-01,1.387422425864605069e-01,-3.045237555837135290e-01,-3.140653107636540847e-02,-4.884474618788224587e-02,-3.118394195818574577e-01,-2.083105382335643796e-01,-3.003499905706076833e-01,7.402137357354093838e-01,-2.465172905055447450e-01,-1.344058916714069851e-01,-1.406871091799282714e-01,8.319276436286708598e-03,3.571143871372488982e-02,-6.458297227815582020e-02,-4.612212478290606682e-02,-3.422859084546576725e-01,-3.869080005261251176e-01,-6.878226747146774789e-02,-5.245608177652261866e-02,8.247177582935841800e-01,-5.178346610188455656e-01,-5.308087697845486064e-01,1.781657967408986909e-01,-1.707885490701181175e-01,1.917736829719355607e-01,4.459381953432484114e-01,-1.224561045690820971e-01,1.574617930692443768e-01,2.418597225976976406e-01,-2.128664455780745757e-01,-9.970733026216761774e-02,-8.682649678889674261e-02,2.491319380706475684e-01,3.624451400573734938e-01,-2.629061877611986731e-01,-6.049683965338067404e-01,-2.011093172986764058e-02,-2.191672016171721804e-01,5.250132069792697864e-01,-8.664829652534984661e-02,-1.266681545831704891e-01,1.276370046297604366e-01,3.259555997532295746e-01,-2.660261400210625626e-01,-9.291043622121987478e-02,2.916891169555771435e-01,3.070507010650920243e-01,-2.024558544676881289e-01,-5.876771553139534809e-01,4.924889833040196341e-01,-6.460488447057395611e-02,4.325233833486529650e-02,-6.726830638751222537e-03,-5.931697114090365153e-01,5.654525073531556645e-01,-3.111060127612145232e-01,-4.335074128587130399e-02,3.653436361330590909e-01,-1.857971642713075744e-01,-1.896739252351953009e-01,1.373233896504846285e-01,-3.055001558204642823e-02,-7.734052906829554097e-02,1.259597832005824800e-03,-1.583159185352875364e-01,2.367620079686598433e-01,9.438891590174972035e-02,7.210849056285826286e-01,-1.958011528319854033e-01,4.565812541019646509e-01,-9.011602457256846777e-02,1.835086389629173725e-02,1.643703932308859805e-01,3.282145012332152723e-01,-1.594622739628445912e-03,-1.208723348408821119e-01,-1.091996943920283125e-01,-5.295368022800854985e-05,4.741393702635139087e-04,-1.728615500666414173e-01,-5.131982083137511808e-01,-6.214182591487407616e-04,-2.035910867546811260e-05,7.908569567668103373e-01,2.340009584568345513e-01,-9.713749501163381381e-06};
    cv::PCA pcaANN1_0_0;
    pcaANN1_0_0.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_0_pcaMeanLoad.data());
    pcaANN1_0_0.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_0_pcaEigenValLoad.data());
    pcaANN1_0_0.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_0_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_1_pcaMeanLoad = {8.619790277041141442e-16,4.725067747438797107e-15,-8.426942452179461728e-15,2.008979528139652050e-15,2.623956862619063877e-14,-1.300779724286862501e-14,5.629454265577132234e-15,-6.057790007277858514e-16,6.200670791553118514e-15,-1.873330537296704938e-15,2.312196785223430424e-14};
    vector<float> cluster1_0_1_pcaEigenValLoad = {6.655906830376868477e+00,3.096069643310793928e+00,1.228471941915411536e+00,1.732734241805136341e-02,2.052479276976260352e-03,1.766067923436451454e-04,3.176800485639412063e-05,1.854317749338864430e-05,1.012157461595721640e-05,1.857353110140045566e-07,9.320907436851152531e-09};
    vector<float> cluster1_0_1_pcaEigenVecLoad = {3.874331497347088260e-01,3.707370300309146827e-01,-2.602407615575316052e-02,-3.583400274103550887e-01,2.657825955350881508e-01,3.673071867428412407e-01,-3.382839536028177108e-01,-1.194789621462477164e-01,3.859272840589562659e-01,-2.431354514198055816e-02,3.155432633170690004e-01,1.405900103111037622e-02,1.622750705218778122e-01,5.404353557499209648e-01,2.125015321316739147e-01,3.497288720540139839e-01,-1.782202265396556629e-01,9.059938436675718521e-02,-3.621037224974131830e-01,4.984992183978370628e-02,-5.628541521389447411e-01,-1.534665188132363078e-01,-3.485483796330941450e-03,-5.349373899954686096e-02,-2.684903193599769144e-01,-6.538554772034860241e-02,-3.485706309656836366e-01,5.211733083814866496e-02,-4.161355457373262512e-01,-6.362430032151860093e-01,-2.106901425197826860e-02,-6.448669586817559751e-02,-4.625687624909476936e-01,-1.060480313412208442e-01,3.849320402836992061e-02,3.917177538004011916e-01,-1.116371335160731143e-01,3.216670519506879544e-01,-1.218955550865136461e-01,-8.830170350276146662e-02,-2.829710566137979555e-01,-1.463445626210651551e-01,7.637029615128093640e-01,-1.025156927248851851e-01,-1.385603093220035553e-01,-1.517361630713565945e-01,1.918414491987521786e-02,1.463499384020900407e-01,-2.018363562899869457e-01,-1.661114587617769922e-01,-1.153158198435740023e-01,-4.149171025925249001e-01,-1.723766048342387780e-01,-3.330335419153249155e-02,8.070831199656144372e-01,-5.497702452934271067e-01,-5.415072891919892051e-01,1.780661874361825492e-01,-2.346991988546400232e-01,1.915940575489314401e-01,4.488796362222597924e-01,-1.704288380238345724e-01,4.548254609380558006e-02,1.552070741945594246e-01,-1.557532888482374145e-01,8.189486637157227314e-03,4.348311020610051703e-01,-3.854717051985928622e-01,2.560237420795161700e-01,4.160437247704064090e-01,-1.373204685180192189e-02,-4.314811200727292767e-02,-5.825896623979508471e-01,2.822770549213182156e-01,-8.426553810715284656e-03,3.980000185808725555e-02,-2.994183756712238270e-02,-4.729400189828021905e-01,4.720450383981551479e-01,1.960972344636768838e-02,-9.693237588646332059e-02,-1.642594733568708901e-02,-2.869334592488927416e-01,-5.528444020246808810e-01,3.260964848223557588e-01,-1.799619544530036419e-01,-1.292953180702369753e-01,6.382558125909778245e-03,6.928397737912231347e-02,1.284038618864110914e-01,6.194265736363385733e-01,-2.697105350326866602e-01,-6.903357664021381179e-01,1.694975983601405278e-01,9.291979064797323273e-02,8.720380855064273351e-02,2.470522561762375155e-02,1.111944456199513188e-02,-3.692930116395569916e-03,2.792679535132674973e-01,-3.399413236981307929e-01,-4.975731819374863696e-03,-6.913488973049648489e-01,1.063880617838073306e-01,-4.696574347769366664e-01,-1.908208157682760378e-02,4.335057332715790829e-02,-2.380082888923975570e-01,-1.940962413534275122e-01,1.749441731109648100e-04,-1.464652697488404987e-01,-1.102766188308847428e-01,-4.349285495093794130e-04,-2.209645186657628797e-04,-1.276388747629735865e-01,-5.031522461951656311e-01,-3.833652517905197354e-04,-1.146874911056328161e-05,8.265566810285638333e-01,1.172040733507861143e-01,6.560993052791156033e-06};
    cv::PCA pcaANN1_0_1;
    pcaANN1_0_1.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_1_pcaMeanLoad.data());
    pcaANN1_0_1.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_1_pcaEigenValLoad.data());
    pcaANN1_0_1.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_1_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_2_pcaMeanLoad = {8.057435194219208659e-16,3.989446840715760664e-16,-7.423712988098947910e-16,3.895505031303036671e-15,3.334587727477637007e-15,-4.806424876525646205e-14,-1.749011687705419663e-15,-7.141733556894526319e-15,-1.203995190145370419e-15,-5.694918039788045905e-14,4.157125270369160862e-14};
    vector<float> cluster1_0_2_pcaEigenValLoad = {6.497088327231790750e+00,3.669992005605801300e+00,8.190663588191866573e-01,1.180021095588391911e-02,1.821436663953085499e-03,1.868019070655162065e-04,6.122711500938062869e-05,4.081942413037968517e-05,2.186061232023365507e-06,2.150987019027255355e-07,1.491454518054242450e-08};
    vector<float> cluster1_0_2_pcaEigenVecLoad = {-3.802589801928757396e-01,-3.393545600043006982e-01,-1.578146605660965818e-01,3.614860551598125804e-01,-3.447375620934066687e-01,-3.657114425975070970e-01,3.734624396072425134e-02,-1.279419605027013462e-01,-3.708257622235580087e-01,-2.742738189380065084e-01,-3.187057397957287486e-01,1.266978883066432193e-01,2.589005740142444889e-01,4.315561572684069591e-01,1.454784615423560246e-01,2.004039106289214056e-01,-1.383976356501789573e-01,-4.273035178575853577e-01,-4.850980270589460575e-01,1.684178027297023317e-01,-3.545750312244035363e-01,-2.796451394209559793e-01,3.636623794490846662e-02,-8.317944283027649266e-02,-4.319666704321757922e-01,-2.985588976197123268e-01,-3.123792293494120353e-01,2.707547705796317650e-01,-6.255571595694411346e-01,-1.898544035633061566e-01,5.227561287279400715e-04,2.337778380798175293e-01,-2.512336030535115561e-01,-2.016962427416816306e-01,-5.877985866035671803e-02,3.944041527264893210e-01,-1.614234367072754639e-01,2.023914226641732872e-01,-2.375966938147434371e-01,-1.080406324405417534e-01,-1.730625612590136753e-01,-4.559663368790697890e-01,6.536794749878686028e-01,3.366101414142185638e-03,-8.513638385955744903e-02,-8.960969174134379711e-02,-4.476767832555020310e-02,1.006598665050996710e-01,-1.368633801593167887e-01,-9.449204033239708145e-02,-3.107931549065207077e-01,-2.535997783081446744e-01,-7.406306352603185539e-02,-1.490777772665224932e-01,8.696610036553127365e-01,4.894389097650665987e-01,5.614761735026518874e-01,-1.474409066467611551e-01,1.327619193780414375e-01,-2.939949972896242492e-01,-4.055291939520974664e-01,-7.222690352196860231e-02,2.085165805006964357e-01,-3.121619785466125396e-01,9.231541889621233676e-02,1.671523484980984645e-02,-3.697193538237730781e-01,1.464594914706933704e-01,4.581767731800632792e-01,-2.342755159954685862e-01,-3.438357363088723750e-01,6.161225779643577510e-02,-2.988903079255327278e-01,5.689316609468754171e-01,4.254940498099506001e-04,-2.048658432621409953e-01,6.189849393619127615e-03,3.313303237771969001e-01,-4.997668826261371655e-01,-1.377490915971361137e-03,2.699045190100249902e-01,3.738306072590645290e-01,-1.428921837563420782e-01,-4.254608173653616765e-01,4.751020880678661906e-01,-1.515948096363850008e-02,2.093889376911114552e-03,-2.150205047895052679e-02,5.006274759131431606e-01,-3.903658204094055395e-01,4.585857044634129576e-01,4.604116685302848261e-02,-5.288072802978646125e-01,2.157596147504945994e-01,1.741265278043318265e-01,-1.485299253761044602e-01,-1.355074674968509765e-02,7.621215648552555344e-02,-1.888446227667249424e-03,2.074984398392424045e-01,-2.281567794787703329e-01,-5.226989415230395841e-02,-7.584833936450352532e-01,8.920060757551932784e-02,-4.028690384081824449e-01,1.026542854817897588e-01,-5.528493807979201896e-02,-1.110868082161073772e-01,-3.614735820656051479e-01,1.309379682535671916e-03,1.019439503510665285e-01,9.214870722263689140e-02,4.084980761000569518e-04,-7.775452833152125820e-03,2.274210789592690796e-01,5.575735895001681097e-01,1.743420404666965167e-03,-7.812155635372071676e-04,-7.145164751912603807e-01,-3.284955467022829256e-01,2.835338161975991625e-06};
    cv::PCA pcaANN1_0_2;
    pcaANN1_0_2.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_2_pcaMeanLoad.data());
    pcaANN1_0_2.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_2_pcaEigenValLoad.data());
    pcaANN1_0_2.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_2_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_3_pcaMeanLoad = {-3.840922551350085382e-15,3.175419241984109396e-15,-2.053313615417877341e-15,-1.017810331814847882e-15,6.048506290254384788e-15,-2.345278360189162947e-14,-3.346761511932812262e-15,-4.086140655081018038e-15,-6.793472681335700702e-15,1.966664712055231694e-14,-3.186593737850329435e-14};
    vector<float> cluster1_0_3_pcaEigenValLoad = {7.345427644357899410e+00,3.370517507729038797e+00,2.690059359458272237e-01,1.135240911354764778e-02,2.970290092512696718e-03,6.954685102128196688e-04,1.553384411533271212e-04,1.034242275126281128e-04,1.150643012063599178e-05,7.438692022631264112e-07,5.632583577940887541e-09};
    vector<float> cluster1_0_3_pcaEigenVecLoad = {3.665060369773358029e-01,3.000622755803399877e-01,-2.312011322429516624e-01,-3.241994140848687977e-01,-2.798535164047517565e-01,3.133780970646825592e-01,-3.643463240201982312e-01,-2.637861843642899107e-01,3.647899540517759998e-01,-3.071317098975311355e-01,-1.040188297144081508e-01,-1.274922158667013417e-02,3.009306554596855032e-01,4.209832251474578957e-01,2.569296777871871162e-01,3.090266351381227850e-01,-2.854972966945432677e-01,-7.199444994822097599e-02,-3.750045198881006292e-01,4.465741565550778586e-03,-2.987442634429025579e-01,-5.039371256197043847e-01,2.145777799941830932e-01,3.490318852858040888e-01,1.918043222953332294e-01,-9.714250377860514374e-02,6.151984086081457859e-01,1.166663615865423248e-01,1.451878539309411076e-01,2.254651835429171414e-01,2.864066369250637401e-01,-7.588714481343747376e-02,4.838654266151337646e-01,-1.366534317019213740e-01,1.822017815531521423e-01,2.283685720783978218e-02,-5.024565022714017060e-01,2.788213121677617923e-01,-3.657982931867358178e-02,-3.510933500187944367e-01,-1.699024828957866606e-01,-1.701972771422382569e-01,6.444655441035911370e-01,-1.401018873681765808e-01,-1.406097257850262294e-01,-6.504640417083244752e-02,1.730985294286606635e-01,1.371230869523863971e-01,-1.249323726905160886e-01,-1.537231469122611605e-01,-3.371026173410566207e-01,-5.357699828458254432e-01,-1.322422163023479202e-01,-7.708158851848243009e-02,6.810843564587288901e-01,2.297972702658984956e-01,6.056443187446192145e-01,-2.007865165487035183e-02,-4.768576397687893098e-02,-4.142093012717891209e-01,-5.100946092287832467e-01,1.746727103536863668e-01,1.844345245462061245e-01,-2.355518288056262788e-01,1.002558152139828573e-01,1.260265514217538407e-01,-7.657774561325761953e-01,2.628461111501846359e-01,4.784144488194752576e-02,-2.808978043859726714e-01,-8.847706583510313305e-02,6.779412646481450255e-02,-1.058937311589809582e-01,2.781041964015280032e-01,-2.719242079450728475e-02,-4.011250528571802532e-01,2.615401078082382064e-02,1.541087521324559229e-01,-4.906934154941645226e-02,6.023447311833387552e-01,1.883726907007695628e-01,-2.460215212304099341e-01,1.614447060900593145e-01,-5.020155602536103823e-01,4.616719406724926200e-01,5.033562298683010722e-02,1.422314064736287520e-01,-3.200332712210821745e-02,-7.362141379862330304e-02,2.015566179955294024e-01,-5.760607150986912783e-01,5.284949710096887854e-01,2.422402351307484381e-01,-8.951739002937929290e-02,-4.793134528608813949e-01,2.109332034466854799e-01,-1.835739986608372551e-02,3.914581729159692658e-02,-2.156182994068534496e-03,-2.578986821222922221e-01,4.096458891341290265e-01,6.847208521133238412e-02,3.901423351000409268e-01,-2.034402702426015286e-01,5.146785071729689243e-01,2.838992728154158818e-01,-2.324773832076199587e-01,1.500991787844830894e-01,3.812101305867590662e-01,-1.296125179101442846e-03,-2.147525439270348835e-01,-1.158267954253369564e-01,-3.665885311123181275e-04,4.262300426380057463e-04,-1.198901325886095326e-01,-4.668417892492346954e-01,-6.952687083413395478e-04,1.143452659925348324e-04,8.104319488000373273e-01,2.266050354414195500e-01,-9.860104900848452822e-07};
    cv::PCA pcaANN1_0_3;
    pcaANN1_0_3.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_3_pcaMeanLoad.data());
    pcaANN1_0_3.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_3_pcaEigenValLoad.data());
    pcaANN1_0_3.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_3_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_4_pcaMeanLoad = {-1.543966070088031343e-16,-1.098285142639939814e-16,7.353735302893510359e-16,5.252668073495364542e-17,-3.645033299486176914e-16,1.448463014206297532e-16,-9.852731931798880061e-16,-6.478290623977616433e-16,1.289291254403407683e-16,2.753671444589993855e-16,2.042173678271076370e-15};
    vector<float> cluster1_0_4_pcaEigenValLoad = {5.329958248462945747e+00,3.981878550330620659e+00,1.149602158934666996e+00,4.464658885622147522e-01,8.880242170550491088e-02,2.843864646690416262e-02,1.190763924378904041e-02,2.068151466410297814e-03,4.466400896234846247e-04,4.263458299700240246e-11,1.843355105255507140e-11};
    vector<float> cluster1_0_4_pcaEigenVecLoad = {4.142295738201135502e-01,3.971460079195365256e-01,-1.155477176208420317e-02,-4.242647260731899905e-01,1.449583750479058741e-01,4.187472501547570558e-01,7.961757568159108164e-03,3.506989880293417440e-03,4.334446648019783521e-01,-2.973899993722322610e-01,-1.334236496418047813e-01,2.618741371330904344e-02,-1.829395902298228127e-01,-4.807290055858005617e-01,1.035276939871171697e-01,-4.516155805099507647e-01,-1.652377201319214783e-02,3.996287957469816243e-01,1.043325511037701270e-01,-6.367179689354689372e-04,-3.584708012373841735e-01,-4.697968938757678958e-01,-8.411285301623530608e-02,-4.079179414710992074e-02,-1.911661568941185052e-01,4.225349048681279265e-03,-1.828150865531097680e-01,9.335177680354991847e-02,-3.310002454755426315e-01,-8.892053464845248723e-01,2.211843826901297924e-02,-1.074276728836214556e-01,-1.689832339302261774e-02,3.104023839738312418e-01,1.884378912583005994e-01,-2.901806357073887788e-01,4.883978761768208859e-02,-2.597023922677944019e-01,-2.835681516319307205e-01,-7.242688265050145624e-01,3.108738331826719770e-01,-4.047441011120955778e-02,6.242101607416314368e-02,-8.338304067145428655e-02,-5.551950588148564236e-01,-4.460764483406889913e-02,-6.371194964814497208e-02,-6.422624745112032185e-02,-3.181109547052377584e-01,4.882535630479345468e-01,-2.440251189808456400e-01,2.989083919660855959e-01,9.621868431632209229e-02,-2.311439163844428157e-01,3.611346413643471420e-01,-5.169145520213715983e-01,4.365519913007347430e-01,1.985821028288358714e-01,3.100139498613035602e-02,9.031833648063487818e-02,3.086382286889326199e-02,-1.313048839980325844e-01,1.757655246356093492e-02,-5.877011526355085946e-02,1.134648446562741553e-01,-6.773755856974654765e-01,-9.633710631391254053e-02,7.274446701232549772e-01,-1.913208267470492829e-01,3.759644572595764733e-02,-2.721830210449882048e-01,-2.466849873520334246e-01,3.434651287716669610e-01,-9.965029966451752208e-02,-3.924467928383798543e-02,8.721433900519974525e-02,3.892868091296063926e-01,2.002895583652922751e-01,-2.814142905176620236e-03,7.426824663012125960e-01,1.058558161625342345e-02,-6.168434965520800395e-01,-7.164082170514382564e-02,1.125186692160791077e-02,-4.600195324815217757e-02,1.038072390443000106e-02,-1.335860394507387139e-01,-4.860856889659042473e-02,-9.851858455611826881e-02,1.003404501792632963e-01,1.262084396667032538e-01,2.493027749729225528e-01,3.272896085233106267e-01,-3.497425189459463235e-01,-1.059343028495361300e-01,8.497364054767034963e-03,-4.028767282077440337e-02,-8.054203533798145465e-01,1.052986104405264772e-01,-2.986228611104337904e-01,-1.988909025430840305e-01,-1.422443596049041865e-02,-6.010253467307776765e-01,-5.580098710038440546e-02,-5.542357712841671225e-01,-8.540913295692959721e-04,-4.818290625296659180e-05,4.462846701476715916e-01,1.926693459072003484e-02,3.647975832522036200e-06,-2.414518935389078566e-02,-1.607475519637934641e-02,1.452364089989256583e-02,6.139082135909728066e-01,1.814455738432786626e-04,-2.061861183005235174e-02,6.352554209874745515e-05,-4.556338335682334740e-07,7.712619170093660825e-01,1.636895612403045930e-01,-4.122016444950630608e-06};
    cv::PCA pcaANN1_0_4;
    pcaANN1_0_4.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_4_pcaMeanLoad.data());
    pcaANN1_0_4.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_4_pcaEigenValLoad.data());
    pcaANN1_0_4.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_4_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_5_pcaMeanLoad = {2.405599230786545916e-16,4.677554059862728375e-17,-4.232072720828182698e-17,-8.430734341228774748e-16,-1.650508361122991394e-15,-4.376854156014410198e-16,-8.486419508608093235e-16,1.051335960121527551e-15,5.278953867559365347e-16,9.577848789242730452e-16,-4.953752490064147040e-15};
    vector<float> cluster1_0_5_pcaEigenValLoad = {5.921276345159561139e+00,4.489075434316069035e+00,3.265055670853032055e-01,2.452578955577955633e-01,1.823363589684652564e-02,4.300665017840085702e-03,1.817147461470277432e-03,3.723712990952910990e-04,6.180453718473271089e-05,1.173109922822702835e-08,2.313342958252954892e-10};
    vector<float> cluster1_0_5_pcaEigenVecLoad = {-2.440651451306225517e-01,-7.023070851182237895e-02,3.740283464647073952e-01,3.302687565340195475e-01,-2.924043038824543639e-01,-3.872979702713015282e-01,4.067466004448069272e-01,3.368618525245488105e-01,-2.561903236210557044e-01,-1.505884335539398322e-01,-2.894756283531011443e-01,3.789794138910454468e-01,4.583837519836720387e-01,1.367470651799500836e-01,-2.764949664691130349e-01,-2.674997484179705842e-01,1.419533719786577886e-01,4.049774526745534425e-02,1.812769496340647379e-01,3.688057686384262901e-01,-4.279957619816039394e-01,-3.251205486134685629e-01,-6.336402290863234199e-02,-2.594110574812328873e-01,-3.934802696908332731e-01,1.743318992242860188e-01,-7.188999983144663819e-01,1.012419467528752615e-01,-1.074050817565934818e-01,-2.912469485365972721e-01,-2.999643258925223030e-02,-3.287261425305940676e-01,1.052812015755305863e-01,-1.167275879775791711e-02,-9.826427436494943046e-02,-3.822207132630016102e-01,-7.870538492598141977e-02,-9.746574995107719352e-02,2.384027863022369353e-01,1.874081039606245447e-01,7.908094411509508648e-01,5.039202068370487314e-02,1.145929708112123913e-01,3.088898388426472574e-01,2.858880597446929461e-01,4.229659533752951894e-01,-2.516341090323359619e-01,4.376792109884885401e-02,-3.150426503562548386e-01,-4.862005574107750583e-01,-2.174022311349301240e-01,4.513602751555887554e-02,-1.618424223969512354e-01,5.121576639265077446e-01,-2.627121574245903576e-02,4.427246587831418917e-02,-3.255836671782817437e-01,-2.758877646435921593e-01,-5.956222702177242645e-02,1.611138258999527534e-02,2.436316500133731966e-01,1.606896189897250027e-02,1.959880459513388407e-02,-3.354230257285296946e-02,3.078470161032383912e-01,-8.100742887310634632e-01,-3.696682290063980081e-01,2.602468598368162800e-01,-4.591217755124645805e-01,1.915356973464560630e-01,3.524745275777211861e-01,-2.364122716478378738e-01,-3.346169089256268436e-01,1.637506974679098781e-01,-1.170522604375539774e-02,-4.291718726901622150e-01,-2.118983582723668879e-01,3.695847765435928967e-01,-1.429850419562060312e-02,-4.171498977341730474e-01,6.719718195224576307e-02,2.559427482380877694e-01,-2.441006338550925359e-01,6.878213892699336363e-01,-2.441887123341831833e-01,2.207966533222992939e-02,-1.568656209047985528e-01,4.195964784449436602e-02,6.035850690035895472e-01,-4.983416520976713948e-01,1.150155203805273557e-01,1.487677504517855021e-01,1.424356764464094760e-01,-2.509026411681683499e-01,-3.919923848152871426e-01,2.336493226671431112e-01,-6.103358914954847697e-02,-2.373488698255541984e-01,2.075019854757531243e-02,-1.693730485193277180e-01,-2.087117251172298515e-01,-5.490344605403875422e-02,-8.420661060436814838e-01,-5.860451473279149753e-02,-3.617531459632216118e-01,3.566970116520262225e-03,-1.613765479005050112e-03,-2.463559597638461385e-01,-1.437193734671129430e-01,8.935326238669424230e-04,2.066732940275968211e-01,2.515138870865068488e-01,-2.369966277907693808e-04,-3.884369156661151862e-03,6.039855500096161234e-02,3.971435302258492506e-01,2.295506053553556826e-04,1.018852179244383363e-05,-8.381830013681546010e-01,-1.734647052670114653e-01,6.901638993318935445e-06};
    cv::PCA pcaANN1_0_5;
    pcaANN1_0_5.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_5_pcaMeanLoad.data());
    pcaANN1_0_5.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_5_pcaEigenValLoad.data());
    pcaANN1_0_5.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_5_pcaEigenVecLoad.data());

    vector<float> cluster1_0_6_pcaMeanLoad = {-2.838377326144530257e-16,-2.860592199859087160e-15,-3.641359569103780399e-15,2.251562892792313709e-15,6.005534783264501583e-15,-7.370553331202040235e-15,-1.023593027309195433e-15,-6.584915778104539700e-15,-1.161197081606479092e-15,1.683156899985486622e-14,9.277888211605097750e-14};
    vector<float> cluster1_0_6_pcaEigenValLoad = {6.745464625160916938e+00,3.260554363511601661e+00,9.717775160649264610e-01,1.869366644149978232e-02,3.172584455104731239e-03,3.438701346051842300e-04,5.828243823669523931e-05,5.073933540439686608e-05,1.631722584260393254e-05,3.042462190913882214e-07,6.117922422441721704e-09};
    vector<float> cluster1_0_6_pcaEigenVecLoad = {3.831808208753169076e-01,3.586302103668568275e-01,-1.925462444339611223e-01,-3.545216267716686520e-01,-5.532878009468921061e-03,3.585290817732952329e-01,-3.754335562224712097e-01,-2.561270375578361680e-01,3.817482624790524692e-01,-2.713788198739439661e-01,8.540410485957122821e-02,-7.039576870551832524e-03,1.815549017285176259e-01,4.656413414299931941e-01,2.140358064247570580e-01,4.302380169203404714e-01,-2.002409970152606855e-01,-2.078093329773807868e-02,-3.677635621766127128e-01,1.914362589088888442e-02,-3.885033504890131884e-01,-4.383727318606894796e-01,-9.718111715839743148e-02,-1.592879512839582845e-01,-2.094203724180469517e-01,2.504562143394140766e-02,-6.368838366717370914e-01,-4.516201370573987711e-02,-2.178989369103869755e-01,-3.433802438569102944e-01,-1.261240964149938915e-01,-1.164372360661434028e-02,-5.758520400566251585e-01,-6.502754948279848568e-02,9.166891897179466064e-02,1.052486589993227167e-01,-3.389538596715652718e-01,3.237491042423574217e-01,-4.922225998253111807e-03,-2.781248513782300646e-01,-2.214045813654428596e-01,-1.111647857339344431e-01,7.653840176392671113e-01,-1.789407484063493814e-01,-1.474553375303900571e-01,-6.735032772888399633e-02,1.939525618754673886e-01,1.319887366985760258e-01,-1.780691060167308715e-01,-2.046088294597893653e-01,-2.539651656078283359e-01,-5.614828717440299988e-01,-1.697597549758259883e-01,-2.366997467507013855e-02,6.602794041843652595e-01,-4.814058750114660890e-01,-5.978303395318531610e-01,4.664082867793833964e-02,-1.226811775685913153e-01,2.453829217655006667e-01,4.680854308394092334e-01,-2.293379667108589870e-01,-1.371956318722834973e-02,1.444110388953571689e-01,-2.009903032725816885e-01,-1.639213221166576848e-02,-6.451869176702714759e-01,4.636769036123639109e-01,-2.939478204132495165e-02,-4.967125085877997503e-01,-1.029143829555337897e-01,-9.464086715122141391e-02,2.174831142148101748e-01,2.126455468392517145e-02,-1.011663808802864134e-01,-2.076471315461172196e-01,2.233568571291364574e-02,-1.111378069667557636e-03,1.173906936255105921e-01,6.353431750235966069e-01,-4.410130045107507613e-02,-3.321539752153072622e-01,2.301533890984586508e-02,-4.759267063750090565e-01,4.928329318907191392e-01,-4.532448362125140540e-04,-1.391621092320683914e-02,-1.311301291061983676e-02,-2.238232213691440098e-01,1.983091658582486760e-01,-4.944711805844257402e-01,3.258624740848911072e-01,2.670420953488034654e-01,-2.603718561116947772e-01,-5.752594028383710700e-01,2.525226905372557340e-01,-1.270225018926111615e-01,-9.978272830955406403e-02,-1.075675528942583855e-03,-2.969283313866911689e-01,4.026078789311443584e-01,4.847749086550792036e-02,5.706660967313508248e-01,-1.183602351534732006e-01,5.128832450830916878e-01,1.093679454408381657e-01,-9.830303246328654654e-02,2.243131277537975810e-01,2.696858927997324296e-01,-7.339423776152507149e-04,1.772704030201554815e-01,1.118601398920042039e-01,3.610172715558766787e-04,5.263768114160329595e-05,7.918641240679595572e-02,4.774919214888300734e-01,5.889328110259622277e-04,-7.280553471680674003e-05,-8.362284547376206412e-01,-1.500499133787960571e-01,-7.410023667924426960e-06};
    cv::PCA pcaANN1_0_6;
    pcaANN1_0_6.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_6_pcaMeanLoad.data());
    pcaANN1_0_6.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_6_pcaEigenValLoad.data());
    pcaANN1_0_6.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_6_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_7_pcaMeanLoad = {5.603913723919423952e-16,-4.227697658137036415e-15,-1.209470108137279792e-15,-1.819690978495820550e-15,-1.837611311709496189e-14,3.322664956791608481e-14,-1.052679891166436555e-15,9.591308501126051138e-15,-3.766609719511352669e-15,-5.294545431791070714e-14,-4.862856135046750307e-14};
    vector<float> cluster1_0_7_pcaEigenValLoad = {6.624796002652558080e+00,2.949396939822193531e+00,1.414786602236698609e+00,9.632998048497898660e-03,1.265313508611006508e-03,1.065811564886455840e-04,2.826430355940644500e-05,2.015486486379796608e-05,6.269770595244975316e-06,1.741495032055858330e-07,1.749764640130786721e-08};
    vector<float> cluster1_0_7_pcaEigenVecLoad = {-3.816384757599839417e-01,-3.433943628264761738e-01,4.408260863952009889e-02,3.698775803353108738e-01,-2.400918908423770870e-01,-3.770065990454355975e-01,2.972614087150610152e-01,-6.837036520846244414e-02,-3.747481295739160667e-01,-2.154521292966543045e-01,-3.435214115884774322e-01,1.042888297477914256e-01,2.720198183724494290e-01,5.684555862317938191e-01,1.696687716487353392e-01,4.347590803928843006e-01,-1.317506960640832947e-01,1.236529006680675558e-01,-2.982726682221217285e-01,1.511254690663867140e-01,-4.791843096699248128e-01,1.062894292711861338e-02,4.397285976123060242e-02,1.897736040123441242e-02,-1.515869082213062435e-01,-7.806310690854383061e-02,-2.055287032415350490e-01,6.983589128937855994e-02,-5.110287659816429295e-01,-7.064127562946329597e-01,3.440392883674147501e-02,-8.279186900207752275e-02,-3.915446368106971775e-01,-1.571148661660216050e-01,-8.181738813487562934e-03,3.996685175685403268e-01,-1.074776044251420093e-01,2.945485218399052640e-01,-1.608710473303616717e-01,-2.170551867097322840e-02,-2.158143887661330973e-01,-2.421109308311682196e-01,7.588921309003497928e-01,-9.869824666271391489e-02,-1.152637671906503875e-01,-1.486332785390196143e-01,-1.390828307496340746e-02,1.214148028029433807e-01,-1.626604620113536737e-01,-1.456890101196702536e-01,-1.218571273908556490e-01,-3.754731737168475747e-01,-1.688380793512724853e-01,-2.268557242971556628e-02,8.468491650359889489e-01,-6.190321602128859846e-01,-4.373687953179220544e-01,1.447640127982726677e-01,-2.812292082972764895e-01,2.112607507236916038e-01,4.436124000898932218e-01,-4.346940073927845621e-02,-1.960575435286380716e-02,2.308975637510397028e-01,-1.667807383251470876e-01,2.519313729311666028e-02,1.883166506625941483e-01,-3.632656750421715541e-01,3.233227569187596684e-01,2.658007471818241152e-01,4.580631561000195195e-02,-9.627306390324585905e-02,-6.935674957891013737e-01,3.960069807738737513e-01,-6.091167241843307295e-02,-6.458487558776995763e-02,-1.678352358805220920e-02,-5.133928709570176885e-01,6.077784328678538239e-01,1.218842856749012410e-01,-2.433084584945870155e-01,-2.206589074131031503e-01,-1.971938005969054164e-01,-3.126992525023837288e-01,2.493738872955633401e-01,-1.586924775941900845e-01,-1.396112501379639104e-01,2.756521932795851990e-02,1.968271574755237618e-01,-4.880386163638918834e-02,5.930068905849518179e-01,-1.616798074794563167e-01,-6.851125760610684567e-01,2.608450223377635213e-01,1.935748223024379711e-01,-1.529631203261763023e-02,6.131787390051172265e-02,4.684266272167034173e-02,-1.023466890923175080e-03,2.571086628255974116e-01,-2.825710036039222883e-01,-4.772861247949518218e-04,-7.529469326925452011e-01,8.933251321190958938e-02,-4.125644431113231203e-01,4.119891668684549924e-02,1.251975233216576049e-02,-2.188249073227430119e-01,-2.432910985747308019e-01,8.607482220177329127e-04,1.284113451083807589e-01,1.033942513643729966e-01,7.818945038942471748e-04,2.809032751426436200e-03,1.584358038167608951e-01,5.525672270167628630e-01,2.850451295460305792e-04,-1.634298994568393623e-05,-7.839425111840196969e-01,-1.667730989796941121e-01,-1.252550421691712007e-06};
    cv::PCA pcaANN1_0_7;
    pcaANN1_0_7.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_7_pcaMeanLoad.data());
    pcaANN1_0_7.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_7_pcaEigenValLoad.data());
    pcaANN1_0_7.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_7_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_8_pcaMeanLoad = {-4.925977335861553760e-15,3.564227676451537553e-15,-1.438480385460263958e-14,-6.881885416658570911e-15,9.641346616034419289e-15,-1.269222038376205883e-14,-4.168480207886868240e-15,1.334885385966813653e-14,2.379318563924030445e-15,2.878329026246771696e-14,-6.774774259138055017e-14};
    vector<float> cluster1_0_8_pcaEigenValLoad = {6.829831478994007554e+00,3.608995701361321196e+00,5.484849883885754007e-01,1.084920175872838843e-02,1.603175752425294682e-03,2.129852130881579395e-04,5.857046120741608608e-05,4.226381824800741434e-05,1.344305274386876006e-06,2.083871113230751520e-07,1.470682877383109473e-08};
    vector<float> cluster1_0_8_pcaEigenVecLoad = {-3.672355081856367720e-01,-3.312853681411449536e-01,-1.987090078267598203e-01,3.603598128913735321e-01,-3.510545576673912982e-01,-3.630028138101686896e-01,-2.909147793935758231e-02,-1.442798429106157687e-01,-3.568830023468725354e-01,-2.862102623169515137e-01,-3.163676623373665175e-01,1.463224190063885655e-01,2.615412310180430522e-01,4.116296370445124975e-01,1.174363464169156379e-01,1.743497206035465041e-01,-1.104986752534593136e-01,-4.741259266585877707e-01,-4.836072571132832842e-01,1.880138024500152549e-01,-3.329408360019568414e-01,-2.819179573232903913e-01,-4.634072703559139611e-02,7.903173891852435795e-02,4.622004445001444695e-01,3.388952889937796864e-01,2.963012957636029232e-01,-3.174173635389199721e-01,5.770042978305947035e-01,1.556473673442299033e-01,-1.567974229749439022e-02,-2.559152390381686515e-01,2.273334254991633552e-01,-1.933597785216471798e-01,-7.008339056483528506e-02,3.876218313405457860e-01,-1.675847628470654993e-01,1.889858707013139516e-01,-2.456363550665261741e-01,-1.171501698537535524e-01,-1.786429817793766806e-01,-4.685505696216460958e-01,6.460261357775028968e-01,-2.802173541050928876e-02,-6.308194973147095153e-02,-6.247825511675716981e-02,-5.414069281735882366e-02,8.452367499018646757e-02,-1.334629527334086352e-01,-1.000250121671646258e-01,-3.227562496555148597e-01,-2.479481859106318076e-01,-8.284583626768853015e-02,-1.194173941968367236e-01,8.760424989576518495e-01,-4.983177616204870208e-01,-5.615497999377907501e-01,1.718586643036946471e-01,-1.252495142655463412e-01,2.634106705217696409e-01,3.986926893204257860e-01,7.910605190169700540e-02,-2.318621357053882448e-01,3.044972795879724026e-01,-9.958022620965079064e-02,1.116760096473667398e-02,-2.263354412401646087e-01,-5.189624325296824520e-02,4.083584988035008911e-01,-1.329938620431019847e-01,-1.824701755907915390e-01,4.055382774478273784e-03,-4.393192978628152612e-01,7.072063875576229952e-01,-7.499786858080252291e-03,-1.873949801771004620e-01,2.785768045879718526e-03,-4.206294658525798202e-01,5.167404341663128786e-01,1.886984843686275448e-01,-3.058201486025254323e-01,-5.074832189532181292e-01,1.551647906170187663e-01,2.927331648005833120e-01,-2.323519922775572621e-01,-9.036409161889235112e-03,-7.180939535143453234e-02,1.957971023171226066e-02,5.106321031344729366e-01,-3.947319271461904311e-01,4.377150184396431110e-01,1.115209318776565067e-01,-5.318137522170987008e-01,2.264033898833152647e-01,1.479875500534628407e-01,-1.206949525247173610e-01,-3.113475189033890894e-02,8.881633585256704100e-02,-7.365475116399177640e-04,-2.302372088592149479e-01,2.405491222041407362e-01,2.775852434018405077e-02,7.528868551101186579e-01,-4.811577106694139155e-02,3.939579155308955416e-01,-1.291139966329238886e-01,7.233685386400555417e-02,9.463658660120488619e-02,3.648828312317053957e-01,-1.104514784454191075e-03,9.990617480230214176e-02,8.975361220088937109e-02,6.836541201391456045e-04,-9.709903087945196895e-03,2.442941612106087623e-01,5.435193117207447466e-01,2.432094639598797198e-03,-1.167097708718613279e-03,-7.126390786767569097e-01,-3.448386324068407616e-01,1.607694974395982798e-05};
    cv::PCA pcaANN1_0_8;
    pcaANN1_0_8.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_8_pcaMeanLoad.data());
    pcaANN1_0_8.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_8_pcaEigenValLoad.data());
    pcaANN1_0_8.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_8_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_9_pcaMeanLoad = {5.869777499581080697e-16,-2.165912643426502483e-16,-2.128455354577824300e-16,-2.701331536969371111e-16,8.663650573706009933e-16,-2.103777611336342281e-15,8.363992262916584469e-16,4.701991435475235494e-16,-1.421173606317491358e-16,1.965405979589460865e-16,-3.373800040299756207e-15};
    vector<float> cluster1_0_9_pcaEigenValLoad = {6.644376387619408852e+00,3.944723586490677558e+00,3.243638134576215526e-01,7.585573397903282167e-02,7.448372983545899217e-03,3.791035777204888445e-03,1.688337399164553014e-03,2.955383797452011338e-04,1.850095380657243850e-04,1.712527177498097857e-06,3.843386669366304434e-10};
    vector<float> cluster1_0_9_pcaEigenVecLoad = {3.855795060867823199e-01,3.794588283595499711e-01,3.028806229858737598e-01,-3.727975043854346304e-01,3.640018268030984494e-01,3.509820813933264283e-01,-2.289049281932181157e-01,-8.445894018576216578e-02,3.816990378393989025e-01,1.159657524982968535e-01,4.760304261181991931e-02,-3.459888959353843701e-03,9.920224535192195825e-02,2.672073965287275477e-01,1.381426943179648870e-01,-1.488856882374981483e-01,-1.868686657041157551e-01,-3.978542016223527988e-01,-4.830360326987342412e-01,-4.639919432662486729e-03,-4.519792412467437126e-01,-4.966471207449323910e-01,1.780467124743004559e-01,3.102349060543281231e-02,-5.283787079467622272e-01,-6.590118816592668849e-02,-3.117375535580484414e-01,3.623231883907186979e-01,-3.388428887801435418e-02,2.306481448622457742e-01,3.111553204821102536e-01,-5.500782291332241281e-01,-4.001358592741980497e-02,-3.571248708462604338e-02,1.404965382099101767e-01,4.837090798126243429e-01,-4.758710664337154062e-03,2.713169309824936537e-02,-2.581830551534477700e-02,5.893641470536826743e-01,4.333733346294914024e-01,8.425025913085137930e-02,-2.815983448998157224e-01,-3.493239601182643317e-01,4.839791851527614486e-01,6.108049273597478956e-01,-1.545625803165686651e-01,1.121939930972979810e-01,-3.088890760114406664e-01,-4.085188491092787144e-01,2.082105738928643479e-01,-7.648889498671385123e-02,-1.329476295934813590e-01,1.026543872193776824e-01,1.284099093018976623e-01,1.317720158971787958e-01,-6.074568933783402840e-03,-3.524813023587368144e-01,-7.703113844630272988e-02,8.283250002982874005e-02,2.334562313292458738e-02,-6.412252157269197894e-02,1.717023058843551719e-01,-6.484780087440181195e-02,4.542004760778736161e-01,-7.751899380724071031e-01,1.254375957995175483e-01,-9.258538393484469151e-03,2.195047287207926023e-01,9.201733119383001536e-02,-1.042487095817340170e-01,-2.186154524937204413e-01,-6.121195563610029033e-01,6.850633159726010613e-01,-1.232958058122970713e-01,-1.852130272735023550e-02,9.655398376530434368e-02,7.138958399549812928e-01,-6.413205695600323608e-01,1.856077609043086940e-01,6.461487410789791552e-02,-1.044953867206082493e-01,1.061486477386197787e-02,1.334651048124853578e-01,-1.045468556336904553e-01,-2.371155542910366107e-02,9.744534345473683523e-03,-1.788757737410902717e-03,-1.501417063659929441e-01,4.666922765361454506e-02,3.006472251148881170e-01,-1.439894548011255715e-01,-7.627733703306460722e-01,4.032999759795468098e-01,-2.454535382563048998e-02,-5.310968576353881226e-02,-4.302167439886196015e-02,3.372296122989351663e-01,-2.618892953406682170e-02,3.654325372806281613e-02,1.247051832581331093e-01,5.050764062880302302e-02,8.863838697871569972e-01,9.416139666923231677e-02,3.448910267218815995e-01,-1.572088834959414066e-02,1.171328657341088805e-02,2.032604340774182561e-01,1.591963750466771077e-01,-5.195695969605702326e-03,1.322155139699245918e-01,1.524513863135539271e-01,-1.545526377845029517e-05,-3.428052665557832055e-04,1.807455230685013070e-01,4.615281703372598465e-01,2.795969484495894396e-04,-4.502339277852660779e-06,-8.182655463956857167e-01,-2.098612307799801457e-01,-9.058929179624696819e-07};
    cv::PCA pcaANN1_0_9;
    pcaANN1_0_9.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_9_pcaMeanLoad.data());
    pcaANN1_0_9.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_9_pcaEigenValLoad.data());
    pcaANN1_0_9.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_9_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_10_pcaMeanLoad = {2.730790504118328627e-17,1.047549144202768727e-16,-2.314456869883894974e-15,7.811851524076202111e-17,4.693378302487960073e-15,8.843732198173374070e-16,-3.350366579151077072e-15,-2.463978841748734694e-15,-3.755956119598816115e-16,3.350366579151077072e-15,5.368465528751966295e-15};
    vector<float> cluster1_0_10_pcaEigenValLoad = {7.162102155220032351e+00,2.138701572728812117e+00,9.743699054147483274e-01,5.587920582234878752e-01,2.139455239518157359e-01,2.341231354756003954e-02,1.384007176740142259e-02,3.652201706099031560e-03,6.150916763315658490e-04,5.072015427505225431e-11,2.194446421103213608e-11};
    vector<float> cluster1_0_10_pcaEigenVecLoad = {3.629509593126054035e-01,3.445761236480587852e-01,-3.323709567514911978e-01,-3.568986888747320285e-01,-2.177559451115151368e-01,2.675695991190958356e-01,-2.304191907506771830e-01,7.051380282200671312e-02,3.660067953845291822e-01,-3.554427036753590174e-01,-2.725984912116192760e-01,1.274524932180504284e-02,2.298067556847549486e-01,2.483291895812216599e-01,-1.823167013100966127e-01,4.120220321166573885e-01,2.983839401574533978e-01,-4.095655170739329054e-01,-4.577064476883614397e-01,1.223613026655610836e-01,1.305003652828197191e-01,4.290486898159527884e-01,-8.535531238988081776e-03,-9.243282727615351191e-02,-2.673549315104739588e-01,1.477609311450727714e-01,-5.080722210952638429e-01,-3.125299735878227514e-01,-3.424952838013484713e-01,-6.369172469012606141e-01,-1.245137972593398229e-01,5.933172601971906102e-02,-1.638476383806811154e-02,2.917070307914862992e-01,1.947001600318287728e-01,1.305913474123922280e-01,-5.206748708009151239e-02,1.249956973084298678e-01,-5.909697630513485178e-01,-4.803335355205222146e-01,3.829869674958909509e-01,-3.992653223584468301e-03,3.318513737265053054e-01,-6.945465652288575209e-02,-2.415816764012776729e-01,3.349596912220520299e-03,-1.005582176385553250e-01,8.752969434045219932e-02,-4.446719417829456122e-01,2.397167273149486966e-01,-3.133852153438282384e-01,4.687919132037133840e-01,-7.353308167716136878e-02,-1.449233056545468946e-02,5.874207464080903884e-01,2.627534920283614017e-01,-7.982068695432957828e-01,-2.361775391350477149e-01,-1.063370884166864490e-02,3.018545987983448087e-01,5.995212725035743706e-02,-3.064661565729242532e-01,7.514958813607289234e-02,4.451722766336887321e-02,-1.965743242154710246e-01,5.505287900211692370e-02,-3.968706094658999151e-01,-6.903496598970489118e-02,1.505081455091575315e-01,1.161778668402486253e-01,4.319324302551389577e-03,3.967006340008019660e-01,-4.379159239268844428e-01,7.864717668919490867e-02,-1.423539692449133365e-01,1.966047620268895346e-01,-6.223455830841815306e-01,-3.157194452778732674e-01,2.880656346088163455e-01,-7.441692824604237977e-01,1.685189016055431976e-01,4.536391984839923674e-01,-8.881940601516379041e-02,-3.369522969345623703e-02,3.986079858953290450e-02,-1.334749589084815724e-01,8.531587298042764278e-03,2.937460098503831898e-02,-2.125511539294948349e-01,1.349719607947259814e-01,3.110813496987153703e-01,2.396065763519260317e-01,1.169141435821260261e-01,-2.643982565069079027e-01,-2.147100840006665734e-01,-1.557395845825883555e-03,-6.567618369295827319e-02,-8.051000357989721579e-01,-1.562145275558327225e-02,5.849543675635823226e-01,1.941165790072470199e-01,7.517707324041932385e-03,4.206649009270125306e-01,2.614131771233581952e-02,3.025442398554405443e-01,1.269691415119006536e-03,9.212278931349360386e-05,-5.909253347631978626e-01,-4.148384502260935719e-02,-5.199830452710419762e-07,-1.048930633943170043e-01,-3.481997953804853024e-02,-1.299504849915074541e-02,-7.285594827598029788e-01,-7.077299988079346210e-03,-6.852143255968393132e-02,-4.510483141712315737e-04,-2.383432637218377075e-05,-6.607358648582557503e-01,-1.244984379320722145e-01,-2.583863305836053840e-06};
    cv::PCA pcaANN1_0_10;
    pcaANN1_0_10.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_10_pcaMeanLoad.data());
    pcaANN1_0_10.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_10_pcaEigenValLoad.data());
    pcaANN1_0_10.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_10_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_11_pcaMeanLoad = {8.130092624288981385e-15,2.913784524364471726e-15,1.053264874953868351e-14,8.223653603873249032e-15,-1.709795814358358624e-14,6.525006068367982290e-14,8.000503890654962641e-14,-1.270582156996560752e-13,3.121241874631347419e-15,2.754546140205431420e-13,-1.278966190861846815e-13};
    vector<float> cluster1_0_11_pcaEigenValLoad = {7.817007568237390736e+00,2.997203986774867879e+00,1.849873787250374269e-01,6.146822314186103703e-04,1.770092470408089237e-04,1.829529393318690957e-05,3.771387673575045665e-06,1.205961192122388654e-06,4.392117798896378788e-07,5.887322452579997598e-08,3.766838932216808661e-08};
    vector<float> cluster1_0_11_pcaEigenVecLoad = {-3.570270271487521185e-01,-3.496975011149734414e-01,-8.789190555627149348e-02,3.314025843410031702e-01,-2.982849358078134561e-01,-3.379072417511468918e-01,2.217338744665789119e-01,-2.366961233747849058e-01,-3.565367090157187668e-01,-2.839005760911283427e-01,-3.415063173413845354e-01,-1.254566451428214616e-02,1.095925420384334936e-01,5.533757068580931193e-01,2.171482806570554924e-01,3.145794122723080677e-01,-1.893244738830998364e-01,4.519090771689667774e-01,3.836053250896111488e-01,2.335887166370799461e-02,-3.441954476866147528e-01,1.710528184606477653e-01,1.285662452983643012e-01,2.086885754412321770e-01,3.423773284071714995e-01,2.726779135543961133e-02,2.060134011673930288e-01,-5.577167914359663350e-04,-1.389097609513657294e-01,-8.086993131949165026e-01,1.582702066123139462e-01,-2.802957501540626062e-01,-5.105421024703848260e-02,-2.598315411049303414e-01,-1.260111497268815162e-01,4.245657412976012179e-01,-1.164062291972863816e-01,2.260057274549203132e-01,-1.110946361242526464e-01,1.011844634389327119e-01,-1.599768993850409216e-01,-2.560632550758631942e-01,7.424319777651516850e-01,-8.232337643359390056e-02,-8.837551003905891323e-02,-1.529147681552390781e-01,-7.775585170920576439e-02,9.730339703389911943e-02,-1.515464658427358446e-01,-1.151228203854556681e-01,1.235360543485230014e-02,-2.229374048292994959e-01,-1.609229851399296973e-01,2.817958065337079071e-02,9.168038668775726485e-01,6.285257985319093743e-01,3.772563519698039491e-01,-1.284697933231142286e-01,2.961656193701551754e-01,-1.027904413888633406e-01,-4.484761950432617494e-01,7.189298415616503235e-02,-2.300193209026286587e-02,-2.715536252884933055e-01,2.536660883616485562e-01,-5.414873387887237516e-02,-5.344215271245312815e-01,5.911552490024225559e-01,-1.922241216522392604e-01,-1.122233380052822943e-01,2.186175392618385782e-01,-3.307207748122670821e-01,-3.224036401722443212e-01,9.236861053955949807e-02,-1.825834803413127205e-01,-1.056214733207413159e-01,3.530386225478265166e-02,-1.219699843296718073e-01,3.992501793031227875e-01,4.146873596800776385e-01,-1.377278612572992167e-01,-7.771845253936703335e-01,1.608539736973514933e-01,5.334420255174306125e-02,3.658266316328757928e-02,-1.304774047924275177e-02,2.327656075950226833e-02,1.524085326156310836e-03,1.087390388314607020e-01,-2.794207577730853376e-01,3.873231082031461381e-01,2.504022045219221893e-01,-6.663993038674168035e-02,-1.248097563905060936e-01,-7.776328677239410236e-01,2.380576904974861241e-01,-1.054267854872287524e-01,-6.957956616159340080e-02,-4.537364297696729575e-03,1.238402925132453813e-01,9.650901297653467770e-02,1.138299534429106433e-02,-1.882393706381305792e-02,1.642581816956655005e-01,5.660542461926074687e-01,-1.336495933600265066e-03,2.057540435164535546e-03,-7.712986245109186845e-01,-1.804436847434553737e-01,-8.976657353635345428e-05,-2.404871024858646344e-01,2.105016296609119042e-01,-8.340919661588853951e-02,7.980753958691064742e-01,4.222000036723241173e-02,3.898760474482154126e-01,-1.588932003223423109e-02,-2.141466686142824358e-02,2.062938794250895047e-01,2.385780817163783152e-01,-2.932351923192321139e-05};
    cv::PCA pcaANN1_0_11;
    pcaANN1_0_11.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_11_pcaMeanLoad.data());
    pcaANN1_0_11.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_11_pcaEigenValLoad.data());
    pcaANN1_0_11.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_11_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_12_pcaMeanLoad = {3.453135648887399192e-15,-6.873951456360477740e-16,1.001166939366738334e-14,2.410558912708563055e-15,-8.910999238835261055e-15,1.309005947393364982e-14,5.808892978642282686e-15,-3.507899824617219147e-15,3.003800075891088212e-15,-1.546766262242228625e-14,6.410894913652624856e-14};
    vector<float> cluster1_0_12_pcaEigenValLoad = {6.721822520662413147e+00,4.064281554717129374e+00,1.999769053532355623e-01,1.154370158945173391e-02,1.909180869061382225e-03,4.051823469396495059e-04,1.295090337867693447e-04,4.627963064903755107e-05,5.850875597704449623e-07,3.899637054451880488e-07,1.313769664384038303e-08};
    vector<float> cluster1_0_12_pcaEigenVecLoad = {3.675758773339036778e-01,3.349485650084189081e-01,2.747453340281667544e-01,-3.678296957464274319e-01,3.731096447050181175e-01,3.656576299708075850e-01,3.650963933136542466e-02,7.935638739437726741e-02,3.555755605719244095e-01,2.643169694357780930e-01,2.550874568416389154e-01,1.497970686703603838e-01,2.450434866971104575e-01,3.326009542337895475e-01,1.181173863287751369e-01,1.017514473082196946e-01,-1.287766140101610779e-01,-4.840627224553299968e-01,-4.843006301541536440e-01,1.903655546029273948e-01,-3.560815349219838555e-01,-3.662044773882884297e-01,2.968168616670959284e-02,-9.095597479658029672e-02,-4.552024322597420514e-01,-4.082374272892335676e-01,-3.297801592995626696e-01,4.054033474127652359e-01,-4.369942864771727553e-01,-1.366322886626373523e-01,2.064072487242890955e-02,2.310372774138790275e-01,-2.836114902857535536e-01,-1.694980208081014739e-01,-4.262651852670287789e-02,3.639862305191579051e-01,-2.108380761757880639e-01,1.690531126931176797e-01,-2.865429324881367812e-01,-1.446820093890806846e-01,-1.748076233230066168e-01,-4.867309408730886577e-01,6.161793759405630455e-01,-1.172787374882479916e-01,-7.998860128406180825e-02,-8.813523498506717346e-02,-5.551879187061625059e-02,1.175383876776475538e-02,-1.034096945652893534e-01,-4.415487537627930947e-02,-3.693786482407909744e-01,-3.567620482166610207e-01,-6.191565226270489414e-02,-6.120508229873145717e-02,8.358653851992928763e-01,4.057185363083625207e-01,5.859018159310186435e-01,-9.210058722390136732e-02,-1.568050100240750422e-02,-4.064689773999539679e-01,-3.330109033700944798e-01,-1.450675644999522562e-01,3.230834724274643244e-01,-2.738671806715677337e-01,1.458912067880750209e-02,8.140172133941260546e-02,-3.739965014186273362e-01,-1.196215976406470038e-01,4.959050403485293357e-01,-2.851836775220131237e-01,-2.307474391367839717e-01,9.523870706836409794e-02,-3.161377318480552701e-01,5.290451285026456230e-01,5.405112215396418174e-02,-2.687762592241925708e-01,3.545341344868804812e-02,-3.990272247617312473e-01,4.465075433058947607e-01,1.751377356749287129e-01,-1.541481100625973211e-01,-4.276361114638999594e-01,2.016627744865542027e-01,4.530310417578889415e-01,-3.964293721903212053e-01,-3.111373522342440745e-03,-3.081707607807309540e-02,8.953110099014565879e-03,5.075378017220117943e-01,-4.071674870653606004e-01,4.307690033064601742e-01,2.444983918515961641e-01,-4.694656971747012131e-01,2.490563956013494007e-01,1.258036067507167788e-01,-1.068478389748130919e-01,-6.987319907628486426e-02,1.293297695479138365e-01,1.704499859205765779e-04,2.766819579148868669e-01,-2.804175476782219123e-01,-2.177328483443003240e-02,-6.887340526724587964e-01,-8.251439308202169684e-03,-3.632047486253003332e-01,2.719399862511586163e-01,-1.726365688446284963e-01,-5.615177843054701412e-02,-3.620639540253233202e-01,7.590459082763709652e-04,9.267625824333011741e-02,9.234015928038402654e-02,6.901228093531012932e-04,-5.444909709823907498e-03,2.839158000723366881e-01,4.967105563015554726e-01,3.187283528280424570e-03,-1.563971806560827613e-03,-7.142763168079595548e-01,-3.812105231087857815e-01,9.644335037150823610e-06};
    cv::PCA pcaANN1_0_12;
    pcaANN1_0_12.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_12_pcaMeanLoad.data());
    pcaANN1_0_12.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_12_pcaEigenValLoad.data());
    pcaANN1_0_12.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_12_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_13_pcaMeanLoad = {9.524564764445255092e-15,-3.412368576738491397e-15,-2.474209535501498156e-14,1.314390505979934725e-14,3.632242096230231548e-14,-3.405741445488717529e-14,-2.258557028193293705e-14,-1.102238454229995850e-15,4.574198627216184322e-15,1.345434131947939419e-14,5.764853785137134531e-14};
    vector<float> cluster1_0_13_pcaEigenValLoad = {6.615575244524586118e+00,3.076067094881862918e+00,1.298018383691762923e+00,8.690288856719243296e-03,1.449048981107027741e-03,1.595711629934177611e-04,5.165468748267104193e-05,2.921290480561398859e-05,3.299267481167044635e-06,1.850050964034303963e-07,2.026050974899361597e-08};
    vector<float> cluster1_0_13_pcaEigenVecLoad = {-3.803297731568295315e-01,-3.432374089679533502e-01,-1.134715298982584275e-01,3.581162097034568670e-01,-3.247585538631103663e-01,-3.643801068978241853e-01,1.122242708162887043e-01,-1.405025025725916699e-01,-3.723513304116566336e-01,-2.781314209022915374e-01,-3.314144167558541465e-01,1.161397738120292095e-01,2.634996036902971239e-01,4.806479539776631338e-01,1.621177666225017688e-01,2.449830465681566705e-01,-1.452880572928131608e-01,-3.181305449356835457e-01,-5.023873354370583799e-01,1.624505908132434229e-01,-3.783227680091534872e-01,-2.356505537874415412e-01,3.002265624444106634e-02,-7.296470183621688033e-02,-3.952557605229316540e-01,-2.330551413860051102e-01,-3.004790720669130999e-01,2.082073169851374195e-01,-6.828280335691729874e-01,-2.671170528105230035e-01,-2.301170916788693090e-03,1.838953490273017577e-01,-2.795828670305828823e-01,-1.963723431913052819e-01,-6.849302772657221705e-02,3.988301466622882208e-01,-1.513116697870132421e-01,2.210287693399430597e-01,-2.111132340528539819e-01,-7.590709769501062520e-02,-1.644341939539790409e-01,-4.246438807742111687e-01,6.830872804070311499e-01,-4.040094626603931566e-02,-9.818128869612338661e-02,-1.413223853701504884e-01,-4.390666135309491402e-02,1.175255370636935220e-01,-9.767997457889764090e-02,-1.053016977016488637e-01,-2.523916500686991249e-01,-3.158704940429041819e-01,-1.014140534743922656e-01,-1.076167308946077011e-01,8.652610364251549502e-01,4.507461499250836612e-01,5.173535317790626253e-01,-5.564657766436806319e-02,1.557640464813330183e-01,-3.017149462364707158e-01,-4.330617070132523616e-01,-1.690499426661461746e-01,2.836317358070282735e-01,-3.291088919427203052e-01,5.997298785456935816e-02,4.801701924771683422e-02,-3.917149696114927138e-01,-4.059119249088118803e-02,4.518346431672920493e-01,-1.573441426824080391e-01,-1.869283213368091723e-01,6.329930507724430833e-02,-4.265319595598674463e-01,5.855715858494426884e-01,2.661106922046366924e-02,-2.225510866149510159e-01,4.461260463184232861e-02,-3.993918578184961765e-01,5.665777621269173503e-01,6.074789626898375455e-02,-3.427519651411466417e-01,-4.353072095585706625e-01,1.169321430220727487e-01,3.220957533974507792e-01,-2.978199726870196518e-01,-4.697817360722856064e-03,-2.867815708832747307e-02,4.305992832099495710e-02,4.674551852576879774e-01,-3.587031626729177414e-01,4.755672845046095554e-01,9.224058761436962350e-03,-5.630402232957836262e-01,2.389679297761031496e-01,1.725797864727042219e-01,-1.274850641200412082e-01,1.752074401678300683e-02,7.811991998756703803e-02,-1.574280839275434257e-03,2.167450314405870715e-01,-2.354996685027530290e-01,-4.213581577218313695e-02,-7.666968153926956298e-01,9.599782635049229629e-02,-3.938425822350348215e-01,8.026588725474415043e-02,-3.756652118368036808e-02,-1.346334237995439054e-01,-3.430003174473776340e-01,2.295383980860536688e-03,-1.055389502539658825e-01,-9.125867469344660365e-02,-5.448673074495395544e-04,6.389121732511817038e-03,-2.100858705866256171e-01,-5.741698049433553441e-01,-1.283795941189172724e-03,5.039671988823991779e-04,7.189407101095016683e-01,2.996791305864108801e-01,-2.258366916595035332e-05};
    cv::PCA pcaANN1_0_13;
    pcaANN1_0_13.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_13_pcaMeanLoad.data());
    pcaANN1_0_13.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_13_pcaEigenValLoad.data());
    pcaANN1_0_13.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_13_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_14_pcaMeanLoad = {4.404190510909712018e-17,-1.468063503636570673e-17,1.295566041959273508e-15,-1.027644452545599471e-16,-2.422304781000341363e-16,-7.670631806501081642e-16,-9.826850077467293739e-16,-3.229739708000455480e-16,4.404190510909712018e-17,-7.707333394091996032e-17,-7.156809580228281660e-16};
    vector<float> cluster1_0_14_pcaEigenValLoad = {6.169159986790604400e+00,3.329325537131734070e+00,1.055832753349769337e+00,3.887224911533945226e-01,4.306743247427254756e-02,1.904188509437307678e-02,1.296747492747267819e-02,4.170563156033413148e-03,4.862029817440217212e-04,4.248888051844619560e-11,2.026996916926726095e-11};
    vector<float> cluster1_0_14_pcaEigenVecLoad = {3.376625383996144647e-01,3.178738929703369132e-01,-2.892481553465141020e-01,-3.413873288063851708e-01,-2.212030525788079294e-01,3.579954801035343248e-01,-1.128744499779594790e-01,1.731016384765620697e-01,3.820087170843923241e-01,-3.478454311065913296e-01,-3.130605658214685172e-01,-2.103126567333092334e-01,-3.223266625622975279e-01,-3.450813287803328744e-01,2.840108973978437423e-01,-4.248528438148470587e-01,-1.034079533605022777e-01,4.658584947365392859e-01,2.031974057644408138e-01,-1.625712166089096078e-01,-2.558346408535210892e-01,-3.327815578303359723e-01,3.415357439194235400e-01,1.375813598860203546e-01,9.511540175053814772e-02,1.257105074958302050e-03,2.275327960882264355e-01,-2.977888848388502430e-01,2.240620223042753545e-01,7.963368753118958976e-01,-3.848787228737315935e-02,1.635560095470423025e-01,4.836009152115792326e-02,2.054174342110928198e-01,9.500274443859380025e-02,-4.402033660691793138e-01,1.920596095749609045e-01,-3.233779047448455124e-01,-4.405286484914782696e-01,-6.008598091733716728e-01,1.508041176621386249e-03,-1.758496906977121133e-01,1.430281679711070675e-01,8.401514568188098164e-02,3.709175265743032135e-01,1.887446003908683501e-01,1.533346428412041274e-01,3.947333143538150207e-02,1.408887179673505574e-01,-3.851707227784848531e-01,2.131959860125841044e-01,-4.385912464045692016e-01,-5.110158371184678888e-02,9.455060881781905679e-02,-6.198014938808962260e-01,-2.999114481490059991e-01,-2.105399118277923587e-01,2.898399112685153267e-01,6.395339214024851893e-02,1.321477538607355451e-01,1.102507197900467750e-01,-5.342650933120000056e-01,3.109928819112601217e-01,-7.380149645653663604e-02,2.888028164540401219e-02,-5.996449900761046115e-01,5.530343473256498221e-01,-7.293192089346218765e-01,-6.342213024895025641e-02,4.290083257886014717e-02,2.578896162487973043e-01,7.709205780545090592e-02,-1.157943744253915330e-01,-6.947731401955818675e-02,2.411612552003934012e-02,-2.433332097150789630e-01,7.684622175412161860e-02,2.450418750418420222e-01,-6.696653418846336414e-02,6.780065999061122284e-01,1.467285118388678318e-02,-6.708254379751856789e-01,-3.475105139911264379e-02,-3.768021685433755458e-02,2.618850782767784269e-02,1.633292819740911382e-03,-9.038877042533217943e-02,1.186123211974211833e-01,1.452221119833625174e-01,-2.400187154509803855e-01,-1.505833027628391274e-01,-2.168687865196233244e-01,-2.363878661886176513e-01,3.366164254974526870e-01,1.152317433358764492e-01,-3.906308535385153032e-04,-3.084779933305974858e-02,8.062407670060365295e-01,-1.347220962579656067e-01,-2.604645376564665438e-01,-3.039672200689692572e-01,-1.636576414839633481e-02,-6.055137548013375115e-01,-6.722323380418365746e-02,-5.447759188820366916e-01,-8.425146421871433514e-04,-4.642368318934996755e-05,4.139390750160317767e-01,1.419061135169305717e-02,-6.210301082413651899e-06,-2.364687388591129799e-02,-2.756628766783375539e-02,1.585136331578627933e-02,5.869591943803866840e-01,-3.993877681922732644e-04,-2.546318467006400063e-02,5.027498423800837586e-05,1.485809583545304311e-06,7.837704237394443885e-01,1.973928838826145282e-01,-1.696945176073081985e-06};
    cv::PCA pcaANN1_0_14;
    pcaANN1_0_14.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_14_pcaMeanLoad.data());
    pcaANN1_0_14.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_14_pcaEigenValLoad.data());
    pcaANN1_0_14.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_14_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_15_pcaMeanLoad = {-2.958002022153955490e-15,1.783714530451020889e-15,-1.245709649831483283e-15,1.949157469221197826e-15,-2.161637075780227899e-15,2.118783780903098729e-14,5.176240764089037364e-15,9.024733623130502558e-16,-2.575822527002517150e-15,-6.600374421901699487e-15,3.769182205007769965e-14};
    vector<float> cluster1_0_15_pcaEigenValLoad = {6.868260874560546014e+00,3.438838712551281152e+00,6.723803484382876450e-01,1.707761206884526525e-02,2.942399920452469942e-03,4.617706071158842233e-04,1.154074462614107743e-04,7.152578747277316400e-05,1.364358158264731572e-05,4.233780737583402542e-07,5.960729430361736521e-09};
    vector<float> cluster1_0_15_pcaEigenVecLoad = {3.782348129259566760e-01,3.398618906730666578e-01,-2.178359997387853408e-01,-3.468389802696106861e-01,-1.572424753460205105e-01,3.466097224626399909e-01,-3.747552256976909302e-01,-2.554039292830420083e-01,3.761168309618860839e-01,-2.855958657405162082e-01,-1.084017720946622507e-02,-3.291625954667845924e-03,2.223881078717639126e-01,4.356010341913893469e-01,2.205985986642299279e-01,3.904554959004960524e-01,-2.212394557011750085e-01,-6.462500554873280845e-02,-3.816306193834925753e-01,1.920691278006849897e-02,-3.535484430501903419e-01,-4.853190423234500783e-01,-1.595228714441396245e-01,-2.319191711051789284e-01,-1.783857296270204562e-01,7.155044469218441172e-02,-6.726841807023044018e-01,-9.709432142945287336e-02,-1.686582774312638255e-01,-2.716907243756145895e-01,-1.994762318227913944e-01,3.605323636267331738e-02,-5.277704382557276697e-01,-8.030780009985809265e-02,1.181307360833237230e-01,5.175790380397116835e-02,-4.143184460658804746e-01,3.023616781893275207e-01,-3.318492168318273091e-03,-3.084550471324709608e-01,-1.806856130846596076e-01,-1.310736426382024256e-01,7.285307707034652802e-01,-1.951777234155104845e-01,-1.404822351486301191e-01,-5.438445465240945853e-02,1.874187211786838003e-01,1.139657700165735421e-01,-1.320615261210655311e-01,-1.889280350400001918e-01,-3.040797534304888750e-01,-5.616302379694606550e-01,-1.567112572781761692e-01,-1.909030063552371106e-02,6.657651022894930382e-01,3.573802068058537507e-01,6.416534295888451922e-01,6.666996450812068264e-02,2.095770731009108725e-02,-3.324286458878644157e-01,-4.816500553443018307e-01,1.823985375932285491e-01,1.276150675881151386e-01,-1.767193715545169741e-01,1.706888931978088608e-01,5.710785814295141205e-02,-6.230165252659978226e-01,2.890410642952143672e-01,3.354114458440404789e-01,-3.600651289001773891e-01,-1.998595344395981688e-01,3.734614672554071452e-02,-2.061410727311897839e-01,3.637404031869586607e-01,-4.514923509889196690e-02,-2.595333949670713958e-01,2.494213004728643157e-02,3.842954349591957142e-01,-2.228529111694561027e-01,5.376999284394132772e-01,2.751036870722550765e-01,-1.673861164474420016e-01,1.290349848600575444e-01,-4.801417590997774654e-01,3.605819471183843716e-01,7.890202699200021819e-02,1.606878407495503369e-01,-2.409660191429563447e-02,-1.518292156393525605e-01,1.947018044890319877e-01,-5.327200831498534184e-01,4.077659425774070034e-01,2.409531802103374309e-01,-2.071287445275821482e-01,-5.543195095268164119e-01,2.618489149505165425e-01,-8.862412600870810120e-02,-6.573775004862582316e-02,-1.983288103620656044e-03,-2.883058672102488118e-01,4.106515291492244257e-01,5.757859683554651664e-02,5.188740592328445755e-01,-1.338087037006425450e-01,5.175639452446723077e-01,1.604907640104954458e-01,-1.416273679055371493e-01,2.044009017790492655e-01,3.198846079415741950e-01,-8.775302889196328563e-04,-1.885997766046379198e-01,-1.134355829146379280e-01,-4.159579370382811715e-04,-1.671950720672836467e-04,-8.377659130092042494e-02,-4.743167606507010525e-01,-7.881542426517335618e-04,2.144578438570529568e-04,8.291622609714530689e-01,1.790437457382371700e-01,-6.897535261693469616e-06};
    cv::PCA pcaANN1_0_15;
    pcaANN1_0_15.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_15_pcaMeanLoad.data());
    pcaANN1_0_15.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_15_pcaEigenValLoad.data());
    pcaANN1_0_15.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_15_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_16_pcaMeanLoad = {-2.865602387980796350e-15,-4.282747436327836800e-15,4.627182640481698092e-15,4.403950631252255143e-15,1.675735319085639474e-14,-4.245805969079465781e-15,3.964523082745438901e-15,2.352819640223643157e-15,7.469916501118265102e-15,7.347306012203432670e-15,-1.980308920961020079e-14};
    vector<float> cluster1_0_16_pcaEigenValLoad = {6.840673221545129579e+00,3.984329583424528032e+00,1.591310231581475332e-01,1.168291175109698217e-02,3.103502843803484287e-03,9.275040002362568712e-04,2.131824255153024297e-04,2.011046220534433058e-04,9.227775991370861330e-06,1.071285021972765668e-06,5.065534704486230834e-09};
    vector<float> cluster1_0_16_pcaEigenVecLoad = {3.807226640992578126e-01,2.422038664636083360e-01,-2.448012044621208361e-01,-3.275319404411067281e-01,-3.102103474027908536e-01,3.053560870512970760e-01,-3.749177356738579991e-01,-2.398574865095174924e-01,3.788887473585875743e-01,-3.018395703321919976e-01,-8.337390125346549885e-02,-4.444925260744605339e-03,3.794526185254730177e-01,3.830442681662507010e-01,2.561539022281729139e-01,2.691566448387408550e-01,-3.006742124418479989e-01,-8.908840741515010320e-02,-3.867802028240831524e-01,1.164919387493889777e-02,-3.054878773942057424e-01,-4.793889046049312763e-01,2.227901935760676078e-01,3.889523104109793850e-01,1.831083121443108364e-01,-1.012121974096231170e-01,5.724307534751147397e-01,1.044482890008243958e-01,1.718494670672803815e-01,2.388903695722862652e-01,3.264910088846393887e-01,-5.147336017795340474e-02,4.699733191320299430e-01,-1.610076988782523644e-01,2.276464907674241589e-01,2.986661233593440948e-02,-5.074114239316114272e-01,2.437721711097619870e-01,-4.171347662777818988e-02,-3.901315439890494230e-01,-1.524895437486668837e-01,-1.828955549568532513e-01,6.185954072212925814e-01,-1.056579315921168521e-01,-1.234183826092159625e-01,-1.280168269569900985e-01,1.421351670706527126e-01,1.638416231895429287e-01,-5.517855505493297202e-02,-1.045633665652438010e-01,-3.193188583489990351e-01,-5.499783298820091204e-01,-1.065144894983951207e-01,-9.253531568244130479e-02,6.949864195207915429e-01,6.973018400375398385e-02,5.808157058182606969e-01,4.280254356692504702e-02,-3.126322950258041133e-02,-5.132935865028311895e-01,-4.282147158101305418e-01,1.694206417993269348e-02,2.976524274766781386e-01,-2.714635890078671565e-01,-9.684749701618750387e-03,2.132438642080137503e-01,-7.633185552972435728e-01,1.129516644249550228e-01,1.133024032698693173e-01,-1.336471984450130768e-01,-1.881667053473235970e-02,2.402651591287278121e-01,-2.531446523420186057e-01,3.023525154301147655e-01,7.304540435610309967e-02,-3.935371213179296723e-01,9.996353006761365262e-03,2.706129330809068367e-01,-1.596579289210865171e-01,5.923101122109141192e-01,2.870314648716884021e-01,-1.624752709245645965e-01,2.013669164095449604e-01,-4.711145783798920683e-01,3.491174299457034391e-01,8.328899163231243130e-02,2.184806700415678482e-01,-5.108836931325953096e-02,-1.419773079350171267e-02,1.715072142526766763e-01,-6.096684189883984084e-01,5.502261461561237521e-01,2.512321444601640086e-01,-6.400937660953706643e-02,-4.310890252921066312e-01,1.883266084035041810e-01,4.238159601553426886e-03,8.599563096770976300e-02,-2.578074391161662600e-03,-2.306121893160048841e-01,3.980900528537330563e-01,3.911536477256603861e-02,3.585786531115117137e-01,-2.509161955724572568e-01,5.017825891133581573e-01,3.092642295721379497e-01,-2.696437008144716430e-01,1.492476534059509474e-01,3.909745811464942489e-01,-9.421038913081822242e-04,-2.238459663904092400e-01,-1.198825810392730590e-01,-1.745536405031127133e-04,4.236217456840886430e-04,-1.577295619920862646e-01,-5.052157258588869659e-01,-4.969580207978682371e-04,4.309485461352190030e-06,7.724358372077373414e-01,2.423675436049870791e-01,-2.575293396334508039e-06};
    cv::PCA pcaANN1_0_16;
    pcaANN1_0_16.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_16_pcaMeanLoad.data());
    pcaANN1_0_16.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_16_pcaEigenValLoad.data());
    pcaANN1_0_16.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_16_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_17_pcaMeanLoad = {1.752983723092352458e-16,1.370514547144930086e-16,6.416982840895641588e-16,-7.075679755027313397e-16,1.313144170752816779e-15,3.697202034158416103e-16,-4.908354424658587277e-16,-3.399726008421531857e-17,6.055761952500853409e-17,-3.187243132895186232e-17,-3.085251352642540405e-15};
    vector<float> cluster1_0_17_pcaEigenValLoad = {7.036243462760351619e+00,2.313285959820783777e+00,9.949912067432195029e-01,5.565792458009387600e-01,1.154020750152424390e-01,2.045048504694809907e-02,1.187358702411484696e-02,3.558030623091690443e-03,5.005624864480517303e-04,5.152362681277207580e-11,1.194692796447796000e-11};
    vector<float> cluster1_0_17_pcaEigenVecLoad = {3.681915189291046220e-01,3.365394626785480070e-01,-3.097572839566284930e-01,-3.520170327892324647e-01,-2.139682457776393987e-01,2.881366628061099999e-01,-2.604441993730930993e-01,-2.797124218713174792e-02,3.667449385306703058e-01,-3.518111062649048604e-01,-2.749891027855533854e-01,1.220023748148224563e-03,2.689644205684947886e-01,3.558703011740637634e-01,-2.199667947000101820e-01,4.894559673990910298e-01,3.070262661438227236e-01,-3.284883194396908679e-01,-2.734232337922883893e-01,1.346844628249641018e-01,1.916398643849155092e-01,4.257519640865226052e-01,-8.058536484420561474e-02,-1.087106165925914164e-01,-1.736837941418028497e-01,1.353654627227678653e-01,-2.799026845209451886e-01,-1.311454249395677951e-01,-2.165969912366508265e-01,-8.823756996080951431e-01,-1.096087882400353236e-01,1.114470064871349829e-02,-3.751532898427811444e-03,1.868614102224266382e-01,1.828610827684585272e-01,-2.816127331892478644e-02,4.346990172912068573e-02,-2.091444845038590850e-01,-5.383601662073699279e-01,-6.344723226897595048e-01,2.874760303738548850e-01,-7.881394915121874012e-02,2.853403281627042709e-01,1.502016191466656603e-01,-3.991799764157547004e-01,-3.696758671369550914e-02,-1.835045892962753333e-01,1.037494863922150123e-01,-4.609151572524554097e-01,4.426117797745103277e-01,-1.640133474476126729e-01,2.178255842397355813e-01,-6.526570776799868467e-02,-1.368071298170798755e-01,5.377533982152287173e-01,5.684097498385268787e-01,-4.508046969648938918e-01,1.188592193197759994e-02,-1.362844632516598542e-01,-5.650460093489582253e-02,-1.752986296811822331e-01,1.863400241127359247e-01,-4.657085622035764261e-02,1.613149991326471577e-01,-2.205805983447853280e-01,5.563080022588867690e-01,1.700773653150096029e-02,-7.015498150386422216e-01,2.140603403336348645e-02,4.635700859025566889e-02,2.195875164088318676e-01,2.648947645694925690e-01,-5.314783873895836397e-01,1.140883183413774482e-01,-3.500804714050446964e-02,-5.728772043656794183e-02,-2.941948721482331441e-01,-7.775945043421561564e-02,3.639525050249482752e-02,-8.114218464663999208e-01,6.921050420798879887e-02,5.327010805042136088e-01,-1.023779056155604966e-01,-3.433162472956633620e-04,2.398597919090686079e-02,-4.392265245781595828e-02,2.054442362707338196e-03,1.807562028496801088e-01,1.963314607909776577e-01,-1.522737408733408349e-01,-2.311002676180554105e-01,-2.323606874206680939e-01,-2.082702091857397964e-01,2.940710636257559685e-01,1.752174152047303590e-01,-4.438212884745536789e-03,4.014030724354916008e-02,8.161008319202999184e-01,-5.158410263707966653e-02,5.342513275479833235e-01,2.149516419764541386e-01,1.493595713953055869e-02,6.644763208162703938e-01,3.931903579657291398e-02,3.455869851572948570e-01,1.156458486336585335e-03,4.897228655130763682e-05,-3.249658293026431721e-01,6.242270223214897371e-03,-7.152155253567613818e-06,1.013987833936303845e-01,4.078506731907938915e-02,-1.176345858584589184e-02,-5.250604060757629865e-01,4.047260897887396819e-03,4.987905986911838480e-02,3.591164114838711011e-05,4.960474676450798793e-06,-8.297479024958842597e-01,-1.457469453502530099e-01,1.428126525481984840e-07};
    cv::PCA pcaANN1_0_17;
    pcaANN1_0_17.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_17_pcaMeanLoad.data());
    pcaANN1_0_17.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_17_pcaEigenValLoad.data());
    pcaANN1_0_17.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_17_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_18_pcaMeanLoad = {-6.618683756659163627e-15,2.940600205118363905e-15,-9.814021712249626749e-16,9.285258538576151032e-15,7.169287383276085564e-15,-2.321556405891834683e-14,1.472674593361567579e-14,6.829808135112471825e-15,-4.843934223319686269e-16,-1.597219202233687751e-14,-7.278843525462157710e-14};
    vector<float> cluster1_0_18_pcaEigenValLoad = {6.681402685793831786e+00,3.185438063436746958e+00,1.108467110845743120e+00,2.211680892343513560e-02,2.339740106766436279e-03,2.398202238112061041e-04,3.459449906357056078e-05,3.103087463406749557e-05,1.354354874510111044e-05,2.344538838043427137e-07,7.942689291283217631e-09};
    vector<float> cluster1_0_18_pcaEigenVecLoad = {3.863853251518369891e-01,3.748650553713704925e-01,-5.822122341916103477e-02,-3.496246065101962786e-01,2.417488296699522587e-01,3.584398242544364344e-01,-3.543823335552505616e-01,-1.972702945592010038e-01,3.863687994272458903e-01,-1.593782839206043245e-01,2.417626856416971448e-01,-2.412603804944916247e-02,1.300333076319080683e-01,5.231445440602198182e-01,2.361465131395843464e-01,3.350418674163926358e-01,-2.089849986579297991e-01,4.291245292154001467e-02,-3.776168126833566174e-01,7.036336213972962418e-03,-5.060144131047056293e-01,-3.108055160813084083e-01,-1.904968901253308033e-02,-7.949079705442008148e-02,-3.054782409980721924e-01,-6.568854644791292940e-02,-4.741946414554987776e-01,4.466568776865847273e-02,-3.731503135515999992e-01,-5.060550487208393955e-01,-4.305854466103387762e-02,-3.354515757439478080e-02,-5.201140406881755718e-01,-7.484885825795484227e-02,7.421277396319035657e-02,3.074341124160664407e-01,-1.911766155391586841e-01,3.427212239142504169e-01,-7.348881049352887218e-02,-1.647306403536431818e-01,-2.432049038419290821e-01,-1.182317764917962810e-01,7.784649040463874625e-01,-1.693997322153438234e-01,-1.554342699318906895e-01,-1.231904121816387032e-01,1.012842269798767958e-01,1.361237722361162972e-01,-1.918935219282560112e-01,-1.864027385430360728e-01,-1.806498962635200989e-01,-5.005263399621413534e-01,-1.785167731677052283e-01,-3.913184640478450764e-03,7.384189028241531227e-01,-5.305609706981758711e-01,-5.706308859882975870e-01,1.217991601411293201e-01,-2.002513731619204040e-01,2.250664576653255144e-01,4.569453192942846687e-01,-1.787980763455611077e-01,2.649086741108643006e-02,1.436921693721337212e-01,-1.586052360232489689e-01,-4.720876910350987887e-03,-5.154538477267974761e-01,4.304634829391073003e-01,-1.873697025263080240e-01,-4.680134776312281919e-01,-2.448819366559324556e-02,-2.070597846652799667e-02,4.837752164614939066e-01,-2.222947542280797051e-01,-4.006377611854994997e-02,-9.125785512468841121e-02,2.120308417459529707e-02,-2.454101504173021586e-01,3.309000106902656446e-01,4.697288642231799982e-01,-2.155464238203238236e-01,-4.084092056849230601e-01,-9.305486821834739464e-02,-4.423561541853551216e-01,4.164719013828916960e-01,-9.262697063710188805e-02,-1.000428501229485428e-01,3.836230152923831736e-04,3.220209403504493695e-01,-1.988075890707311499e-01,5.029038080927743515e-01,-2.079189275679923787e-01,-4.523531388361308192e-01,3.011878976054563339e-01,4.586309856736228707e-01,-1.623121154970302016e-01,1.398259235884882767e-01,9.517346851630113791e-02,-1.068698126395181951e-03,2.907304771513366526e-01,-3.782221642222770575e-01,-3.659024510451171219e-02,-6.432546068880391488e-01,1.283476881566742722e-01,-4.872096840501495829e-01,-3.913009719988664453e-02,5.303044096136213387e-02,-2.351548859705081262e-01,-2.093337128822042592e-01,4.770945274944160498e-04,1.560891067014827938e-01,1.121411192864136125e-01,3.979661498882685494e-04,-1.891565967950206316e-04,1.049465521760942627e-01,4.896224628138112211e-01,4.825074765771678867e-04,-1.087226387911464508e-05,-8.350372450199812224e-01,-1.225928120527719073e-01,1.516491053311281700e-06};
    cv::PCA pcaANN1_0_18;
    pcaANN1_0_18.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_18_pcaMeanLoad.data());
    pcaANN1_0_18.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_18_pcaEigenValLoad.data());
    pcaANN1_0_18.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_18_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_19_pcaMeanLoad = {1.871333201573575198e-14,5.383390613985405744e-15,2.740950484676271609e-14,-1.656704788778378567e-14,5.363062480791069921e-14,2.405588517831069517e-14,1.745047831562615738e-14,2.263975426137667527e-13,-9.271721512145525390e-15,4.389264872479620666e-13,-5.689635793720831456e-14};
    vector<float> cluster1_0_19_pcaEigenValLoad = {7.496034411437166867e+00,3.207076013502395018e+00,2.956477702274135089e-01,9.770778295783238108e-04,2.522489045799695788e-04,2.417913734243568963e-05,4.448777258864868877e-06,1.616481196196199595e-06,4.293738813064932429e-07,4.602795761418725924e-08,3.160675462369047020e-08};
    vector<float> cluster1_0_19_pcaEigenVecLoad = {-3.644527282241287747e-01,-3.535272542721408784e-01,-5.883633961362074588e-02,3.392606830177705701e-01,-2.877556824099851140e-01,-3.463438934399248326e-01,2.391142462685210135e-01,-1.937530258079331602e-01,-3.632082208600837525e-01,-2.752043677325206050e-01,-3.442415208773027535e-01,6.075911031984477162e-04,1.262873045417373385e-01,5.423635777622752840e-01,2.065996400563176461e-01,3.383496811423574169e-01,-1.772736050188307155e-01,4.205470784076308921e-01,4.031201762534036281e-01,3.741234081794417299e-02,-3.550439588657290368e-01,1.856917617783137020e-01,1.200991256949653918e-01,2.011960865603957538e-01,3.210757559146504292e-01,3.296467418172630698e-02,2.022124279851812145e-01,-6.412525427211789898e-03,-1.191378242392947678e-01,-8.171050217804515237e-01,1.490667754261585931e-01,-3.047291296230659752e-01,-5.526168388593268033e-02,-2.383219461376364923e-01,-9.394364737158254763e-02,4.340353700717556884e-01,-9.834877351145397684e-02,2.497661793757091908e-01,-1.250129713950841326e-01,1.059483530056369305e-01,-1.604854088527173928e-01,-2.398212839893007764e-01,7.460686675197092388e-01,-8.481359052681074207e-02,-1.054538376722000681e-01,-1.563370509837810340e-01,-7.208289965678285616e-02,9.786791467341628137e-02,-1.533300654611680913e-01,-1.185316020733217374e-01,1.807012337907473384e-02,-2.223073193959451688e-01,-1.648184743150980791e-01,3.339023357975198086e-02,9.132782604497051704e-01,6.378942938737258705e-01,3.756643480717127281e-01,-1.386941218026868372e-01,3.073199409417675110e-01,-1.145642841020197977e-01,-4.451634739620761172e-01,7.957013556465478143e-02,-2.252155902620116279e-02,-2.520323205422102530e-01,2.338665611779963405e-01,-4.401797401599257670e-02,-5.291080578341429419e-01,6.061839512789887197e-01,-2.173613477296940377e-01,-1.219151050157410432e-01,2.049988839400240515e-01,-3.271722569933098179e-01,-3.023757689864211007e-01,8.116270256203490796e-02,-1.805214516365946376e-01,-1.002744817336188171e-01,2.736325494018345544e-02,-1.126008088961451548e-01,3.876155258849076635e-01,4.488466990405520218e-01,-1.278524517870262556e-01,-7.686817879092131545e-01,1.581098724850310555e-01,2.740508873268765466e-02,4.439585062000371563e-02,-1.814070460851076663e-02,1.854854211335929537e-02,2.576855915881635581e-04,9.919736745689960999e-02,-2.636351403307680141e-01,3.589228235911067211e-01,2.653395731186369289e-01,-2.395979552376299379e-02,-1.307692078237053801e-01,-8.010646647916983554e-01,2.177530642184366261e-01,-1.036909729243043199e-01,-6.223085948458416394e-02,-2.358666167592486478e-03,1.251663151243919414e-01,9.757411816360996026e-02,6.807169899643171658e-03,-1.130528185418124346e-02,1.668006760990253246e-01,5.622973571395279979e-01,-4.605131528026844192e-04,1.093553790661721571e-03,-7.769531655192077890e-01,-1.642562723923535750e-01,-4.803056984682862503e-05,2.445036697102472845e-01,-2.178778848331516527e-01,9.428913892709024636e-02,-7.910079083987028303e-01,-3.892679187013196873e-02,-3.942220600331752256e-01,8.762212473176012387e-04,2.517879783466182853e-02,-2.212112434970576469e-01,-2.273054003511522647e-01,-5.731898076573768269e-05};
    cv::PCA pcaANN1_0_19;
    pcaANN1_0_19.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_19_pcaMeanLoad.data());
    pcaANN1_0_19.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_19_pcaEigenValLoad.data());
    pcaANN1_0_19.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_19_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_20_pcaMeanLoad = {-4.794120087129361862e-15,6.270753860359753981e-16,6.616613499149946571e-15,5.330931129444897339e-15,1.981402784739658253e-15,-4.428900212048310122e-14,-3.234917985183077896e-14,-2.924400903959236821e-14,-6.239403384175202299e-15,5.085639174959432840e-14,9.623891461566912690e-14};
    vector<float> cluster1_0_20_pcaEigenValLoad = {6.516516568000951359e+00,3.128881617105881752e+00,1.337699008781833232e+00,1.514378861848987047e-02,1.613811342935876896e-03,1.348757915202444878e-04,3.453922625054725755e-05,1.933177699118811353e-05,7.232603216139490046e-06,1.954394987279902359e-07,1.270422013984687315e-08};
    vector<float> cluster1_0_20_pcaEigenVecLoad = {-3.890422495422399818e-01,-3.600865959824253171e-01,1.762460547883590301e-02,3.670180719447835305e-01,-2.591348035206409994e-01,-3.755669771242874377e-01,3.182578074421464343e-01,1.771888013669703152e-02,-3.847184246535018115e-01,-1.109217309524812012e-01,-3.374249420745999983e-01,6.440855714781199004e-02,2.218771180393142861e-01,5.449632404785742512e-01,1.904296416920874813e-01,3.823885083767020188e-01,-1.542247722162101431e-01,9.060625284266594914e-02,-3.588612462701701311e-01,1.055287202486188958e-01,-5.382684219954207983e-01,-7.421156649471549738e-02,1.612239069553008178e-02,-2.656858185288171054e-02,-2.225509386628087838e-01,-8.003464198895893222e-02,-2.781124742958571150e-01,6.680680234579100540e-02,-4.846419910458315550e-01,-6.662346568460923990e-01,5.571428611772051218e-04,-5.831030728350367065e-02,-4.232530422201273845e-01,-1.404043265222562897e-01,1.384487088382900175e-02,4.050065130816870029e-01,-9.577324244627813399e-02,3.008155706253589079e-01,-1.600586800467745929e-01,-4.704729805850600688e-02,-2.590885409376511572e-01,-2.010238111515012804e-01,7.592903830882732352e-01,-6.716090862835946695e-02,-1.227764869198137432e-01,-1.415018216566360509e-01,-2.072677498573328309e-02,1.355019077499668434e-01,-1.940501621614008909e-01,-1.548504736217172217e-01,-1.202903881785641060e-01,-3.789891943342603153e-01,-1.660241476114229786e-01,-5.468553996627551622e-02,8.341591905174777777e-01,-5.772665974364790120e-01,-5.058737790186861316e-01,1.889134176343463534e-01,-2.466741488764256918e-01,2.022756718515586749e-01,4.400057518910564514e-01,-1.321844655436314742e-01,2.873897919289863587e-02,1.843063491146647304e-01,-1.643737705916304692e-01,2.262393291321474625e-02,3.446724907605609456e-01,-3.764190368691492927e-01,2.728026516744980756e-01,3.655267206749868714e-01,3.060189973334574709e-02,-9.752939170040765549e-02,-6.337790870013869649e-01,3.411974404562707064e-01,-4.916282163960179058e-02,6.277692255341957295e-04,-2.282657167942201554e-02,-4.978728429917258502e-01,5.419801496791050166e-01,8.561605511003092528e-02,-1.772869389823271968e-01,-1.166901263286889839e-01,-2.488244221221059260e-01,-4.448728590237420177e-01,3.118390104640713645e-01,-1.698076351584378030e-01,-1.413663200835731104e-01,1.071003065252912681e-02,1.424267800675802220e-01,3.829506052865181559e-02,6.093214342408048712e-01,-2.020355853662892109e-01,-7.030340288807975790e-01,2.174479340410743478e-01,1.471248363002956028e-01,3.085619488262348123e-02,3.489240376554906403e-02,2.805986454585995826e-02,-3.742303852534203598e-03,2.653893612054702977e-01,-3.093646542987590342e-01,1.779720752108250289e-03,-7.269033158042172982e-01,9.481532561277683513e-02,-4.430743583806922015e-01,1.533080556429619948e-02,2.896639018705717689e-02,-2.269794239825534410e-01,-2.181092740682493425e-01,4.086137198645733320e-04,1.371866421918090384e-01,1.080407196761274669e-01,4.382036699644098693e-04,2.743603380079910311e-04,1.497359673991215390e-01,5.219908410973020940e-01,3.375164314519630226e-04,2.219649239395368354e-05,-8.092730918676587226e-01,-1.403153982221344853e-01,8.260038036044392172e-06};
    cv::PCA pcaANN1_0_20;
    pcaANN1_0_20.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_20_pcaMeanLoad.data());
    pcaANN1_0_20.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_20_pcaEigenValLoad.data());
    pcaANN1_0_20.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_20_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_21_pcaMeanLoad = {-1.674340981767941347e-16,5.883066946867684717e-16,-5.123666392295340070e-17,-6.624168692896118176e-16,7.637465216015240820e-16,-4.227024773643655666e-16,-1.701789194583809299e-16,1.486778194192844130e-16,-3.385279580623706795e-16,-4.039461986068557857e-15,4.453929999588163506e-15};
    vector<float> cluster1_0_21_pcaEigenValLoad = {6.275492775462420347e+00,3.772762543515751688e+00,8.860938240507119090e-01,5.142859570024187893e-02,1.077793351084020169e-02,3.363898092002735006e-03,2.350174361150206975e-03,4.825319165102756234e-04,8.086876224268020120e-05,4.453618245726829045e-07,1.988043148951052693e-10};
    vector<float> cluster1_0_21_pcaEigenVecLoad = {3.940672288136292112e-01,3.851963905201182814e-01,-1.516355296042672107e-01,-3.631985106152947340e-01,7.145663346034971525e-03,3.305653573432137948e-01,-3.876088444416093126e-01,-2.292811018212584373e-01,3.914086001538639725e-01,-2.672746665809649369e-01,-6.824128048095130794e-02,-7.807293973381991548e-02,9.906062199532865431e-02,4.359251750949572624e-01,2.112950572098262758e-01,-2.935555054735176639e-01,-2.847971011639145456e-01,-1.094167340250102732e-01,-4.114838087255325294e-01,-9.986558545278277632e-02,-3.734300343983273374e-01,-5.014149517780963627e-01,6.600147753874779227e-03,-1.565995426348682218e-01,-3.895653700507142325e-01,6.182142170040588053e-02,-8.722156243955533350e-01,8.413762745581442049e-02,1.856863510459401054e-02,1.016664633855991623e-01,6.734910610656736967e-04,-1.471753445529861148e-01,1.402455709007157103e-01,1.225576194547501330e-01,3.961543498558989240e-01,2.142645111081701581e-01,-9.559761613938597136e-02,-8.464832916902710613e-02,-1.282005325320596627e-02,4.667947806999226956e-01,6.502971720314743020e-01,1.366766274479502552e-01,-2.352054153922956414e-01,-2.255606692535866431e-01,3.899033968662553584e-01,4.152056832658168051e-01,-3.147423313470983919e-01,5.608424834033360479e-02,-1.039424562102701094e-01,-4.217618539503950048e-01,1.297196401598816884e-01,-1.688085953069615452e-01,-1.524696016306772151e-01,5.314575859846472072e-01,-1.834847022962705632e-01,-6.890525219956607217e-02,-3.263372059322064977e-01,-1.499635832386605472e-01,-1.118377860929817419e-01,-8.301157497220513007e-03,2.761890176871202307e-01,-1.993743206838808901e-01,2.355096632212508867e-01,1.354936167104123061e-02,3.090023397697244101e-01,-7.658518736918668024e-01,-2.946688733513034286e-01,7.592546015453112418e-02,-6.631472948017863578e-01,1.431059848249103261e-01,3.102806853743250715e-01,-5.548874223107690129e-02,2.968330638200645799e-01,-1.588011996554045957e-01,7.117557693799414671e-03,-4.311999363299889310e-01,-2.202205357011463305e-01,-2.905095483359649289e-01,3.315390159568715744e-01,-1.366494637537023216e-01,1.806023169594230537e-01,4.409300203800593787e-02,-2.756926057043486700e-01,-6.765982234424912090e-01,4.370901975877595769e-01,-1.363451245863073757e-01,-6.842739099905634226e-02,6.587797120194252565e-02,6.665715629581745461e-01,-4.617012265862462939e-01,-8.636983318549103228e-02,2.100645496290568515e-01,1.853606336633824292e-01,-3.008349947135586788e-01,-1.305997119851173560e-01,2.112409759979963220e-01,-3.254178162704982752e-02,-3.209102220056259114e-01,-1.859662125663598051e-02,-1.149519745497614293e-01,-1.592648405401785594e-01,-4.308688211454399924e-02,-8.352266949231091919e-01,-2.880342431381964149e-02,-4.183031653929835114e-01,-4.064791313007381189e-03,6.262159364406823074e-03,-2.593399296573429269e-01,-1.372565013198280004e-01,1.088083056735674641e-03,-1.949922125554291452e-01,-1.650491144485113360e-01,1.163451812378846225e-05,2.197179934375213166e-04,-3.961348132272198008e-02,-4.512710727031900571e-01,-2.543518831692651418e-04,-5.916174057511644762e-06,8.412834448458978986e-01,1.475265067137707109e-01,-2.261918823793762714e-06};
    cv::PCA pcaANN1_0_21;
    pcaANN1_0_21.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_21_pcaMeanLoad.data());
    pcaANN1_0_21.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_21_pcaEigenValLoad.data());
    pcaANN1_0_21.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_21_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_22_pcaMeanLoad = {8.561542295393902962e-15,1.548062147606228327e-14,-8.963795043453398296e-15,-1.025900687649956936e-14,-9.134725762854665952e-15,-7.736570437764998620e-15,-1.494445494809874897e-14,3.476393503664806605e-15,1.883160963085742870e-15,1.588659647468154300e-13,-1.708162140695275352e-13};
    vector<float> cluster1_0_22_pcaEigenValLoad = {6.970220363194700397e+00,2.575747894941918137e+00,1.448752336976765420e+00,4.179545743319746688e-03,1.011270166332676459e-03,7.691165219001497516e-05,2.723212456973850282e-05,1.246905165803719274e-05,2.899480807736478931e-06,9.053802725413470471e-08,3.396595928001458498e-08};
    vector<float> cluster1_0_22_pcaEigenVecLoad = {-3.720684769755613353e-01,-3.377827290500619584e-01,-5.505905202529449288e-02,3.530041443788939359e-01,-2.861878590062309491e-01,-3.596948931102687541e-01,1.912923684588543338e-01,-1.819011688642154512e-01,-3.647460426729181027e-01,-2.913785519191891549e-01,-3.477335227396951556e-01,9.592109175511158436e-02,2.736071582502893618e-01,6.156607324924805447e-01,2.181493511561344023e-01,4.035509436018460683e-01,-1.865374155020549651e-01,2.175669036793201616e-01,-2.553353884851865541e-01,1.522402565631890137e-01,-3.929555152333475965e-01,3.922713146973903775e-02,8.783078926025697508e-02,9.037986007955772783e-02,-3.650703370412490545e-02,-7.771890043271008353e-02,-8.051417656645928900e-02,7.614990028918980358e-02,-6.557487765204736974e-01,-6.441719870970750161e-01,9.230914268105358533e-02,-7.592054892884261830e-02,-3.243670574711436938e-01,-1.991636252710228816e-01,-8.397071150482647572e-02,3.866951174828546778e-01,-1.403510129561270081e-01,2.330402875693427522e-01,-1.789855933539828414e-01,-2.267532749953890189e-02,-2.017304818826563817e-01,-3.844103185662194888e-01,7.130504978182011788e-01,-1.691058070914810973e-02,-9.435060115754456689e-02,-1.174411319118978392e-01,-5.847773794845351897e-02,1.124997859190757926e-01,-1.577853332569888467e-01,-1.195740814289988213e-01,-1.783687540629700641e-01,-3.010112722731000390e-01,-1.316695655562590550e-01,-1.057644566364502603e-01,8.781169235048509325e-01,-5.796685830981471721e-01,-4.150020433557893851e-01,1.445677773628396001e-01,-2.678757864098946784e-01,1.506886342334360085e-01,4.641666275790731766e-01,1.137343986224919057e-01,-1.422073225491547188e-01,3.312593431479227690e-01,-1.320921448664023057e-01,2.455835424182694834e-02,-2.452210473855427064e-01,-4.179318994511238561e-02,3.921812962016072990e-01,2.350461193993480524e-02,-3.598399541944059810e-02,-1.134289181869698182e-01,-6.280516166332071881e-01,5.761072835128669967e-01,-7.329376540376125737e-02,-1.945699364420216682e-01,4.742618142106030596e-03,-4.950226874797213350e-01,7.346260258347244720e-01,-2.244650478135262056e-02,-2.965235554579160326e-01,-3.152730056874211151e-01,-2.944972789386560499e-02,1.309507739564730877e-01,-3.842676354643743269e-02,-7.310700372218767451e-02,-4.800353734510138387e-02,1.757916359767606324e-02,2.960247443699501879e-01,-1.132569011831387057e-01,5.366381906841195537e-01,-3.194623215063843724e-02,-7.118213836286992890e-01,2.677598787379371070e-01,1.531311097865148130e-01,-4.075681605008561748e-02,2.664358945187174713e-02,7.948504669936695688e-02,-4.251165281255269400e-03,2.365273969485899852e-01,-2.164901002928266704e-01,2.128054737403207650e-02,-7.925425484126268350e-01,2.369975739690841424e-02,-3.606748005941022850e-01,7.585644604054632423e-02,-1.396505797748751054e-02,-1.725110211684959816e-01,-3.197692459293578482e-01,7.985146792631312622e-04,1.063457157930449010e-01,9.319913200734603054e-02,1.254476070057620974e-03,4.870628890521872499e-03,1.972467601900715906e-01,5.939065894892193720e-01,2.059265714220579119e-04,-8.808781254986113452e-06,-7.205794803857407116e-01,-2.628936329810853123e-01,-6.857153610877100322e-06};
    cv::PCA pcaANN1_0_22;
    pcaANN1_0_22.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_22_pcaMeanLoad.data());
    pcaANN1_0_22.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_22_pcaEigenValLoad.data());
    pcaANN1_0_22.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_22_pcaEigenVecLoad.data());

    vector<float> cluster1_0_23_pcaMeanLoad = {8.682169931868742896e-16,-2.261682154021107737e-15,1.116474102927990397e-15,-2.029761895978994454e-16,-3.561958971080322319e-15,-1.313882105130088270e-15,5.278221410661732962e-16,-3.504806255168698627e-16,2.157094785105626936e-15,1.704075463394373173e-16,-4.228460496343818235e-15};
    vector<float> cluster1_0_23_pcaEigenValLoad = {6.787967291216284949e+00,3.988610249122906737e+00,2.014252681856526783e-01,1.504161166228730993e-02,3.964787670082721947e-03,2.537107047577811299e-03,1.265370597371208742e-03,3.505107485300930554e-04,1.251001866077124959e-04,1.401567534689899805e-05,1.030602614561326377e-09};
    vector<float> cluster1_0_23_pcaEigenVecLoad = {3.791682410687328697e-01,3.186222396692897640e-01,-1.900652363476313944e-01,-3.100675699448918188e-01,-3.396269049024042697e-01,2.685909409535118253e-01,-3.643245074444698695e-01,-2.374394466319310337e-01,3.772240537468683486e-01,-2.994579572363191833e-01,-1.177887975945711985e-01,-7.315073773921017264e-02,2.674217701165914063e-01,4.330379395232989981e-01,2.831172318094258289e-01,1.604994999448477455e-01,-3.569564217930123462e-01,-1.509734291391999772e-01,-3.913958861071686335e-01,-8.596011113323516473e-02,-3.058044667801639305e-01,-4.747527117391557305e-01,-9.712924731167826842e-02,-3.279552945041729339e-01,-1.724810442153781598e-01,3.683124888080545056e-01,-7.515041692534756290e-01,-9.221129379665718440e-02,1.424219279645708991e-01,1.050951892415413237e-02,-1.483227195623932904e-01,-2.907332551272731047e-01,-1.320078962042803561e-01,1.271362358619896049e-01,4.999169668471508121e-01,1.085190836854902641e-01,-7.779266789373556756e-02,-1.142985043969684950e-01,-1.027878033213887876e-01,4.623225323783332064e-01,6.289363970406868232e-01,8.037378325903876686e-02,-1.196672391604660518e-01,-2.497569295080934448e-01,1.641805763598106205e-01,1.986503383068906059e-01,5.496196066096337152e-02,2.670617098013589041e-01,8.147097921988903646e-02,-1.683427868496490121e-01,2.058024041808059756e-01,-1.304949110525704392e-01,1.144535920706876708e-01,-4.336220309863655920e-01,7.508341702824926633e-01,-2.726682454961940616e-01,1.539098277570173645e-01,5.273064469304721280e-01,-6.404468865654780463e-02,-3.498493916493835010e-01,1.304735701412210527e-02,-5.286074645338907363e-01,3.162585836047342447e-01,-1.094904733525245005e-01,9.011101418441573585e-02,3.125566339703187424e-01,-4.845125785947806962e-01,-2.153544532807518952e-01,1.945358787697024083e-02,2.556322673116825581e-02,2.849118399431234683e-01,4.099816313279958657e-01,-4.736062033285549228e-02,2.388141630876457755e-01,2.933736778843781257e-01,-5.596668859633455728e-01,-1.000401642260074914e-01,-6.308725405868033098e-01,3.529843206305936509e-01,-2.277721653557613635e-01,-4.317703769841414463e-01,-1.502213575966424575e-01,-9.058472941567922987e-02,2.403164346224506420e-01,-3.311521415162999582e-01,-1.751882551989131509e-01,-3.082195472352864535e-02,9.627768410199689930e-02,1.586907144190551899e-01,-3.620625894955054047e-01,6.118438828821773923e-01,-4.379130634551991474e-01,-1.459044795819572082e-01,1.353734522217259761e-01,4.167215215737958833e-01,-2.328777519977677790e-01,6.868067346296782838e-02,-7.253945900787842072e-02,1.118836952453459987e-02,-1.420658394179127038e-01,2.912474910765565639e-01,1.647507232214557304e-01,4.772065780960115244e-01,-1.320456271799997638e-01,5.573920235433091896e-01,2.345550499921908172e-01,-2.382979614954336134e-01,2.330729881744668663e-01,3.818265415035609345e-01,-9.211195474482328574e-03,-2.141527977155418816e-01,-1.394766410613278440e-01,3.767441608669377820e-05,4.015210226677947314e-04,-9.784332650333997516e-02,-4.975548874727055426e-01,-3.888499815668239453e-04,-5.784618025823963110e-05,7.880142242010576004e-01,2.378737658912038200e-01,-2.863557591874635207e-06};
    cv::PCA pcaANN1_0_23;
    pcaANN1_0_23.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_23_pcaMeanLoad.data());
    pcaANN1_0_23.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_23_pcaEigenValLoad.data());
    pcaANN1_0_23.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_23_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_24_pcaMeanLoad = {8.163655482779316355e-16,2.329752381166414376e-16,3.078828078653163506e-15,3.169923301186509754e-15,1.901255689807468972e-16,-2.752853188263802711e-15,-4.011998650945977996e-16,1.305803991296815847e-15,6.652807889543331094e-16,-6.751203426077606781e-15,-7.874182162394606304e-15};
    vector<float> cluster1_0_24_pcaEigenValLoad = {7.571675868296066092e+00,3.274402035478441331e+00,1.423705018845110304e-01,6.903696735796907742e-03,2.713092290126956161e-03,2.232979626669757273e-03,4.487541151397918455e-04,2.049565854200001089e-04,2.621787674842002256e-05,4.740986660625770476e-06,1.013632546990785929e-09};
    vector<float> cluster1_0_24_pcaEigenVecLoad = {-3.422564955096258910e-01,-3.131428134409292019e-01,-2.469519732469479256e-01,3.627850468245080173e-01,-3.594989190892379227e-01,-3.591143291671975435e-01,-1.147707969056213223e-01,-1.785609200095576721e-01,-3.384358685456287374e-01,-3.107099222740469791e-01,-2.790437192402310806e-01,1.797771421395164548e-01,2.799385335518305706e-01,3.806897042231355277e-01,-2.438728539020368694e-02,5.923121309924101602e-02,-1.738261578686974701e-02,-5.227901838748300056e-01,-4.804089801760443312e-01,1.865655333388367698e-01,-2.769244202086572626e-01,-3.526875625003300097e-01,2.154566773958667414e-01,1.659491784789721147e-02,-6.641385034049547276e-01,-9.859525726282730718e-02,-2.610403095818149000e-01,3.947389180949608667e-01,-1.743524708204871043e-01,6.810322173970909110e-02,3.605141448247939917e-01,-3.355661087994185610e-01,-3.048443596388260637e-02,-4.656172269491716531e-02,1.194953157229785290e-01,3.244633396910868717e-01,2.993267899717922884e-02,-1.035615461293075551e-01,3.044653193928077706e-02,3.587248525706979718e-01,5.572081513710173128e-01,1.663252474717853147e-01,-4.094948878471326714e-01,-4.808470352981513152e-01,1.016834077764504352e-02,2.018193746265542210e-01,2.061734342957464994e-01,2.116775756769353478e-01,-1.638322932430489043e-01,-1.562552562763907804e-01,5.972017798304734421e-02,-1.048752791354513013e-02,8.071882748520167739e-02,-5.230923112390646335e-01,7.326502271248244158e-01,5.326195328245874050e-01,5.632217487341332207e-01,-2.476040663306572631e-01,1.597659417728816145e-01,-1.691191725447692140e-01,-3.950923326196319474e-01,1.150939169814060026e-01,7.830993408354708363e-02,-2.531278798480705028e-01,1.744997148013993360e-01,-1.168870816259881401e-01,3.139636556452566896e-01,-3.447034079482235169e-01,1.370802835942472146e-02,1.518706548494823672e-01,3.228479651008722140e-01,-2.357727729804963979e-01,-5.489538513762401983e-01,5.358361672086062732e-01,-3.514813764303074267e-02,-6.620113172069810870e-02,7.379334751626932809e-02,-1.858318467074736302e-01,1.523836265784981325e-01,2.086054116474823916e-01,-3.758769248264405283e-01,-6.215571585307892999e-01,9.527996491294477011e-02,-4.137191440752822635e-01,2.968080330459110239e-01,-2.302295605483487828e-01,2.003220907776405435e-01,9.819049048160637116e-02,-6.107864465188928005e-01,5.378270131713954738e-01,-2.855996865385644901e-01,4.085619567100002431e-02,3.915804399304708694e-01,-1.016392698935254940e-01,-2.262475546250792002e-01,1.892819151238765985e-01,5.887905177664574247e-02,-1.703214820825089265e-02,-2.718947995156319967e-03,-3.628439245492544318e-02,9.326909284096181196e-02,1.365543625675866291e-01,7.879245662414078311e-01,-1.619627810790916222e-01,4.316155849505809994e-01,-1.179850676324871173e-01,7.013382105231448505e-02,1.234869077286586958e-01,3.222268715812952045e-01,-8.351367890873134109e-03,1.033481590863530863e-01,1.052304468615141569e-01,-1.137585498135996684e-05,-4.676080777680053594e-04,2.506223162290979189e-01,5.217141511699885381e-01,6.174390501337735518e-04,3.203055601617645910e-06,-7.412650498782001884e-01,-3.062254657362072918e-01,8.914946297866009549e-06};
    cv::PCA pcaANN1_0_24;
    pcaANN1_0_24.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_24_pcaMeanLoad.data());
    pcaANN1_0_24.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_24_pcaEigenValLoad.data());
    pcaANN1_0_24.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_24_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_25_pcaMeanLoad = {-6.380860752056162968e-16,-7.946859544685331078e-17,-2.851520189563559946e-16,-4.908354424658586661e-17,-4.394145865884829952e-16,1.904908979093689747e-15,9.302500290543416243e-16,-6.380860752056162968e-16,2.000738755956071485e-15,-1.963341769863434664e-16,-8.507814336074883628e-16};
    vector<float> cluster1_0_25_pcaEigenValLoad = {6.389099157177815513e+00,3.209039073823375610e+00,1.144073720378972592e+00,2.380071544454865629e-01,4.074542089716942650e-02,2.790664585653425053e-02,6.887020781292705653e-03,1.910679380349656264e-03,5.321852762963724063e-04,1.199832622773085180e-10,6.378054800965671785e-11};
    vector<float> cluster1_0_25_pcaEigenVecLoad = {3.821323747850599584e-01,5.378509483063079188e-02,-3.881331912056981692e-01,-2.548908830317100915e-01,-3.871337353032407447e-01,-2.115769099900720873e-01,-7.015346726491426821e-02,2.001307044793638190e-01,3.671293917331160950e-01,-3.606631558079671507e-01,-3.619285114768031608e-01,1.015956671329164111e-02,5.103068844261005044e-01,3.507584465245273952e-02,-4.253239884882760169e-01,2.919823669032345012e-02,1.959215448157854422e-01,-5.414054055745270988e-01,-3.701268978459287817e-01,1.992420600148092080e-01,1.242438977842338366e-01,1.812936562351440406e-01,2.194003367150345885e-01,2.919608455644325806e-01,1.751620899210881432e-01,-5.542323510614835524e-02,1.740920573425576157e-01,-6.914134218642832286e-01,-1.034381413625686530e-01,4.131494266694609729e-01,-1.112609126361415457e-01,3.272819200257408023e-01,1.537008656625764025e-01,2.511553314834269468e-01,-4.110476510633475078e-01,3.584559389750312242e-02,9.691727473271123661e-02,4.903740252183316078e-02,-4.459273546054916548e-01,-2.252962100554216918e-01,-6.792306746426080011e-01,-8.236556241013419377e-02,6.995120932815991621e-02,-1.795470457828099997e-01,-1.565318431915073694e-01,3.607821125111398408e-01,1.043043007433542696e-01,-2.063312252446675502e-02,3.640694184204470996e-01,1.084068685853526760e-02,1.759482640264788122e-01,-8.563615869790842938e-02,-3.925282660990259825e-02,8.334109386312374412e-02,-8.090655158429367333e-01,1.195721932031645340e-01,-5.362158243938116575e-01,2.364033373852798270e-01,-2.881074463928133822e-01,3.258211008187121838e-01,2.561194049191433120e-01,-4.205246686124927691e-01,3.858105240757534471e-01,1.052592092079297770e-01,1.010428763673084374e-01,-2.013608228692911617e-01,-2.686737971341601194e-01,9.163286629513971160e-02,-4.529599934957998647e-02,4.751049799818470865e-01,-3.689417071708174234e-01,5.779898724476828682e-03,-6.212833545461730056e-01,1.820288706838966708e-01,-2.874003954533734806e-01,-3.438325934335581015e-03,-2.318439619171726584e-01,-6.426838303669321628e-02,-5.457905696061416539e-02,-8.605513118374455983e-01,4.177141010641090280e-02,4.066259907609766078e-01,2.079646533150324508e-02,-9.568221942963764381e-02,3.742978434888155626e-02,-9.877441578661085020e-02,2.456131811195123027e-01,6.466687960668085489e-02,7.817634992518446291e-02,-1.028337137608656832e-01,-5.949733481426686815e-02,-2.636757111332977410e-01,-5.150598071483641904e-01,1.549777999954326801e-01,1.937822638841273648e-01,-1.371866457933023156e-02,-1.712707671202604032e-01,7.257121054796557003e-01,-1.649625576916241010e-01,-6.880305475261676573e-01,-1.806845252054535000e-01,-5.132088731125140219e-02,-5.411538395267763146e-01,-9.768099858776906064e-02,-3.493834085714698778e-01,-1.485499985397546914e-03,-9.187463268137087066e-05,-1.770989989026764966e-01,-1.884386918954307488e-01,-4.094223665984499588e-05,-3.847632848912952430e-01,-1.010171840674272820e-01,2.481264580634619590e-02,2.615183963669557299e-01,-3.956550825512659270e-02,-1.663694051586003531e-01,-4.378453416726238619e-04,-4.001247475767791604e-05,8.004262274388453946e-01,3.206534839746436605e-01,-3.094887812123644415e-06};
    cv::PCA pcaANN1_0_25;
    pcaANN1_0_25.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_25_pcaMeanLoad.data());
    pcaANN1_0_25.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_25_pcaEigenValLoad.data());
    pcaANN1_0_25.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_25_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_26_pcaMeanLoad = {3.425398000891268138e-16,-1.485349575607717876e-16,-5.410916311142400799e-16,1.060963982576941472e-17,-5.729205505915484011e-16,-4.183229417017654789e-16,-4.713711408306125494e-16,2.197711106766521388e-16,-3.182891947730824108e-17,1.533850786239806657e-15,-1.427754387982112516e-15};
    vector<float> cluster1_0_26_pcaEigenValLoad = {5.954524622352247221e+00,4.220802154476112733e+00,5.947207834661732972e-01,2.020295706759617504e-01,2.886969305270634112e-02,1.172240975052199312e-02,3.470282746554103140e-03,2.525406814066184259e-03,1.384952868640298800e-04,1.339026138533989555e-10,4.831246836120436565e-11};
    vector<float> cluster1_0_26_pcaEigenVecLoad = {2.512886549625373278e-01,2.199546398007034831e-01,-3.286956007502203070e-01,-2.337745138600821615e-01,-3.101686988629179798e-01,3.413863639341912504e-01,1.623078592962271527e-01,3.052624790303034019e-01,3.341967720314712453e-01,-3.790999264429574245e-01,-3.716182407273767030e-01,-3.569134509215511342e-01,-4.017338865919847790e-01,-2.418571030421404477e-01,3.990020633893019419e-01,-3.005990215829176249e-01,-2.136730256071959488e-01,4.145187900741497677e-01,2.047455685892240473e-01,-2.800391427430556357e-01,-1.691893503814820565e-01,-1.916134166835251895e-01,3.392313112846546130e-01,1.987104944162205178e-01,2.277114369569240571e-01,-2.331040640516577212e-03,2.365912451214643719e-01,-3.587793376263326839e-01,3.470532792452163395e-01,6.654129430285993241e-01,-5.997611840304409303e-02,1.941068133150073982e-01,6.622190775674899332e-02,2.941699969802242798e-01,1.495154818586937606e-01,-6.121491436673057729e-01,1.407264236618548658e-01,-2.299905636530846231e-01,-4.108022443529643630e-01,-4.604373697078341654e-01,5.652265100209158399e-02,-1.265557084474225047e-01,1.017226876819922327e-01,1.826561134684515086e-01,1.631560969588145560e-01,2.538541426017549285e-01,3.613383357225011250e-01,9.376941148330852904e-02,-2.538920968354533847e-01,-3.772395611709414842e-01,-7.058649814293889435e-02,-3.134114046332676096e-01,-9.254392874772557342e-02,4.501839031044915784e-02,-6.700813287057204581e-01,-6.988485906893998623e-02,-3.780482559017576127e-01,1.775459801317316455e-01,5.022870203692369334e-02,1.230083973534877584e-01,1.495565248260457836e-01,-6.456102906540710507e-01,4.927381162470509945e-01,-5.306850212903057445e-02,-5.959984981263146027e-03,-3.437973519901856290e-01,2.241998615301328546e-01,-2.441683448029752235e-01,-4.406301039896102223e-01,-3.946958842007438489e-02,6.355364275630408510e-01,3.511112555048751037e-04,1.723503656363278569e-01,-2.201442584991849527e-01,-2.211502152182010308e-02,1.841755346263511395e-01,-4.218044400885916922e-01,6.601245020588139001e-01,-5.196126198881456659e-01,2.236356030636812986e-01,1.123957727063112921e-01,-9.245358353112759220e-02,-3.887407858695302726e-02,3.863433009940850371e-02,-1.713232251830232589e-01,2.529435659935160008e-02,-3.853783747148412098e-01,2.037971053228511964e-01,2.103773555497257808e-01,-2.625748500349059378e-01,1.062121172985513139e-03,-1.635442185241724189e-01,-4.501030665715169410e-01,3.078127650866409604e-01,1.280177520706958783e-01,9.600564601886102389e-03,-1.033190771275362269e-01,7.312819075056701257e-01,-2.788785345073690677e-02,1.804709931057114913e-01,2.942978891739135849e-01,2.400995096958362038e-02,8.093072567903915049e-01,8.798080989442089161e-02,4.564595303818520522e-01,8.539481567790171675e-04,5.684954734103171437e-05,-1.806909160229856759e-02,9.402717039501581886e-02,1.862298527140373219e-05,-1.161498086439760324e-01,-1.893526777917608483e-01,7.205960849818803839e-03,2.431177482962268432e-01,-4.674032373028245285e-02,-2.665069088266666664e-01,-3.824126055853270534e-04,-1.861071030540096673e-05,8.756519096578089245e-01,2.269793298218604483e-01,1.547878856678453056e-06};
    cv::PCA pcaANN1_0_26;
    pcaANN1_0_26.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_26_pcaMeanLoad.data());
    pcaANN1_0_26.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_26_pcaEigenValLoad.data());
    pcaANN1_0_26.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_26_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_27_pcaMeanLoad = {-7.039274652480534115e-15,2.583952769753851105e-14,2.461502483321423712e-14,-7.310912410054540925e-15,5.253900325047270181e-14,6.328076483827060620e-14,1.185520153489604821e-14,6.584026137953247729e-14,1.290613283451619321e-14,-2.942206792595734491e-13,-3.490644059427551090e-14};
    vector<float> cluster1_0_27_pcaEigenValLoad = {7.577736357746321261e+00,2.865805445370930737e+00,5.548153681763317024e-01,1.186224423282575919e-03,4.333474180241928941e-04,3.273246003473543475e-05,5.361246074958672386e-06,2.411580372324995397e-06,1.925917563727738022e-06,4.880422990008254299e-08,3.085204154039636006e-08};
    vector<float> cluster1_0_27_pcaEigenVecLoad = {-3.612662118805982092e-01,-3.453669685119134525e-01,-6.285452572762273427e-02,3.358697231867374122e-01,-2.836135033094205338e-01,-3.426242425506091371e-01,2.147388180541690839e-01,-2.427025065659648984e-01,-3.587897651506639085e-01,-2.901116988193576662e-01,-3.430875514677071414e-01,1.363094300523191166e-02,1.577855679427702107e-01,5.694936473109559749e-01,2.250339342492637118e-01,3.614241077844512207e-01,-1.961676406085007818e-01,4.647485768250530502e-01,2.436083605798480822e-01,5.666339771088542421e-02,-3.418392015893180758e-01,1.882669481139938872e-01,1.368843493334346850e-01,2.112612516847671706e-01,2.699625352438560499e-01,5.887226732586647339e-03,1.700836576602617334e-01,1.497837766856593804e-02,-2.385468544089822118e-01,-8.313985273743459414e-01,1.654336576248735258e-01,-2.192772449060721995e-01,-1.048103424867440625e-01,-2.265306346986886155e-01,-1.200795988950045107e-01,3.841336391858747867e-01,-1.194477316276829487e-01,2.175203638657037808e-01,-1.424056727143881429e-01,8.279648928925970042e-02,-1.900285749207454578e-01,-3.219544427991561375e-01,7.466890910219716737e-01,2.604772533574455096e-02,-7.457597750060228348e-02,-1.337708454779844292e-01,-1.194109640570703290e-01,1.022753251328694796e-01,-1.783086227803177548e-01,-9.745194353678887644e-02,-4.572373496674571325e-02,-2.306599814142838434e-01,-1.294702470529830174e-01,-7.428142928188299909e-02,9.126657412116900847e-01,-6.394747663624089640e-01,-3.687613311679317496e-01,1.646469943933547564e-01,-2.919899090908331107e-01,1.148395294280694090e-01,4.440667624738314223e-01,-2.113399623107609787e-02,-2.120789583975373361e-03,2.967385769832363573e-01,-2.051837241972785386e-01,4.161333564439588517e-02,-5.492366662047426518e-01,6.209545666108858830e-01,-1.339613095017901934e-01,-1.243560975379455064e-01,1.288527120722539887e-01,-2.946270262415450758e-01,-3.369484995097395408e-01,1.341193941627298603e-01,-1.748868782404254529e-01,-1.160469002101391645e-01,1.901911725787932411e-02,1.236510573083960673e-01,-4.019330651742209493e-01,2.599090861669752228e-01,2.491657978204739610e-01,2.056634086305850484e-01,-1.640474569531959192e-01,-7.330238579598928883e-01,2.645989432734393021e-01,-8.375871777846900790e-02,-9.932388335643904664e-02,-9.877234401436734909e-03,-1.655292680221765247e-02,2.224375227982377523e-01,5.636444834446495689e-01,-3.180968642528138324e-02,-7.575950684410716063e-01,1.537284763659774733e-01,-1.389098441338030565e-01,1.136407362527282611e-01,-3.920307044657496409e-02,1.333174431472583348e-02,-5.751447932025709892e-03,1.177313489025222232e-01,9.122663512100052940e-02,5.366871014306088053e-03,-1.588538694792647477e-02,1.817947770462098600e-01,5.835190577054951699e-01,1.757381809940939538e-03,5.441192692487709830e-04,-7.458918752066546753e-01,-2.182520867775403495e-01,-5.197765494278193404e-05,2.316737908893982956e-01,-1.948329372350952604e-01,8.184123313516659948e-02,-8.048094512640333598e-01,-4.254721531306478177e-02,-3.729442305047060979e-01,3.796753071193013918e-02,1.710084521943503605e-02,-1.916438475699655530e-01,-2.731156103665146051e-01,-5.538738966298511638e-05};
    cv::PCA pcaANN1_0_27;
    pcaANN1_0_27.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_27_pcaMeanLoad.data());
    pcaANN1_0_27.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_27_pcaEigenValLoad.data());
    pcaANN1_0_27.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_27_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_28_pcaMeanLoad = {9.166944593343957493e-15,1.968454059463603700e-15,-4.027880699687690913e-15,7.340682704853129387e-15,-1.332811659520438986e-14,2.053683837685132928e-14,5.459083386491630001e-15,3.030096474772919995e-15,4.924366069006352286e-15,-1.820737648210665728e-14,4.753447215062936417e-14};
    vector<float> cluster1_0_28_pcaEigenValLoad = {6.802674135984556614e+00,3.851344929408107465e+00,3.327428296176296874e-01,1.105483495214425529e-02,1.876984957728227181e-03,2.740486382882202816e-04,8.411231404596404906e-05,4.504821607732978876e-05,8.677589645998049776e-07,2.700562497860527918e-07,1.402480532011151751e-08};
    vector<float> cluster1_0_28_pcaEigenVecLoad = {-3.653389643328062153e-01,-3.300732309400029596e-01,-2.376560893821925702e-01,3.641121524618592953e-01,-3.616428601382901120e-01,-3.647863367450715488e-01,-4.685993026045089105e-02,-1.180704633245435453e-01,-3.535756799791439642e-01,-2.792691484896610010e-01,-2.924429706058639389e-01,1.536720057132281436e-01,2.580365947212843181e-01,3.755647426533767486e-01,1.139109341903400685e-01,1.423959713383086134e-01,-1.135987796227060642e-01,-4.831674609719510127e-01,-4.826727705213511022e-01,1.952748519594419419e-01,-3.396225925769573717e-01,-3.204630809716485507e-01,-4.319020248403341450e-02,8.287754832003953187e-02,4.617810020257158143e-01,3.788374397073926425e-01,3.090683710303374077e-01,-3.647217578328161847e-01,5.069318649808798316e-01,1.484662708934544051e-01,-2.111107686977333961e-02,-2.501598448962853993e-01,2.528110467103420467e-01,-1.858039091591574821e-01,-6.013295140152268708e-02,3.777557006554511099e-01,-1.867851506020146157e-01,1.816287536957832960e-01,-2.639847537855677384e-01,-1.352176733120678820e-01,-1.859601736270038719e-01,-4.779814946085461091e-01,6.296653580085755930e-01,-6.153163103556699015e-02,-6.960794246617942049e-02,-6.178403279044628743e-02,-4.861597320385190740e-02,4.394533125357707321e-02,-1.356881237715480415e-01,-7.362431784947383318e-02,-3.578243133138112597e-01,-2.755267655630909696e-01,-7.011588842361715646e-02,-1.031303670313975934e-01,8.623836775955134870e-01,4.825309049746116519e-01,5.791020390769276993e-01,-1.730115523644508435e-01,7.798881762051164401e-02,-3.038009281877664947e-01,-3.760667134777835874e-01,-8.849693294132869592e-02,2.450775199522194081e-01,-2.941841968183379064e-01,8.608949140276510315e-02,1.476089728316247462e-02,-2.744291021162189037e-01,-1.722703806889396699e-02,4.484723961619729304e-01,-2.239000353142696076e-01,-2.579706885392885618e-01,3.481830788661170739e-02,-3.759018230506666614e-01,6.454708227495453698e-01,1.821656893899503953e-03,-2.177932650048967356e-01,4.603718215793020549e-05,-3.917112334741438273e-01,4.822503323785604090e-01,1.695403365909133597e-01,-2.365657008371837566e-01,-4.740126327283999963e-01,1.757308957068543231e-01,3.933445581973843974e-01,-3.407713690212180180e-01,-7.432901894894873053e-03,-5.160587196150225042e-02,1.252456767181324600e-02,5.337125983431311171e-01,-4.245799792493493707e-01,4.256902572319181677e-01,1.270066905844879634e-01,-4.948742410015257720e-01,2.056609231604326071e-01,1.565534630369491143e-01,-1.265365674867758305e-01,-5.791551138410414024e-02,8.042213571936157601e-02,-6.806175629684134290e-04,2.146839011253489360e-01,-2.308359218040960115e-01,-5.611973935839577321e-02,-7.387480614657551126e-01,5.843105287526901420e-02,-3.982693208797242201e-01,1.807810677984754699e-01,-1.082324067930661854e-01,-7.048144655613816645e-02,-3.746078213275977897e-01,3.660331256238746759e-04,9.568276798961242169e-02,9.160864738867642576e-02,3.128020687532826805e-04,-7.262167735610922797e-03,2.648919431358822685e-01,5.210192820044735607e-01,2.601354825926541301e-03,-1.219604223518935783e-03,-7.128106321216406416e-01,-3.642303407030693108e-01,1.065969276720188639e-05};
    cv::PCA pcaANN1_0_28;
    pcaANN1_0_28.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_28_pcaMeanLoad.data());
    pcaANN1_0_28.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_28_pcaEigenValLoad.data());
    pcaANN1_0_28.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_28_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_29_pcaMeanLoad = {-2.173356655057402809e-17,-2.129889521956254666e-16,-7.418390715929268189e-16,2.810874607207574209e-16,-2.407354721585249810e-15,-4.042443378406769237e-16,-1.322125298493253294e-15,-5.353701893624735058e-16,-1.195346160281571514e-16,4.088808320381327255e-15,-2.529787146486816788e-15};
    vector<float> cluster1_0_29_pcaEigenValLoad = {6.722649354332308036e+00,3.227647052307993647e+00,8.485976504396216535e-01,1.890307080680087015e-01,9.006739927114164670e-03,4.224792361802309250e-03,1.927593106597360511e-03,1.162069579230304295e-03,2.419392967118297365e-04,6.435168656017878629e-08,3.252348781536849452e-10};
    vector<float> cluster1_0_29_pcaEigenVecLoad = {-3.412669480707249958e-01,-2.373176911349550999e-01,5.280007868678770339e-02,3.779310055810488622e-01,-3.792177074935745851e-01,-3.727298147609727219e-01,3.027617789991794983e-01,6.260954049545633393e-02,-3.301714193863227731e-01,-3.199116707433479756e-01,-3.031874225795389011e-01,2.535128328680626431e-01,4.239284224138642476e-01,4.688853166699583630e-01,-1.102906224746271202e-01,-3.716944809485791135e-03,4.722267709489405552e-02,3.253681196736064041e-01,4.007951952038824595e-01,2.721008985181507245e-01,-2.746902211537705640e-01,-3.252074097638331107e-01,-2.751173416528860868e-02,-2.102591010474394728e-01,-5.360524305508106435e-01,-2.927829562291992677e-02,-1.060100546027836349e-01,2.434713193232797557e-01,1.865979099252514650e-01,7.127629768920783482e-01,1.061322891340504837e-01,-7.164234094482051229e-02,1.925145292610558334e-01,-1.906890717769035293e-01,-9.209471459082092804e-02,3.760160573930771410e-01,-2.003215361305290751e-02,3.479310559395515923e-01,-1.975736418678507023e-01,2.471418255494316762e-01,3.563967697054962191e-01,-3.117382937568509704e-01,5.776210793647310604e-01,1.853399597820782063e-01,4.398417755096574733e-01,4.596000539870724877e-01,-3.516672055140244169e-01,9.047345961989218532e-02,-2.791691200509480164e-01,-3.941415977475580812e-01,-9.841536950498179503e-02,1.177952171225045003e-01,-2.667602945192503738e-01,3.478831797163521311e-01,-1.200986107481764875e-01,-8.093643707447620295e-02,-2.195163310882800034e-01,-1.770454190682935192e-01,-1.071631621521447197e-01,2.468484058358097755e-01,1.604868930997367937e-01,-1.757464226573854926e-01,7.573172859569833604e-02,4.430002586426983087e-03,2.577547874857595289e-01,-8.441939447162143395e-01,3.698555821220873008e-01,-1.943613484672907787e-01,-2.454426622331323804e-01,-4.007203066489763155e-02,2.122286113438028310e-01,-1.610294499605039939e-02,7.534410382137229911e-01,-3.784215803007200951e-01,4.211735738798225159e-02,6.306069578023128230e-02,-4.068838349512009234e-02,-6.418710261609342771e-01,6.119266900342766879e-01,-3.120807607729892408e-01,-5.766297094968280551e-02,1.501732553777762047e-01,4.531374205519443643e-02,2.482864374490651171e-01,-1.396128094383016494e-01,7.100273690784439373e-02,3.796523515114456904e-02,-2.453387814264295502e-02,-8.804441091547716980e-02,-1.338942034566530624e-02,1.849431014016047203e-01,-1.558617071807712473e-01,-6.842010321213664037e-01,4.822399372299183695e-01,1.914778793500396259e-01,-1.344755380891943797e-01,-2.675012827796767467e-02,4.193603472750409011e-01,-3.949119317327574874e-02,-7.611665638618868301e-02,-9.945279195328100841e-02,-4.198893838416165036e-02,-8.915449244974056331e-01,-1.221692070594642687e-01,-3.129355172577212296e-01,4.150930618504385453e-03,-2.056944633733047163e-03,-1.999262866091947866e-01,-1.866905432340650872e-01,8.246684653766783550e-04,-1.407134402228881476e-01,-1.719136664637829215e-01,-2.337942873198670473e-05,-4.770753785206480213e-04,-1.853835823735329735e-01,-4.966171560196351309e-01,-2.798752511999161871e-04,8.216654656414457544e-07,7.679980981212622959e-01,2.825391327740836567e-01,-3.462791454124507312e-06};
    cv::PCA pcaANN1_0_29;
    pcaANN1_0_29.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_29_pcaMeanLoad.data());;
    pcaANN1_0_29.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_29_pcaEigenValLoad.data());
    pcaANN1_0_29.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_29_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_30_pcaMeanLoad = {-2.390364894790270245e-15,1.044370196932269243e-15,5.950869612360070149e-16,4.166350732344363574e-16,-5.025962009890391484e-15,7.842608025915182199e-15,1.032127136009084634e-15,-1.372706830781313038e-15,5.092927843121749500e-16,8.888462230232080973e-15,-2.768786777870523984e-15};
    vector<float> cluster1_0_30_pcaEigenValLoad = {6.220978086105088956e+00,3.793367428238583194e+00,9.683974062457274545e-01,8.526219830787105589e-03,5.618008935124845470e-03,2.016364802566305171e-03,1.718507712905325679e-03,3.226140466138625483e-04,2.003692733172889864e-04,3.818926872184542268e-06,9.476859327437739398e-10};
    vector<float> cluster1_0_30_pcaEigenVecLoad = {3.934639024084482517e-01,3.820507632852934710e-01,-2.066199626719932292e-01,-3.494853760614954896e-01,-1.641094222139908576e-01,3.349581217160833568e-01,-3.630659432348425919e-01,-2.041413112072370251e-01,3.920429058616010098e-01,-2.577337704654453221e-01,-4.059308319262620868e-02,-9.118723529970380881e-02,1.108149326617962338e-01,4.225916408517889078e-01,2.417677296305516532e-01,-7.144860859162638356e-02,-2.818562295212920787e-01,-2.123654359427185334e-01,-4.398947406942219085e-01,-1.000227757293618014e-01,-3.866800460099501513e-01,-5.095971900422517908e-01,-7.004699361241308042e-02,-2.113361432163288200e-01,-2.404272502581088766e-01,1.367710075394095448e-01,-9.162487252040775187e-01,-1.770623487057375323e-02,8.023865011641100053e-02,6.270971807111754004e-02,-7.757230887472255088e-02,-1.330577255233034717e-01,-1.036222103519070540e-03,-1.157584775566052743e-01,-4.047333933582364929e-01,-5.588230055013578695e-02,9.066408240330342538e-02,4.478517335728868232e-02,3.882059974709271832e-02,-4.850599969131337841e-01,-5.367788052860061887e-01,-7.533312776502681940e-02,7.875033092621769315e-02,5.221531537153041302e-01,8.344213601482833656e-03,2.725333551773232443e-01,2.504093068411273326e-01,1.699843268004462005e-01,2.216693993644573788e-03,-1.326417748729669943e-01,2.220066779268754509e-01,1.177094548985340161e-01,7.968051112005386516e-02,-5.747445059778534260e-01,6.454726842479696636e-01,3.575338712761284565e-01,4.123930798426054256e-01,3.083035591151321309e-01,-2.549519661236565940e-02,-2.785191801952657253e-01,-3.455811606959495186e-01,-1.322122230804896603e-01,-4.067538902857899957e-02,-2.003066960433547428e-01,5.536318227692605953e-01,2.088913347727491265e-01,-3.445689334545098403e-01,-9.259228958932989861e-02,5.304418582814497407e-01,-2.470307348289010885e-01,-1.448762467170356671e-01,2.426056144738604481e-01,-4.638350048779520951e-01,4.821294471794371206e-01,5.042918740608081513e-02,-6.164548412943267417e-04,1.800998211270623747e-02,5.639904055906123093e-01,-2.742321440103048236e-01,-6.064415765605687958e-02,5.119263001088637521e-01,1.212244017141819868e-01,-8.949190448722943447e-02,-3.593975736332152837e-01,4.116499293001674165e-01,5.809482057818529666e-02,-1.044241361926673411e-01,-7.320831802944871569e-02,4.352199081909798317e-01,-4.639960775744990107e-01,5.106943194513859918e-01,-1.673934648562575289e-01,-8.769625555091120628e-02,2.501107761497589621e-01,4.041763985872272591e-01,-2.066236474489192565e-01,1.708352525457270399e-01,3.040636248807953093e-02,-7.406394343833705603e-03,-1.770511310449623954e-01,2.748581375232311830e-01,1.191030194919639462e-01,6.417351766311668593e-01,-6.049088383196480484e-02,5.384838977048913566e-01,8.323026593987827015e-02,-1.124595245248985464e-01,2.666541608853304490e-01,2.877233890883611478e-01,-2.944141650231977582e-03,-1.819009213251050472e-01,-1.196943657405797473e-01,-1.906689653183944242e-05,2.153677923753035274e-04,-4.282108724760703977e-02,-5.001327825811561212e-01,-4.448584395462375305e-04,-1.031222831223220511e-05,8.197110884778484596e-01,1.693881771495221178e-01,4.670979933716022986e-06};
    cv::PCA pcaANN1_0_30;
    pcaANN1_0_30.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_30_pcaMeanLoad.data());
    pcaANN1_0_30.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_30_pcaEigenValLoad.data());
    pcaANN1_0_30.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_30_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_31_pcaMeanLoad = {1.489474659199528119e-15,2.337640081277287530e-15,-1.965409075872895388e-15,1.131413394237551576e-14,-2.692250684058986946e-15,-2.394979808145301546e-14,-4.959409154845501802e-16,2.128764891854112847e-15,3.173507930691292762e-15,1.095422345286745901e-14,-2.857111576097559324e-14};
    vector<float> cluster1_0_31_pcaEigenValLoad = {6.588508132496098568e+00,4.270839059640755941e+00,1.227551373223958048e-01,1.474093573236693287e-02,2.392386166067050988e-03,7.286402860480074547e-04,1.390562430713577244e-04,3.740246457967621449e-05,9.968876734366518414e-07,3.184534230338159627e-07,1.095140408204975358e-08};
    vector<float> cluster1_0_31_pcaEigenVecLoad = {3.865100482248497449e-01,3.711244048785558580e-01,3.458484366361931350e-01,-3.498146484399320966e-01,3.861924765219394984e-01,3.356872612906845466e-01,-1.123134433695433948e-01,-8.838744173819113037e-02,3.817055605292933307e-01,1.686621795443616068e-01,1.203825064398431066e-01,5.984945596293267389e-02,1.457353637651196687e-01,2.092537359882770953e-01,2.012425431817320143e-01,-4.236947148537340002e-03,-2.325399876024869528e-01,-4.590357401524692849e-01,-4.707288915258915907e-01,9.264428284796163982e-02,-4.335314786518387198e-01,-4.560359146181356405e-01,-4.611094955693254178e-03,-1.110158292547784170e-01,-4.371374129685399179e-01,-4.039109333100561749e-01,-3.708519631533832017e-01,4.505996720942415656e-01,-3.635242498446221160e-01,-9.768843839807210550e-02,1.610873139975853990e-02,1.812964960929122904e-01,-3.435534872231298387e-01,-1.455961960002396804e-01,2.154884834445936533e-03,3.112382810717943538e-01,-2.269223644111847960e-01,1.174013823763866149e-01,-3.351666772131076111e-01,-1.556906815161080426e-01,-1.659558099243388651e-01,-4.763871406034481115e-01,6.290881649413604393e-01,-1.727331608260231910e-01,-1.319003940643801442e-01,-1.950585289116136267e-01,-8.221847154758513132e-02,-1.656560127684024008e-03,-2.989373595491293112e-02,1.480144662270689408e-02,-3.863014389126685488e-01,-4.666118120141021230e-01,-3.839481115391925325e-02,-1.715888198588595009e-02,7.536279873029670950e-01,2.798950255481302829e-01,5.670876862249150108e-01,1.972410949110642037e-03,-1.250338148866281252e-01,-5.224679413776709413e-01,-2.611481899172711230e-01,-1.993757970997041273e-01,2.930375878131074030e-01,-2.191615676575711935e-01,-9.532542025971312005e-02,2.460109628546194582e-01,-5.351821928595617006e-01,-1.509744533980286185e-01,5.656503567396924392e-01,-3.255097678291473673e-01,-1.836962584329239201e-01,1.566886948646386002e-01,-1.409909093496140853e-01,3.088660936446598893e-01,7.384267964450628996e-02,-2.910145534491624941e-01,3.398860685274768256e-02,-3.203368401913078145e-01,4.233562234198345875e-01,9.204274941280003730e-02,1.190907232163098198e-02,-3.279084419665880268e-01,2.196200886421868781e-01,5.274714003639425774e-01,-5.226892334607868840e-01,-6.071168398525798350e-03,4.772424559113534748e-02,-6.214326678493585152e-03,2.391668730068122750e-01,-2.500516374258835439e-01,-8.542105099520608258e-02,-6.735375885600604073e-01,2.030256438690193621e-02,-3.576866704996760626e-01,3.452119462891446999e-01,-2.251912601031545169e-01,-4.342699960483111660e-02,-3.452547994084018690e-01,1.620385671126234241e-03,5.248956746585755617e-01,-4.408386739383236552e-01,4.540380670972847255e-01,2.170294914962420663e-01,-4.339113695803347714e-01,2.115949016371044544e-01,1.184192855276066519e-01,-1.029858314842335421e-01,-9.590252481691657893e-02,1.000744653974122711e-01,7.396758487190456402e-04,9.120108726297422586e-02,1.008668087267366176e-01,2.526569814422426627e-04,-2.007894047584413057e-03,3.093497026576343956e-01,4.516065807345414629e-01,1.992792820940776036e-03,-7.171517239957887410e-04,-7.432596785185880961e-01,-3.597484890728123719e-01,1.328982470199454367e-05};
    cv::PCA pcaANN1_0_31;
    pcaANN1_0_31.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_31_pcaMeanLoad.data());
    pcaANN1_0_31.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_31_pcaEigenValLoad.data());
    pcaANN1_0_31.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_31_pcaEigenVecLoad.data());
    
    vector<float> cluster1_0_32_pcaMeanLoad = {2.626589051583147322e-16,5.635604725800860905e-16,-2.285073183928092737e-15,1.966977241225076994e-16,4.718373740970358382e-15,3.006051126755430677e-15,1.043520706723778732e-15,-1.102811655969447920e-16,-3.640464283684091177e-16,-5.148826032493917106e-15,6.264681697297411799e-15};
    vector<float> cluster1_0_32_pcaEigenValLoad = {6.864019360030568784e+00,3.705334434926462084e+00,4.063028600703820770e-01,1.308825278486413883e-02,8.157867079777701008e-03,4.194198652635956238e-03,4.080271080824549208e-04,2.116500135351563074e-04,1.171874692419926214e-04,2.248862621442927094e-06,4.663546564056293618e-10};
    vector<float> cluster1_0_32_pcaEigenVecLoad = {3.754990889425125489e-01,3.810930392517432597e-01,2.603643043460439066e-01,-3.594021330163105765e-01,3.507307901705330466e-01,3.454489461004887629e-01,-3.124233626318360102e-01,-1.902187150851303299e-01,3.745294831606222341e-01,-5.530777656377594380e-03,1.917194727943543828e-02,-7.328684479511524130e-02,8.911286282355129762e-03,2.947734667220149873e-01,1.733768249410437834e-01,-1.747457091360047066e-01,-2.037838160120006847e-01,-2.930896482152329785e-01,-4.488740584841770520e-01,-7.580772627455538426e-02,-4.944925366662339949e-01,-5.175670567805195077e-01,1.614927190618859476e-01,2.176489617265670376e-02,-7.199964223798436258e-01,-6.956785740819197705e-02,-3.216857563560261424e-01,2.524275447045708498e-01,-1.477660276605745338e-01,2.031845953167982916e-02,1.962235622908035104e-01,-4.697846958225629366e-01,3.951555689862423781e-02,-1.383901688198250872e-02,1.751441863410372335e-01,3.555528047529863400e-01,-6.045734682062806759e-02,-6.830963212168571219e-02,1.096045955631095997e-01,4.209541474778031866e-01,6.038392629954283386e-01,1.520299570984177950e-01,-4.828471626328122435e-01,-1.558909699427404316e-01,-4.150350258515793089e-01,-4.529995829473509872e-01,2.453162919702362166e-01,-2.172101203819829310e-02,1.408221483641692029e-01,2.479387098011819612e-01,-2.331004556720031040e-01,-5.172673482223150154e-02,7.142664493923438218e-02,-3.531137693070256489e-01,5.420132481746040565e-01,2.922610174582273568e-01,3.996045913016196827e-01,1.535765985600476558e-01,1.724317085174799091e-01,-2.535559522544252320e-01,-3.752916184311558823e-01,8.805661512424960147e-02,-1.680614111418428092e-01,-1.049397297502398935e-01,-1.947987889047212984e-01,6.414742881426857002e-01,1.311319784547259892e-01,-1.191990412530872893e-02,1.112871547698861124e-01,5.186138183261914530e-02,-1.962182358109103020e-01,-1.640931925021270610e-01,-7.283978254377206918e-01,5.860494322948471835e-01,-1.202249405939011528e-01,1.169609042310740948e-01,2.914759796445226883e-03,3.409058416505799660e-01,-3.817870791492119498e-01,3.179751017707747041e-01,-1.441977363913760912e-01,-6.522558923412085097e-01,3.217096941125777709e-01,1.281600173082458327e-01,-1.367449079655068678e-01,4.226121624730271031e-02,2.242038462791596798e-01,-2.875663547939550594e-03,-6.400561579658040623e-01,4.999467938553682766e-01,2.685951385583620898e-02,-3.185289799407306499e-01,-4.138025613077441767e-01,1.474350553259591579e-01,-8.043581926350509836e-02,-6.473702308304829511e-02,-3.838377949851769222e-02,1.802508186313341587e-01,2.459761795814668570e-02,-7.638083418015011172e-02,2.109778294749195537e-01,5.026034939437214882e-02,8.228778724358779550e-01,-4.745356566259715386e-02,4.322533837126695810e-01,-4.364267109120475996e-02,5.471874619838138117e-03,2.311857971319853933e-01,1.597498970558577092e-01,-1.967941124347083372e-03,1.441151451124284277e-01,1.352225462729153560e-01,-5.618624938365689026e-06,-1.233241533164499359e-04,1.294552976548069279e-01,4.712570001723020430e-01,3.627402454229616976e-04,3.451416936747035420e-05,-8.396962034427096766e-01,-1.304376921129364320e-01,-3.797695546903121579e-06};
    cv::PCA pcaANN1_0_32;
    pcaANN1_0_32.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_32_pcaMeanLoad.data());
    pcaANN1_0_32.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_32_pcaEigenValLoad.data());
    pcaANN1_0_32.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_32_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_33_pcaMeanLoad = {5.325935309777041854e-15,-4.560030018601598956e-15,-7.990339935193096188e-15,1.787852603620519700e-15,-1.724364633040396180e-15,3.778187417938964843e-15,2.959636751982061836e-15,-1.995788770638856893e-15,3.113261964743842337e-15,-3.523004313143742632e-14,-3.620878335279325316e-14};
    vector<float> cluster1_0_33_pcaEigenValLoad = {6.679062043871738297e+00,3.857690912697062657e+00,4.426771056870870136e-01,1.692520018399609402e-02,2.886876582776732279e-03,5.922219643593648044e-04,2.101334622181156317e-04,1.425196341079237709e-04,1.446355906320180321e-05,7.556665155934648470e-07,6.032149707098124111e-09};
    vector<float> cluster1_0_33_pcaEigenVecLoad = {3.833215588143301100e-01,3.185004298043854765e-01,-2.086713135206814951e-01,-3.338404349025732576e-01,-2.289089358366609706e-01,3.259962930412703130e-01,-3.776903354619852160e-01,-2.458948503222376514e-01,3.810527258073857504e-01,-2.920336812492368983e-01,-6.600684791796243567e-02,-1.255526143405083679e-02,2.716086918885412538e-01,4.246069290905894467e-01,2.536134685465727956e-01,3.439426870243945666e-01,-2.713520541014524112e-01,-8.880862504936216928e-02,-3.832136892492961633e-01,8.097384714222628094e-03,-3.306904055234927697e-01,-4.747318438472393765e-01,-1.992542986754050061e-01,-2.902376755882825621e-01,-1.743773972334332623e-01,9.337084210751596391e-02,-6.589295663731264963e-01,-1.156731192856694374e-01,-1.789417583817716206e-01,-2.529154360257485634e-01,-2.577479421395702519e-01,4.246922071737949111e-02,-4.744910687066491439e-01,-1.212434233687582213e-01,1.424184170521264614e-01,5.785188241666073400e-02,-4.598687056165564058e-01,2.810606590979288777e-01,-2.699557587522736710e-02,-3.650165485745060501e-01,-1.857287299457583973e-01,-1.664840919943080810e-01,6.739458567514901022e-01,-1.442736714720246338e-01,-1.410506552446084416e-01,-4.033180882394532540e-02,1.801225085060349784e-01,1.305559657631285564e-01,-1.344522996874125964e-01,-1.653842434913372073e-01,-3.331557247087112983e-01,-4.817822829260507977e-01,-1.336283572043937273e-01,-8.635718571262769594e-02,7.177316380638357751e-01,2.817128615392587854e-01,6.323667987101561083e-01,2.400010695601964908e-02,-3.146326900875759391e-02,-3.749197688553658203e-01,-4.902317841561688594e-01,1.784951867403613834e-01,1.791137459152540579e-01,-2.160594837765912324e-01,1.415889177520320286e-01,8.729679261601240581e-02,-3.502576249945147935e-01,1.198721689116428735e-01,4.873380071251238177e-01,-6.325409318687109927e-02,-2.136579459731116903e-01,1.316888174232928033e-01,-4.475187889620780846e-01,5.756856732740959215e-01,2.407320283836561839e-02,-1.607538419022891685e-01,-1.872980458703410456e-02,6.754194555572687886e-01,-2.901507461265965815e-01,3.070866539206583701e-01,3.954487177330162084e-01,-5.271631639404461556e-02,5.066757062905714176e-02,-2.703283915941646076e-01,1.048160604969598647e-01,5.645537984455821501e-02,3.393348666237125943e-01,-3.455115072620786043e-02,-9.733904390862231637e-02,1.897360692025424900e-01,-6.099453252586545249e-01,4.625503248144879898e-01,2.598833316375454006e-01,-1.440722117329257534e-01,-4.763097517606652564e-01,2.262205252587660420e-01,-4.538161543988544072e-02,-1.128305154262655360e-02,-3.095090353556636219e-03,-2.671517284382973201e-01,4.125052237917414266e-01,7.454439965754056097e-02,4.600706783019185009e-01,-1.738256853467183005e-01,5.156286616630230135e-01,2.028068674365051671e-01,-1.909177060221688704e-01,1.811681778820896649e-01,3.670893666653690102e-01,-1.582536171717560149e-03,1.988227872186945078e-01,1.184640450737854400e-01,2.915172145214125501e-04,-1.840127919901842900e-04,1.062787033823859306e-01,4.814223006407223338e-01,6.523159509510444631e-04,-1.116247643671739533e-04,-8.107995626953102830e-01,-2.144217508829620311e-01,4.763995945350534895e-06};
    cv::PCA pcaANN1_0_33;
    pcaANN1_0_33.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_33_pcaMeanLoad.data());
    pcaANN1_0_33.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_33_pcaEigenValLoad.data());
    pcaANN1_0_33.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_33_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_34_pcaMeanLoad = {4.290717003382247449e-17,-6.865147205411595671e-17,1.458843781149964219e-16,6.436075505073371481e-17,1.089842118859090774e-15,1.255034723489307297e-16,-7.380033245817465932e-16,-3.604202282841088128e-16,-2.585156994537804259e-16,-2.467162276944792422e-16,7.122590225614530925e-16};
    vector<float> cluster1_0_34_pcaEigenValLoad = {5.230454939922900337e+00,4.061842985673509432e+00,1.160297943751198879e+00,4.582941245005227593e-01,7.592998649459148375e-02,2.703424143565004781e-02,9.637863315088047653e-03,2.755267776127247152e-03,3.870296429157538349e-04,3.417674553097270890e-11,1.990839794309025651e-11};
    vector<float> cluster1_0_34_pcaEigenVecLoad = {4.009374320244701306e-01,4.283844741153203795e-01,2.129594659645365484e-01,-4.346299476367069259e-01,2.767617218510704524e-01,3.880315132869602834e-01,-7.442955780393419041e-02,-3.967566007769566389e-02,4.113723654009429076e-01,-1.288648302667254331e-01,3.698921266409530700e-02,7.497858134249327233e-02,-2.974763570516216274e-02,-4.103903327599213169e-01,-5.226885913790502852e-02,-3.657574302566226065e-01,1.853340961382239360e-01,3.964265901107024148e-01,1.059979661334806561e-01,1.656450845810502615e-01,-4.681854643391958337e-01,-4.890687819075529852e-01,-2.413141554635646058e-01,-8.777203683061216011e-02,-8.800344107315773157e-02,-3.570647847044571693e-02,-1.247002883767786563e-01,2.001532490826595234e-01,-2.161519167249426887e-01,-8.944945379554607445e-01,6.133126686770048325e-02,-1.372058935501364596e-01,-1.842167725939939261e-03,2.692983669703985505e-01,2.123261623534524190e-01,-3.844245641114769074e-01,4.100573523540008980e-02,-2.795781144345684255e-01,-1.721922597119860121e-01,-7.733615754367639816e-01,1.320948931617696442e-01,-1.536812444283049313e-02,-1.908962881642090048e-02,-9.476496081694309181e-02,-6.726144958662083617e-01,-8.723808418384274704e-03,6.421437710747793237e-02,-1.122684293835358310e-01,-1.560507020243058207e-01,4.373085313274667207e-01,-2.706882426127115160e-01,3.985447602259694078e-01,1.257841932736983026e-01,-1.619606967291763455e-01,2.025645436024408053e-01,-3.428644160862137635e-01,3.895526898602754695e-01,3.028824108371490076e-01,3.182336378077450095e-02,1.305802503863121300e-01,-1.136866831924175092e-01,-9.860092276840776160e-02,-2.653491044723960135e-02,-7.440459917995828620e-02,1.718833954757763571e-01,-7.499734392221868440e-01,-1.821543954900815554e-01,7.372740214714249563e-01,-1.529298547116271223e-01,2.701967196070613822e-02,-3.322919107717468012e-01,-1.925883721373743973e-01,3.162947004421728381e-01,-9.962814139962686277e-02,-3.345320786706595245e-02,9.223884527385543819e-02,3.633535048744558904e-01,2.175844059311314860e-01,-7.278810090967034740e-02,7.072164221654398952e-01,5.776846034628962262e-02,-6.329321048892677659e-01,-7.168524875820984910e-02,-4.712488119811088227e-02,-1.236135646312711348e-02,-1.786942232850247114e-02,-1.874745419585668038e-01,1.688946069995672650e-02,-9.469596893045309494e-02,1.389820127759514024e-01,1.040037253751724400e-01,2.490521703601756842e-01,3.727820811033830672e-01,-3.495323357562639122e-01,-8.507920763436954692e-02,-3.673992506866926200e-04,-3.612506171193444193e-02,-7.839220616291607824e-01,1.210626121580700848e-01,2.066248571888328056e-01,2.051580024670485169e-01,1.567654935468005065e-02,6.091341692184609746e-01,6.716904842575148471e-02,6.116457011674694133e-01,7.691630483269573529e-04,4.348094835968497571e-05,-4.062938711672918202e-01,-1.512362446062277474e-02,-3.988293444643956732e-06,2.688182198505125256e-02,2.666817588156227339e-02,-1.532354868401062178e-02,-5.955272856737848786e-01,2.867005884941276669e-03,5.191852373469710985e-02,-1.771004297739360117e-05,4.685280659023598648e-07,-7.811279719320585180e-01,-1.755390419181139805e-01,-1.931987996022907914e-07};
    cv::PCA pcaANN1_0_34;
    pcaANN1_0_34.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_34_pcaMeanLoad.data());
    pcaANN1_0_34.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_34_pcaEigenValLoad.data());
    pcaANN1_0_34.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_34_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_35_pcaMeanLoad = {-4.888308676464133915e-15,-2.226968747060003960e-15,1.058250943102921910e-14,-3.943969916648183740e-15,-8.103060343623419409e-14,1.552842206763723381e-15,-1.714034706481748113e-16,2.727279914953918720e-15,6.509106655280236119e-15,1.500167680861983600e-14,1.537347938633335400e-14};
    vector<float> cluster1_0_35_pcaEigenValLoad = {6.504647704983952394e+00,3.414352697700963724e+00,1.054328421413628591e+00,2.387469130865833150e-02,2.449643912449679661e-03,3.130870959721168429e-04,7.505600525366105296e-05,5.172939562577558772e-05,1.566149783904150736e-05,3.196563647871890478e-07,6.940291451174435868e-09};
    vector<float> cluster1_0_35_pcaEigenVecLoad = {3.900450211416521817e-01,3.790380528166911178e-01,-8.598251138727304455e-02,-3.436523509537511845e-01,1.812029040726441387e-01,3.509499050110699292e-01,-3.695329103953515770e-01,-2.366201068831208232e-01,3.905630275170418608e-01,-2.466022724690108137e-01,1.296494159285019876e-01,-4.824449547674738992e-02,1.237380924076024874e-01,5.029775125678516146e-01,2.584372867597842238e-01,3.462370075660473057e-01,-2.410017370438716222e-01,4.963953643874081771e-03,-3.701356943085180595e-01,-2.103133803356913023e-02,-4.154495618207849073e-01,-4.178008048182466072e-01,-4.557085857442156468e-02,-1.107151859185289827e-01,-2.873740774545911481e-01,-4.214324670798489519e-02,-5.959468184957200654e-01,1.788047406454020341e-02,-3.230975865152804771e-01,-3.970253834728627584e-01,-7.427131416935794928e-02,-2.532279335996397152e-02,-5.269293420242765480e-01,-7.653463785872560710e-02,7.850231180333004655e-02,2.026576823357287005e-01,-2.783789779169619227e-01,3.273381498252589950e-01,-4.583058958583653697e-02,-2.449803327958824106e-01,-2.214939422203404118e-01,-1.285298087028753089e-01,7.777942611323706013e-01,-1.720621490858428027e-01,-1.404900122618820968e-01,-8.301167207005662185e-02,1.524484183436277396e-01,1.315691085114161496e-01,-1.872424288367519341e-01,-1.943864562897665571e-01,-2.426087619192180134e-01,-5.217822609239353149e-01,-1.655958375135975214e-01,-2.655771520185045906e-02,7.076240624977403471e-01,-5.025468455935133694e-01,-5.911006370223771400e-01,9.121318815193422969e-02,-1.407445124029132466e-01,2.364753519443543450e-01,4.596376028748324072e-01,-2.246291165916820265e-01,1.989385230321524464e-02,1.377932877292864788e-01,-1.810414079915846908e-01,-1.065534826291277340e-02,1.385073258929251372e-01,2.462129000152106506e-02,5.169252904089440825e-01,9.978471718333362106e-02,-2.946992178016248354e-01,-4.069856991689649317e-02,-5.830704614045815193e-01,5.233670172691340383e-01,-2.324540232220810923e-02,-6.501711201313518235e-03,-8.363362561953160274e-03,-5.881777237153922311e-01,4.925587120041656775e-01,1.507246254574855504e-01,-5.165281380609885176e-01,-2.258079298700430004e-01,-6.429145976610382840e-02,1.375889913359482908e-01,9.785160201111281486e-02,-7.917662419028066723e-02,-1.776601152818748086e-01,2.129123062559930279e-02,-2.979478480563750864e-01,2.230248684840230311e-01,-5.397196416604052027e-01,2.412118880153832357e-01,3.623455399287488499e-01,-2.888502388916706631e-01,-4.769883291744817511e-01,1.982632993122044329e-01,-1.353535431611185280e-01,-1.101257584792388750e-01,1.817745451200172661e-03,2.898375977220450372e-01,-4.000732641780502807e-01,-5.638407326708686634e-02,-6.031427037841250449e-01,1.292589900895059762e-01,-4.997638290050552823e-01,-5.723704897497739613e-02,6.980662526318369421e-02,-2.262009960598642677e-01,-2.513680047176717891e-01,1.298063731520869611e-03,1.655181362218406671e-01,1.152765002060402444e-01,3.783382334256878859e-04,5.201739282773653163e-04,9.035054574800803484e-02,4.777983273023019284e-01,5.316070197138468957e-04,-8.071436044546881458e-05,-8.380192922400351296e-01,-1.434697715577474553e-01,-5.759063815682601170e-06};
    cv::PCA pcaANN1_0_35;
    pcaANN1_0_35.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_35_pcaMeanLoad.data());
    pcaANN1_0_35.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_35_pcaEigenValLoad.data());
    pcaANN1_0_35.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_35_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_36_pcaMeanLoad = {-4.280526550499214738e-16,1.559863349598345018e-15,5.711480671127194027e-15,-7.130098980370450089e-16,-9.820539443378745027e-15,-2.201942332173227007e-15,1.118241302025227186e-15,-2.150131924357386553e-15,2.997602166487922856e-16,-2.249990317516726815e-14,-2.410910977030451160e-14};
    vector<float> cluster1_0_36_pcaEigenValLoad = {6.557472332950582405e+00,3.786042618154541461e+00,6.431341021403876868e-01,7.299203228128358853e-03,4.007985029484998143e-03,1.950311662582061845e-03,6.879206461946280396e-04,2.504419974691231504e-04,1.087189692967077968e-04,1.308285908860097957e-06,9.409826951678817877e-10};
    vector<float> cluster1_0_36_pcaEigenVecLoad = {-3.894485342229950797e-01,-3.816451277445406798e-01,7.073919187690745625e-02,3.858836077101993056e-01,-3.534806701545376018e-01,-3.814613623386299279e-01,3.023757584949406940e-01,1.030705710527870245e-01,-3.895143719606091737e-01,-3.698578675253020708e-03,-1.565743311427798268e-01,1.847766612462425212e-02,1.063136430925271103e-01,3.977455503094085576e-01,7.845112853758914873e-02,-8.868630993593901168e-02,-9.784181874371493393e-02,-3.212949599492433972e-01,-4.950130259052661352e-01,1.629625836749103510e-02,-4.880969395273112577e-01,-4.688166616116713481e-01,-7.411186626065921490e-02,4.414922463513736711e-02,7.561416738654067604e-01,3.726474054378979203e-04,4.837464188822734878e-01,-1.193657416084666911e-01,1.157665033565911383e-01,4.112480845769140442e-02,-7.893725201594602170e-02,3.848381640683096183e-01,5.589717274474646086e-02,-7.473829673070955804e-02,-6.043998088657520640e-02,2.226350190574454824e-01,1.227234709011528757e-01,-5.493701878748025874e-02,-4.119730379855127134e-02,-3.427663515209552342e-02,-7.574667113825057918e-02,1.337322777846103317e-02,-4.871065102099202959e-01,8.228331899005916217e-01,9.198097894316015211e-02,2.585780594477387062e-01,1.923985409102798583e-01,-4.912363484348090947e-02,-8.420476122648042419e-03,8.763555545971922489e-02,4.551620060662034395e-01,5.950111393083824529e-01,1.703545789419757817e-01,-4.844159012850285939e-01,-2.293589021377616388e-01,5.315371739769938486e-01,5.425413287341147583e-01,-4.068803101126990812e-02,2.276375370465647807e-01,-2.188619201191678021e-01,-4.600564473367738105e-01,1.709724889817227367e-01,-1.268772425209697408e-01,-1.478951073001010252e-01,1.660847285139649410e-01,1.237084228102245526e-01,-9.431025677862520107e-02,1.478340511061370099e-01,3.495663452388002024e-01,-3.519419194305275500e-01,-6.944919217739736750e-01,1.198297628788170255e-01,-3.147037483107187339e-01,2.530810338716734109e-01,-3.144452626683503366e-02,2.392273102125416773e-01,7.215122904633615442e-02,1.787116499895638477e-01,-8.472272186541494887e-02,-4.236122918542811061e-02,3.417298286284358722e-01,2.016693990092285893e-01,-2.223483033755611349e-01,-6.627549569252212391e-01,5.478877980296033012e-01,-8.219949349856864318e-02,-6.540971911279988560e-02,-4.172268315859078286e-02,-6.710689666357320116e-01,6.063513429401099497e-01,-2.212157614493265034e-01,-1.135383764149402869e-01,1.864381253452564446e-01,-2.131348374514745181e-01,-1.267382711678972096e-01,3.217510324338693911e-02,-1.358765551115254933e-01,-6.141219221897575159e-02,2.568577725988818727e-02,-1.783897911458394436e-01,2.565247646327750153e-01,6.227061567130393743e-02,7.225736911583726663e-01,-1.284832464396543916e-01,5.023328402209271681e-01,-3.511043496775795563e-03,-3.882493979658722255e-02,2.643799924602882045e-01,1.900479016091409512e-01,-9.182258131602432944e-04,-1.514232861163136157e-01,-1.171699705621971899e-01,-2.667581120315295099e-05,1.681437094762589643e-05,-8.904684633386644732e-02,-4.980704796866884387e-01,-3.683468660214430615e-04,-2.797781762346199052e-05,8.334294655738170299e-01,1.128442789822993453e-01,8.178816849526046817e-07};
    cv::PCA pcaANN1_0_36;
    pcaANN1_0_36.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_36_pcaMeanLoad.data());
    pcaANN1_0_36.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_36_pcaEigenValLoad.data());
    pcaANN1_0_36.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_36_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_37_pcaMeanLoad = {1.859860793389151176e-16,-7.591268544445514954e-17,-4.706586497556219222e-16,8.729958826112341827e-17,4.175197699445033101e-16,2.562053133750361217e-15,-5.313887981111860221e-16,4.061328671278350291e-16,5.048193582056267161e-16,-1.660589994097456381e-15,-1.151975001619606921e-15};
    vector<float> cluster1_0_37_pcaEigenValLoad = {5.586773769706798731e+00,4.835115927506854483e+00,4.477538183301743024e-01,8.597899286768946603e-02,4.659865026808611421e-02,5.893634883837618570e-03,3.319060756674362470e-03,2.091546487870728633e-04,1.216965066353309729e-04,3.287067865511339382e-10,7.811773740470748812e-11};
    vector<float> cluster1_0_37_pcaEigenVecLoad = {-2.162714026878221063e-01,-1.984038768972324340e-01,-3.411831431586609398e-01,2.404979051486491048e-01,-4.171522071262213083e-01,-1.033584582246602906e-02,4.057747063920828512e-01,3.422255003331081125e-01,-7.898894454973265367e-02,-3.853889904005961542e-01,-3.591090031272343719e-01,3.852270551296189671e-01,3.990208968049459015e-01,-2.457910552876802629e-02,-3.743341559185169309e-01,-4.797526942740018563e-02,4.485599381956309473e-01,7.328044193562505138e-02,2.502026851069177327e-01,4.468131631510650625e-01,-1.863906477928034822e-01,-2.139853252163401720e-01,1.825937646923196378e-01,6.922267651551167189e-02,-8.792131275160661730e-01,-1.593332339082336943e-02,-7.435132531178638426e-02,-5.741427315973021001e-02,-2.958396597638675574e-01,-1.505024602131412592e-01,3.363595715188728158e-02,1.699673970223579064e-02,2.611154224268211754e-01,-4.561320238173162400e-02,-1.891105563600094241e-01,-1.198923484181836641e-01,-4.894004345338165418e-02,3.970948885013481644e-01,1.664519754709467003e-01,3.862155512215387221e-01,5.304754309984190952e-01,-5.359992913919790596e-03,1.201182859948726200e-01,5.612245116835746783e-01,-3.767707885452068473e-01,-3.566977164786073184e-01,-5.488486064349015758e-02,-3.704561882038109183e-02,8.123975868469604511e-02,7.119583957297681565e-01,-6.717114106269417295e-02,-4.102876406459967096e-01,8.917127335057405124e-02,-1.752127624119218796e-01,3.797620509706559760e-02,-2.516342628729883457e-01,-2.949431507500951174e-03,1.508063217692127422e-01,4.706867713058537905e-02,-3.002589755175803510e-01,1.437344966190347573e-01,-6.948300914297977915e-01,5.373770803137040142e-01,-3.457020192321005880e-02,-3.948287312279308292e-02,1.630382014090852871e-01,-9.259096534194620476e-02,-1.494228624162935726e-01,-2.333292014651331681e-01,-5.159069068578012868e-02,5.049299109098228655e-01,5.034738015480690054e-02,-2.106430055603449869e-01,2.377271406252340624e-01,-9.412924576255506104e-02,3.628633502039345093e-01,-6.427221305294570364e-01,6.990174992541191568e-01,-6.607422605037778229e-01,1.212160762999808794e-01,9.654048764782499625e-02,-3.881314220840878515e-02,4.461057864567918863e-02,-1.511842860500522967e-01,4.786470803270382463e-02,-4.761707071450953233e-02,-1.378491562034943330e-01,-2.944045454597415956e-02,-8.609881094633058118e-02,6.600485711552205037e-02,1.675092417584838483e-02,1.152559004745971616e-01,5.353149780953251335e-01,-2.778554237677435812e-01,-1.968866221323660459e-01,1.760251624289444969e-02,1.693440381509852821e-01,-7.369082879868293912e-01,1.070777902949490018e-02,1.791410976289626866e-01,3.033286566064908318e-01,2.044865228466789114e-02,8.668862872945876097e-01,1.131722893917508355e-01,3.034834832492954160e-01,8.515220027431301148e-04,5.024478043324096996e-05,6.109007370207440724e-02,1.238841695079504895e-01,8.292637833419383311e-05,-1.656098748699650347e-01,-2.799093465342496478e-01,3.246956364631534229e-03,1.379870922566995561e-01,-8.879088351119129863e-02,-2.575059357183051012e-01,-5.087584898227478971e-04,-2.414563008419976084e-05,8.603923065618721555e-01,2.463835184725153560e-01,2.099053523253783367e-06};
    cv::PCA pcaANN1_0_37;
    pcaANN1_0_37.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_37_pcaMeanLoad.data());
    pcaANN1_0_37.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_37_pcaEigenValLoad.data());
    pcaANN1_0_37.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_37_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_38_pcaMeanLoad = {1.124923732492962240e-16,-2.004409559714732903e-16,6.345592509198936970e-16,8.385795096765718609e-16,-6.790448712502971998e-16,1.077881467315983803e-15,-4.745132835243041279e-16,-2.904348545709102843e-16,-8.263076144130122943e-16,4.397429136108852574e-16,-3.415677515024085474e-15};
    vector<float> cluster1_0_38_pcaEigenValLoad = {6.024069291217815980e+00,4.015340474423161332e+00,8.179666007435740793e-01,1.335906379925544396e-01,8.317336765163205192e-03,4.613204372603453389e-03,1.804763499305615760e-03,5.178924094670726017e-04,1.162029682384859119e-04,1.038810752593931989e-09,9.925924692571673807e-11};
    vector<float> cluster1_0_38_pcaEigenVecLoad = {-3.469869519840901861e-01,-3.031195374750421112e-01,-1.443756429076458250e-02,3.793617017523858714e-01,-3.766129277239141371e-01,-3.629753713553237060e-01,3.094274600696569344e-01,1.827627235241546799e-01,-3.231585284313323592e-01,-2.694655049388857138e-01,-2.526178548524993239e-01,2.485708601933500905e-01,3.257380869686967162e-01,3.137213251713754647e-01,-1.819378626813436817e-01,-1.419100713475554554e-01,1.844631752836679572e-01,3.169280776377048636e-01,4.396385577448352899e-01,2.961054207625680723e-01,-3.411950912535477443e-01,-3.854888593450990775e-01,1.237236051826115513e-01,1.873632364029585370e-02,-8.587065779864359039e-01,-2.456006402770953209e-02,-2.474671840251508048e-01,2.109382219488979970e-01,-4.249822667472997334e-02,3.701468301999147337e-02,1.532781444560416817e-01,-3.367562834299519525e-01,2.347605587687232737e-02,3.226635758702077750e-01,3.818725563515049659e-01,1.305807038545885555e-02,3.767296613937640148e-02,-3.254090256738303988e-01,-4.938645538347845032e-01,-3.678058688053214009e-01,-3.772982521668983846e-01,-2.407951538720491669e-02,3.319385838205509559e-03,-3.470628196860138237e-01,5.509463983486943828e-02,3.372069817625757415e-01,-2.732925143741404828e-01,-2.736302832688520745e-02,-1.812590340106421099e-03,-3.541511421457465558e-01,1.154501337381734910e-01,5.936517636091578343e-01,-1.138967067822518331e-01,5.273603824055500544e-01,1.598736965539029886e-01,6.017707292306800904e-02,-2.088656667828268643e-01,-2.664233217333928372e-01,-5.080329455991779153e-02,4.096948774851129071e-01,6.768500306172962888e-02,1.835423486674574167e-01,-1.054877519463253699e-01,-4.578492831588674289e-02,3.274657917265559326e-01,-7.433806398999945886e-01,-6.126342562623884325e-01,1.966714735347753207e-01,1.998729162047625449e-02,-2.780283633327379489e-02,-1.136331535703838796e-01,2.800630987389861604e-01,-5.849317955845370065e-01,2.445438661138235048e-01,8.681285089195894334e-04,7.654081061710678313e-02,-2.926997093860567722e-01,7.450534926170555849e-02,-1.020073854600435370e-01,7.629901621452524207e-02,-8.693211990804224076e-02,-6.790186533111158829e-01,4.053681083143723662e-01,2.190988548522615487e-01,-1.814105330119430981e-01,-5.993453049877524308e-02,5.104153087383056508e-01,-1.565417156525677686e-02,5.003085435079246412e-01,-5.601365142454927115e-01,1.069365408188322070e-01,6.697042521187500375e-02,-8.041267275190511210e-02,3.261027266092984822e-02,-4.791216216195384736e-01,4.163292626683020581e-01,-8.192768705154808428e-02,2.005974043778515487e-02,-4.986215914989538395e-02,-1.454325691625321937e-01,-2.189022672025234817e-01,-2.227716713730287443e-02,-8.970458840541387646e-01,-9.861597118091507130e-02,-2.600118542773004471e-01,-4.993906435773735235e-04,2.129592105416177011e-04,-1.856073835169947672e-01,-1.181602938952967391e-01,2.240925763605468356e-04,-1.985082356066362463e-01,-2.962192395888763596e-01,2.723503573494622291e-04,1.116275301720876141e-02,-1.134455031937788710e-01,-3.230983717946278033e-01,-4.070004583856848507e-04,-3.305638547612790222e-05,8.508773500783516353e-01,1.773952919172085696e-01,1.075476644100063809e-07};
    cv::PCA pcaANN1_0_38;
    pcaANN1_0_38.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_38_pcaMeanLoad.data());
    pcaANN1_0_38.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_38_pcaEigenValLoad.data());
    pcaANN1_0_38.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_38_pcaEigenVecLoad.data());
        
    vector<float> cluster1_0_39_pcaMeanLoad = {-3.044713217585773181e-15,-3.147983388908497054e-14,8.545888638358453781e-15,-2.201937813560998157e-14,-8.073563524412836967e-14,-1.095459091773144956e-13,-2.891839528659772650e-14,8.434927789022250042e-14,1.037719180246135783e-14,-1.135698598882359057e-13,-1.577172074485392806e-13};
    vector<float> cluster1_0_39_pcaEigenValLoad = {6.934859100943248755e+00,2.895497541144969489e+00,1.165308816301116712e+00,3.481092900176747679e-03,8.013169129293082641e-04,6.100620566067862355e-05,1.089927130047724172e-05,4.205857036604188857e-06,3.906738805364558171e-06,6.784771278094349335e-08,2.722619374510384827e-08};
    vector<float> cluster1_0_39_pcaEigenVecLoad = {-3.750875456849243061e-01,-3.457395509388123123e-01,1.602164622451876172e-02,3.593735033014267000e-01,-2.469248707110425767e-01,-3.664738136434346760e-01,2.803471048890748274e-01,-1.113371914590406964e-01,-3.695937215126791631e-01,-2.601760216089778477e-01,-3.461372408167546766e-01,6.803528783584306128e-02,2.255234560548217970e-01,5.815730290571797800e-01,1.897566285323110391e-01,4.449137355826898177e-01,-1.532274122079418655e-01,3.511476306494558108e-01,1.068496904318721463e-01,1.142397557440467254e-01,-4.015209433846786413e-01,1.996432508058021971e-01,9.611567226684726573e-02,1.427029349729695695e-01,1.253389377325996867e-01,-7.310237744402601004e-03,5.644639797240964124e-02,2.152672317045321859e-02,-2.898688350447624074e-01,-8.693854971552595901e-01,1.121865673709680072e-01,-2.301994338573966625e-01,-2.134293229891509880e-01,-1.906123357563170861e-01,-4.587652386908085134e-02,4.053916656703746013e-01,-9.504212181475467369e-02,2.786544341144340242e-01,-1.539530235699728133e-01,6.426821673148409853e-02,-1.987054773241549721e-01,-2.536740384866252307e-01,7.593667229138694186e-01,-4.726985626864422391e-02,-1.006641616570344011e-01,-1.546941029182042626e-01,-7.281631634589894042e-02,1.128203160436673236e-01,-1.770957546026924734e-01,-1.260255685647833634e-01,-3.272745134997329802e-02,-2.873085060907442090e-01,-1.640505215497608804e-01,-1.407168645199079193e-02,8.887815375485441649e-01,6.641568928491667911e-01,3.671896455574031881e-01,-1.423907506939187662e-01,3.074872037866973606e-01,-1.705597367341970816e-01,-4.259767525540061328e-01,5.835664491238796991e-02,-1.027744002022253165e-03,-2.372049705416169330e-01,1.923819088661679333e-01,-4.487216082972850933e-02,-5.245433683375078093e-01,7.034257508096035671e-01,-1.322785881117438112e-01,-1.882206772431924968e-01,-2.369815968837307718e-02,-2.734391606376532780e-01,-2.211210983286943932e-01,1.034374078788366652e-01,-1.773960234993324780e-01,-1.008665195174752588e-01,2.353722340885444630e-02,5.619579829467341581e-02,3.869688918643460814e-03,6.555367987378907246e-01,2.366164188571365928e-02,-5.823406442813007233e-01,7.988390875959180959e-02,-4.175835227127789873e-01,2.073471424965462884e-01,-5.185099120240187209e-02,-3.082822395971203389e-02,-5.374428425087307039e-03,3.126697608440254239e-02,-2.895865164668864900e-01,-7.211002996734909576e-02,2.640653097013600514e-01,4.808337070444894112e-01,-2.582299314200094398e-01,-6.935967148629954560e-01,2.105274367712889894e-01,-9.767644325924490500e-02,-8.598410458009611568e-02,-3.971379579968336085e-03,2.534101138678634402e-01,-2.428251340869708452e-01,5.882587293480705248e-02,-7.826732092565709120e-01,2.084438916551302132e-02,-3.814497040932950389e-01,3.351075574064800444e-02,1.763328225788846418e-02,-2.343201961916977216e-01,-2.418737925872888328e-01,5.272956312234455822e-04,1.198898382073039504e-01,1.035803632601469543e-01,2.566873954116516811e-04,1.360593396115940615e-02,1.687426602283913779e-01,5.721693328494513731e-01,-2.817601330699054900e-05,-2.470089628094538042e-04,-7.691749654674265857e-01,-1.650161429506645239e-01,-1.167739372250389152e-05};
    cv::PCA pcaANN1_0_39;
    pcaANN1_0_39.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_0_39_pcaMeanLoad.data());;
    pcaANN1_0_39.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_0_39_pcaEigenValLoad.data());
    pcaANN1_0_39.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_0_39_pcaEigenVecLoad.data());
    
    
    
    // GrandChild of parentCluster1 - childCluster1 - grandChild
    vector<float> cluster1_1_0_pcaMeanLoad = {8.291419509371455974e-16,5.928263089010058105e-16,-1.256954751174984826e-15,1.279703527060647689e-15,-1.438265890323402550e-15,-6.605633356053303649e-16,1.350496359480956956e-15,5.025102732952397380e-16,7.333933718362958765e-16,-3.902942967249176281e-16,5.201320862574174345e-15};
    vector<float> cluster1_1_0_pcaEigenValLoad = {6.913460635479972360e+00,3.779553430588466156e+00,1.935811586837736797e-01,1.061346834878396928e-01,3.936348139187999771e-03,2.115812612094560702e-03,9.805071747003781153e-04,7.134628139234594404e-04,3.780287564348934622e-05,1.181921463934329791e-05,7.858287868343988741e-10};
    vector<float> cluster1_1_0_pcaEigenVecLoad = {-2.925370513975929510e-01,-1.958454198746797659e-01,-1.664393546414115743e-01,3.790360404449523157e-01,-3.650989264050188421e-01,-3.626672974232857949e-01,-2.984961260384231263e-01,-2.774962323403989406e-01,-2.656583454688380974e-01,-3.387407685240529931e-01,-2.974015982826896387e-01,3.283622138513015987e-01,4.384623731467166552e-01,4.556182106478203764e-01,1.106193075083942816e-02,1.297379393607423492e-01,-1.352396698765935268e-01,-2.914948448483217769e-01,-3.296659099830673845e-01,3.469765946094178211e-01,-2.165261867001748997e-01,-3.101157508635805637e-01,9.260889111217349146e-03,1.029640422993424453e-01,4.009906526681672467e-02,1.725792341541999564e-01,-2.260114755630538430e-01,-9.106570893859461391e-02,5.380396040505418531e-01,5.312238505153901169e-01,2.669688660497263055e-01,-3.605462942026835815e-01,-3.543946441646975143e-01,-2.670491597531227460e-02,2.026706587316726704e-01,4.659764773375312252e-01,6.438256810324231860e-02,1.820204907035086472e-01,-4.305081475304359806e-01,2.418300678781857005e-01,1.205374000207486002e-01,-6.367904538470132714e-01,1.998696501384147894e-01,1.590354569371648123e-03,1.154730319749941725e-01,6.827354485029791809e-01,-2.050179135037547562e-01,-6.324420223621125825e-03,-5.918852543335350047e-01,1.752024718293891392e-01,-7.252268618545222589e-02,3.238817019737050273e-02,-2.175897683618275291e-01,9.302207692485925383e-02,1.874431513587057341e-01,-4.984170108991811676e-01,5.794822395168660462e-02,3.312590505913325378e-01,2.776598869695273350e-02,-1.704228944211390318e-01,1.912390318919456600e-01,4.637053974500074394e-01,-5.195487930644021590e-01,1.620170214141814780e-01,-7.288575939480605725e-02,2.357692822419971967e-01,4.026217345618219867e-01,2.332881588064495901e-02,-2.603296059626193371e-01,3.439704756547767306e-01,1.510045630512552861e-01,-3.646922153288540414e-01,2.320765076406418326e-01,-1.792808188781425394e-01,9.824747862391118580e-02,-2.610156099113450923e-01,5.759155235551489671e-01,2.702715880915373958e-01,4.030262799200227258e-02,-4.041759904141959958e-01,-4.868973211355263203e-02,1.136461977959687397e-01,6.609620467769175556e-02,4.400265903945896340e-01,-4.500772838196241965e-01,-1.537548152051599615e-01,2.453303713996998481e-01,-5.121478136885180277e-01,-4.410136969348565916e-01,4.133730003567889777e-01,-2.522639549578696294e-01,5.103634445186864266e-01,4.684194169739652747e-01,7.277733364620592171e-02,-9.897579913918988503e-02,1.083206692810216587e-01,1.461099304316965108e-01,1.962762276890023250e-01,-6.638069895475331994e-02,-3.341017927039698354e-01,2.648532926240662055e-01,-3.153351129990630275e-01,-6.635603967126847413e-01,1.811268087746017719e-01,-4.066072793919460193e-01,2.001574822300546119e-02,-1.279459117116602852e-02,4.525136328807243674e-02,-2.775820894802153993e-01,2.607407508178830394e-02,-5.272375517236190662e-02,-7.099014099402714550e-02,5.386931926169431175e-07,1.856169083125493537e-04,-3.135993786265565686e-01,-5.303668740044508167e-01,-6.637990051020893970e-04,-1.853525014444999197e-05,4.494159524281028939e-01,6.407588005486691829e-01,-1.388733057977872109e-06};
    cv::PCA pcaANN1_1_0;
    pcaANN1_1_0.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_0_pcaMeanLoad.data());
    pcaANN1_1_0.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_0_pcaEigenValLoad.data());
    pcaANN1_1_0.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_0_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_1_pcaMeanLoad = {2.972406687591975581e-15,1.197879474495817990e-16,2.910914419624528829e-15,-6.879563144888834053e-15,-6.071309952415206969e-15,-7.003977733567156718e-15,7.236066881750721008e-16,-9.354227357017906029e-16,-7.013146895275024862e-16,1.513534175345404326e-14,-2.500405161510793295e-15};
    vector<float> cluster1_1_1_pcaEigenValLoad = {6.279398431277669168e+00,4.668362528638581033e+00,3.716639548716955954e-02,8.482076641155219046e-03,5.509802864112610735e-03,8.181803466329692388e-04,2.671260279116240382e-04,1.212608801062149179e-04,3.586665654907101592e-06,8.358587910166658266e-07,5.227221364111954041e-09};
    vector<float> cluster1_1_1_pcaEigenVecLoad = {-3.451297789510283653e-01,-2.838156175547656979e-01,-2.512314689654507882e-01,3.928433116863702668e-01,-3.868040501726003333e-01,-3.718711211832768648e-01,-1.425443960804507193e-01,-1.381755158178286924e-01,-3.216153334413157650e-01,-3.024800436939861781e-01,-2.462590725532470548e-01,2.322022954960767382e-01,3.249404861657672061e-01,3.568912375583871976e-01,7.524720460998222948e-02,1.078829600190244903e-01,-1.607950686732453338e-01,-4.316159125428115084e-01,-4.334784976962439140e-01,2.715915467534028571e-01,-3.011071487509262012e-01,-3.624156491862055018e-01,-5.441386273897999559e-02,9.357838916065172596e-02,4.810043313048169566e-01,2.676211360041172993e-01,3.840300674367795875e-01,-5.400243747799553518e-01,2.189183253658891215e-01,4.862826380864945786e-02,-3.412633656922698377e-01,1.283449679391281684e-01,2.509332632810006847e-01,6.912851497924734669e-03,2.176959060991709438e-01,2.097333631831281020e-01,-3.687443942782440698e-01,-2.127256261715645691e-01,-8.955413812284944430e-02,4.672385407871807589e-02,3.906551213306000414e-01,-3.415929083796776511e-01,1.996275953409476223e-01,-6.387461335181534583e-01,1.418905050978234716e-01,2.063517510045379255e-01,8.488286096950271864e-03,3.432591854791123276e-01,-1.068160394089261306e-01,-5.367672065986518054e-02,4.010210764474066436e-01,5.222510442708848677e-01,3.742156084182775011e-01,-4.744300147799995759e-01,-8.006900700591515485e-02,2.140544042597744001e-01,6.047055931546932994e-01,-1.146244734576840479e-01,-2.016184456052985685e-02,-5.243327353346584063e-01,-8.231854676308734964e-02,-1.207025143166037401e-01,-5.347158905589898675e-02,-2.507005733798744473e-01,1.240217291098098806e-03,4.615027668581611620e-01,-3.923690861495026660e-01,-2.052253100105087547e-01,4.947173168342961502e-01,-3.675284333288297844e-01,-2.234571161132662687e-01,6.254770042541649665e-03,-2.768066906700994423e-01,2.389555764537497073e-01,1.216019133128612983e-01,-3.443135408081916538e-01,3.272215508966093145e-01,-5.400480026267101552e-01,2.895641046376612460e-01,2.721182489610897703e-01,1.665282330932177923e-01,-1.931075567127185089e-01,3.660337474008940606e-01,4.269415659232295157e-01,-3.760602052828877495e-01,6.997294280901007746e-02,1.112336131819521984e-01,-1.023721128840282268e-01,1.742499495173520097e-01,-1.313488123617462255e-01,-7.809460102223345079e-02,-5.385362443556224177e-01,-7.083179298328368123e-02,-3.129032783235132231e-01,5.446560676942912016e-01,-3.933081846941541837e-01,-4.210290439526379806e-04,-3.192259563312576653e-01,9.583226146155865433e-03,5.265573863421845191e-01,-4.469659155932813599e-01,4.427809705629408010e-01,2.476990965547032075e-01,-4.007202000559690336e-01,2.402023457845635090e-01,1.110836549964968334e-01,-9.596890050026184171e-02,-1.198119487937329558e-01,1.066069514710048932e-01,2.357914346448966320e-03,6.910571125766311329e-02,8.042521322577129983e-02,5.175163807925794177e-05,-4.368993824425620271e-04,3.268955376449083627e-01,4.867520495449722540e-01,1.609829566495416019e-03,-1.392696305268315633e-04,-5.939097505057930881e-01,-5.405888817530870583e-01,1.238163227670800090e-05};
    cv::PCA pcaANN1_1_1;
    pcaANN1_1_1.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_1_pcaMeanLoad.data());
    pcaANN1_1_1.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_1_pcaEigenValLoad.data());
    pcaANN1_1_1.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_1_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_2_pcaMeanLoad = {1.404384680722420180e-16,2.087598849722516551e-16,8.350395398890066203e-16,-1.089347036127931449e-15,3.909503300389440041e-16,-5.162062610222950464e-16,-3.036507417778206228e-17,-1.442341023444647866e-16,-1.764969936583582085e-16,-1.977525455828056681e-15,-4.118263185361691943e-16};
    vector<float> cluster1_1_2_pcaEigenValLoad = {6.097302587909983806e+00,3.987368946956241444e+00,7.988699708100509556e-01,9.534555116839216193e-02,1.696598529747937734e-02,3.705101401905453503e-03,1.825244151006138538e-03,1.274450915928769783e-03,2.808040725253576307e-04,1.761828884303302457e-07,2.626448576132751599e-10};
    vector<float> cluster1_1_2_pcaEigenVecLoad = {-2.727804746385710799e-01,-8.213680545771252783e-02,-4.745057660802413230e-02,3.886627287008958542e-01,-4.031586223692552040e-01,-3.301274568167266721e-01,3.310417205515300276e-01,3.110561883017959328e-01,-6.633287234593686355e-02,-3.824596049292816047e-01,-3.701257881121742255e-01,3.676328089865615323e-01,4.751904002812191163e-01,4.067110583849053995e-01,-1.327372721096441444e-01,-4.376256516606678686e-03,1.865362196973936737e-01,2.672351681975397297e-01,2.692696473032604731e-01,4.665944334138335536e-01,-1.513321226748697013e-01,-1.914671387236030475e-01,-6.537228706151681362e-03,-2.658555717811019736e-01,-6.342220483432738920e-01,-9.114431745447124089e-02,-5.345033593473372951e-02,4.915502190144471761e-01,1.822653540372779213e-01,3.304704934443210007e-01,3.374885799434482747e-01,-6.525775013190557305e-02,1.169021312719690231e-01,-9.317886097758237840e-02,-5.857995679161878688e-02,1.865613789955300750e-01,-1.436778612140357236e-01,2.485651645461327830e-01,-8.464156444240324151e-02,4.307705280196695297e-01,5.703076777852376100e-01,-3.826307549879227055e-01,3.724257930192188537e-01,2.599373309407452259e-01,6.136885427897249556e-01,6.212784063143269447e-02,-3.100390721125640958e-01,1.336974557184277268e-01,9.565358858488427762e-02,-4.355204072440945762e-01,-3.698931885234869044e-01,3.861156892538906704e-01,-6.426946747841948138e-02,-8.799723850305918305e-02,9.444182861247850391e-02,-3.962722901046170955e-03,6.904465746289819572e-01,-3.741146041329621030e-01,7.884171105700199175e-03,-4.106092069889648588e-01,1.593446556618052790e-02,1.965621879407838946e-01,-1.612201419707608996e-01,-2.450142646674272895e-01,1.727026561227170964e-01,2.447514534098622352e-01,3.601975707477846900e-01,-1.044149197095075449e-01,-2.767569712970517903e-01,-1.099792195054408589e-01,2.184342695723657801e-01,-5.567546744878840159e-02,4.029835024489319406e-01,-2.942408585747279814e-01,-1.783849545761714561e-01,2.429293447624296387e-01,-6.164761570563839221e-01,-3.175978044529587652e-01,2.624562996935048131e-01,-8.268272494322857769e-02,-1.581382128621302563e-01,3.804591331450698881e-03,1.977829255665312647e-01,-5.011264720264847483e-01,3.619673360216239533e-01,-1.313903512952785679e-01,2.542282273486157762e-01,-5.433489929309837096e-01,4.066713643856572635e-01,-3.288306838422085376e-01,2.705811161937311526e-01,-5.288540382491581371e-03,-6.373084686092380657e-01,3.401462929734388463e-01,-1.059404006810459459e-01,5.997417060491207208e-02,-3.000399479346737008e-01,1.597687120247851811e-01,-3.185604390094202987e-02,5.833874854644213737e-02,8.908468886688807042e-02,5.060476665083446512e-02,8.644664597209475998e-01,2.301398219617171448e-01,3.136717847615237420e-01,-2.625130742030915704e-03,2.028251446505636296e-03,3.642947701113497666e-02,2.934272951395626716e-01,-2.321763478978341490e-03,-7.541154180231629534e-02,-1.300346344371313689e-01,5.247452529828287821e-05,9.818109176258727009e-04,-2.969822173550715205e-01,-4.014910010610772684e-01,-1.211765779364835753e-03,-2.391800734229750604e-05,5.594519644917003154e-01,6.442217751421297489e-01,-7.490672765051429628e-06};
    cv::PCA pcaANN1_1_2;
    pcaANN1_1_2.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_2_pcaMeanLoad.data());
    pcaANN1_1_2.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_2_pcaEigenValLoad.data());
    pcaANN1_1_2.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_2_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_3_pcaMeanLoad = {-1.518132442618424916e-16,2.220446049250313081e-16,3.461909495316782158e-16,8.768278967646603243e-16,5.703637775071091880e-16,6.047700501552370333e-16,8.371010664905333927e-17,1.503944288949093905e-16,-4.384139483823301622e-16,7.150829449342861491e-16,3.433533187978119740e-15};
    vector<float> cluster1_1_3_pcaEigenValLoad = {6.689428549336846608e+00,3.481279182423047125e+00,7.022470227864112680e-01,9.796391403647353169e-02,2.157798282524561739e-02,7.352188655615804654e-03,2.560086575470552333e-03,1.159438614344650937e-03,8.262748031981517575e-04,8.612405799250544860e-08,1.476822434135078305e-10};
    vector<float> cluster1_1_3_pcaEigenVecLoad = {3.416497514872564589e-01,3.737302511225142343e-01,3.789611219268993469e-01,-3.845182344898225857e-01,3.611421824205989228e-01,3.320170519020932409e-01,2.634793681391568027e-02,-6.066907989673396562e-02,2.837012674373329268e-01,2.637673913242057910e-01,2.388341402284652748e-01,1.615237309269171306e-01,1.167601610052140804e-01,7.747437280438202421e-03,-2.200401229466008787e-02,-1.687823626745457439e-01,1.981563634464259815e-01,5.314034446264053191e-01,4.381775221229463613e-01,3.318030975968296881e-01,-3.780122661443127696e-01,-4.057139247039318053e-01,-4.146323322953677226e-01,3.487195049290498644e-02,1.883550523103228944e-02,-1.025392381550003923e-01,-1.951454667404370624e-01,3.932077964679067117e-01,-6.681701352774742364e-02,-6.532009675575374263e-01,3.198640916975125092e-01,-2.269336386040238240e-01,-1.958388349396305850e-01,2.759749576331118823e-02,-3.644108309219457609e-01,-6.052818353607286594e-01,-1.426444719136055472e-01,2.901953285607225888e-02,4.190584035322609258e-01,-1.202733735725463465e-01,2.317818498849244513e-01,2.598623768408330204e-01,-9.678639141840521265e-03,4.092271481847362669e-01,-5.458421743462534836e-01,-4.171421007357205002e-01,3.552231919721651199e-01,-7.848278114267415173e-02,1.935905302920033211e-01,9.700457524362908479e-02,5.022917820350221163e-01,1.296184284145674437e-01,-8.889145451044250246e-02,1.933482105252967986e-01,1.855676478487784942e-01,4.075886453627134975e-01,-1.159638696447661127e-01,-1.873733723717520838e-01,1.150501634525324390e-01,-1.161132037688781724e-04,-1.763357218063636989e-01,5.907313536470776283e-01,-5.283920062169603638e-01,-4.419135376688692468e-02,-1.191342809786334195e-01,3.109288648372739994e-01,-2.243822642814723156e-01,4.663812424142195212e-01,1.040062706418633798e-01,9.149127913750154661e-02,-5.588454529189560427e-01,1.153426929000848748e-02,6.713347903610274170e-02,1.580178098905934136e-01,-4.276937258873281938e-02,-1.022880907105733761e-01,5.989518287056452284e-01,-3.097682867847380561e-01,5.031904071781547749e-01,-5.582035017054179926e-01,-9.683597636202725956e-02,1.899798512446048693e-01,-2.680744389379164858e-02,2.938792720047617157e-01,-2.326599293395881229e-02,-1.269170918997375164e-01,3.938147867704027139e-01,-1.869741068398396711e-01,2.631202432337202413e-01,-1.939465685675300921e-01,4.678497249265995556e-02,-1.293749193606537617e-01,-5.938596703381967545e-01,3.114206964537886702e-01,7.647424085980418507e-02,-4.914563571896127248e-02,-2.540762425623047105e-01,5.513955227015283622e-01,-2.184450548345379106e-01,3.565750196617550882e-02,6.795685357182086606e-02,6.097525761111095843e-02,8.757382861218769854e-01,1.453879305915213860e-01,3.391507663980971587e-01,1.695606721760041817e-03,3.345202887772475461e-04,1.628716970300531086e-01,2.465400928149172610e-01,-1.339414427807599818e-03,6.020169356349161505e-02,1.108190044436758587e-01,-5.175687667587266767e-05,-6.685783743355245678e-04,2.061070163918484743e-01,5.166376590515402434e-01,1.511944822814935419e-03,5.093116587599102042e-05,-7.215990178874113203e-01,-3.924187183537789503e-01,3.542268302524427693e-06};
    cv::PCA pcaANN1_1_3;
    pcaANN1_1_3.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_3_pcaMeanLoad.data());
    pcaANN1_1_3.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_3_pcaEigenValLoad.data());
    pcaANN1_1_3.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_3_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_4_pcaMeanLoad = {-1.062692444584184289e-16,1.146379474595188728e-15,-1.524432311756012245e-15,5.055227958886964080e-15,3.267513593985220634e-15,1.441595435700675199e-14,2.598017353897184330e-15,-1.947649577811663642e-15,-5.996242118566259504e-16,-9.508971994139280187e-15,-1.516196445310484918e-14};
    vector<float> cluster1_1_4_pcaEigenValLoad = {7.469855551787376591e+00,3.502434876294381105e+00,1.991504693143427915e-02,4.490856933215553980e-03,2.264415999791520497e-03,8.935548908940917513e-04,2.449660120421220185e-04,1.038298599807823308e-04,2.263955096614821833e-06,2.834457289356417803e-07,3.649823211678318181e-09};
    vector<float> cluster1_1_4_pcaEigenVecLoad = {-3.275330492833584128e-01,-2.968458301150265766e-01,-2.906033830529123341e-01,3.649844945333860502e-01,-3.541422988048015807e-01,-3.486479504980705690e-01,-1.877811596312455866e-01,-1.532796440252482961e-01,-3.074703662575362650e-01,-3.283723207333177352e-01,-2.807947039285668689e-01,2.380222947700707525e-01,3.118703754861165689e-01,3.229536449311818380e-01,3.205734255830947760e-02,1.315864803535605754e-01,-1.560693096071737729e-01,-4.583455126209990960e-01,-4.846350062337547171e-01,2.874469141628945845e-01,-2.348923529747790617e-01,-3.410733802752821675e-01,-1.974968114289564133e-02,7.905168733810491455e-02,4.251152302843393405e-01,2.004517517259550852e-01,3.314435079651141258e-01,-5.703239864816943561e-01,1.246182925501929661e-01,-6.288513914334478705e-02,-4.497253157310527882e-01,1.706207270989910374e-01,2.940818199363273711e-01,1.397677835486501041e-01,3.328740443992280751e-01,1.695207685219745630e-01,1.348092367048852880e-01,-1.059927685789014279e-01,-2.116282180502877530e-01,3.150087231955186473e-01,6.290160399693361937e-01,7.191354420543474846e-02,-2.621476937091716808e-01,-4.449083062099447039e-01,1.570582071840280758e-01,2.887431486050683338e-01,-1.696796704073768314e-01,4.072909881628122841e-01,-2.058783894274017756e-01,-4.481944555506563177e-02,4.830865551781107076e-02,-2.728278645670748764e-02,2.735721086918205813e-01,-3.782213039793825282e-01,6.572040399265322019e-01,1.885251062205427486e-01,5.992141394258269083e-01,-1.951168294897926148e-01,-1.041831965774915048e-01,-4.276434702794366660e-01,9.492270442546676956e-02,-1.173229092640857008e-01,-1.090831910521292969e-01,-4.963102547960633326e-01,3.020296511932910044e-01,-3.710983057604416713e-02,-2.956604189944895822e-01,-1.044823053264400808e-02,4.051917450144046362e-01,-4.832065834782034441e-01,-3.328872321288208758e-01,-5.932526135565743125e-02,-4.033189982462405676e-01,2.896188193237722031e-01,-5.737227658865053093e-02,-2.636814422407007807e-01,2.847957981940588135e-01,5.770532627115577684e-01,-2.090362665524409247e-01,-4.236655549199410675e-01,-2.658591050818273627e-01,1.974934021687634600e-01,-3.662936338517909229e-01,-3.351419096012520638e-01,2.689308508330431335e-01,-7.429069618307389267e-02,-6.175192344645642761e-02,7.738750085786839927e-02,4.611588833490398720e-02,1.435574314849531394e-02,-9.779586423518235594e-02,-5.501642005669331592e-01,-1.260801968591569455e-01,-2.692699500168428406e-01,5.786426022479876918e-01,-4.069590043478951147e-01,9.683980080417452230e-03,-3.106130657222114788e-01,-1.699526098680373800e-03,5.747213220382403343e-01,-4.549272458353570969e-01,4.262490353708848212e-01,1.543131857023575526e-01,-4.216592750749281748e-01,1.917534093709389043e-01,1.182556992928616296e-01,-8.692827038558205432e-02,-1.450972193370096142e-01,-8.639205222387338207e-03,1.056295072953943297e-03,5.564696710968685539e-02,6.453464153019206062e-02,-1.864251758135616931e-03,-1.118052304164238739e-03,4.091500971586990998e-01,4.754426712472240024e-01,1.017799156418358521e-03,1.753317465755181823e-04,-5.140900622482603710e-01,-5.787873315630334137e-01,-5.848067316070230453e-06};
    cv::PCA pcaANN1_1_4;
    pcaANN1_1_4.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_4_pcaMeanLoad.data());
    pcaANN1_1_4.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_4_pcaEigenValLoad.data());
    pcaANN1_1_4.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_4_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_5_pcaMeanLoad = {-2.895969720314774287e-16,-4.221160189940886224e-16,-3.873380104006670018e-16,-4.222561199765739380e-15,-7.928067361817908011e-16,1.819664525456750458e-16,-1.884275802085287430e-15,1.582316978658043970e-17,-1.368044887798100506e-17,-8.824713649724132884e-15,7.808074990936339807e-15};
    vector<float> cluster1_1_5_pcaEigenValLoad = {5.938773307441244320e+00,4.860749198818403727e+00,1.633671004561705886e-01,2.777884029751814809e-02,7.472616158189283354e-03,1.315167109942915781e-03,5.765422949634309421e-04,1.683133413279033189e-04,4.355472586105579451e-05,1.053042777048235366e-05,1.982338569209351861e-09};
    vector<float> cluster1_1_5_pcaEigenVecLoad = {3.604818866601125493e-01,3.796274203372737022e-01,3.808491391891327682e-01,-8.810574586658430352e-02,3.002377382631273850e-01,-1.749069166584440171e-01,-2.919838207537598374e-01,-3.358328491467940657e-01,3.741110661594186371e-01,-1.711461820883636853e-01,-2.917253044484189317e-01,-2.159951886035930690e-01,-1.632357818175957931e-01,-1.657655714895489296e-01,4.419435037438207980e-01,-3.062729031736934338e-01,-4.070931825907331825e-01,-3.049688443498851931e-01,-2.363011288706258484e-01,-1.782712473921817253e-01,-4.074266159305974244e-01,-3.126637455262777920e-01,8.596403168135810513e-02,2.568772481623153858e-01,1.120137882326178586e-01,1.602567251918939895e-01,-1.597930659188819547e-01,-1.197387790195750673e-01,4.989013163965959619e-01,5.972480187261327567e-01,1.724455527429257229e-01,-3.213063388432014222e-01,-3.315732307909546872e-01,2.034256640865115401e-02,1.001315434873447097e-01,3.245863028795765159e-01,6.182353268949800085e-02,2.959051655805350345e-01,-6.043329274739219770e-01,1.393487104295164369e-01,8.705904320044595412e-02,-5.607474118797455276e-01,2.727189033111317440e-01,1.085941171457237286e-01,1.694274386801171706e-01,6.904517850679606772e-01,-7.738490801384017084e-03,1.174163479033501906e-01,-5.315710000589517481e-01,1.811340717790370092e-01,-1.310335800665772266e-01,-9.233972475092799836e-02,-2.938036579192342956e-01,1.050342809323063231e-01,2.056640440406642678e-01,3.348690986497743216e-02,7.158311447936810575e-03,5.808485410621861550e-02,2.865086836245577251e-01,6.005983799557665370e-02,-1.969100691953048210e-01,1.292663307582126719e-01,-7.737330074355230902e-02,3.039206201110651873e-01,-3.703820167990571344e-01,7.865993619709218398e-01,-1.858977989472097581e-01,6.291699189608727927e-02,5.379076208750462745e-02,2.934927582232471632e-02,-4.761624628637271817e-02,7.545812983460933876e-02,6.979118766579049948e-01,-6.633751333689681395e-01,-1.346426030193569219e-02,2.523882834771055267e-02,-1.476535072974548835e-01,-6.182818732783224025e-01,-2.275093521254610389e-03,6.668700712726917113e-01,-2.474745006673187975e-01,-2.166754037382572218e-01,1.101315489278860832e-01,-1.464128247550030848e-01,6.959875671644545625e-02,1.829625285510017713e-02,-1.474694769286945817e-01,6.575057678352570767e-02,1.140182460841277085e-01,8.141177760096643054e-03,-2.548919388957935905e-01,-7.796174325830268481e-01,-2.270520471400793716e-01,-3.544638359810055039e-01,7.789472430707763961e-02,-5.908870869919281149e-02,-9.894505506592617128e-02,-3.308486873935071459e-01,9.029415546800852177e-02,-5.941910156237504292e-01,5.177320722385195806e-01,-4.399540638549692684e-01,-4.045696827614195246e-02,3.674813316433197530e-01,-1.220505641069463409e-01,-7.037870662721130988e-02,6.463990327360119581e-02,1.499477325192155319e-01,4.526885825034900057e-02,-9.500156902371438908e-03,5.361560465942668413e-02,6.613202244033038191e-02,-1.839028682233569332e-05,-9.691217793936372012e-05,4.254114566100449801e-01,4.406586919698132210e-01,9.105856667647113656e-04,3.896647426417088316e-05,-5.221171569873622742e-01,-5.873582946426147977e-01,6.832845277776702382e-07};
    cv::PCA pcaANN1_1_5;
    pcaANN1_1_5.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_5_pcaMeanLoad.data());
    pcaANN1_1_5.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_5_pcaEigenValLoad.data());
    pcaANN1_1_5.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_5_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_6_pcaMeanLoad = {1.290732187764181453e-16,-3.386838591860558406e-16,-4.294618006560821572e-16,-3.844141805822959273e-15,-5.652553605754046954e-16,4.756721464196725270e-15,2.201711764913446688e-16,8.515098916386428027e-16,4.104741701253363709e-16,-1.515650271888212569e-15,-3.016179776204890050e-15};
    vector<float> cluster1_1_6_pcaEigenValLoad = {5.673825885225517673e+00,4.532101215448960829e+00,7.416404422910695127e-01,3.828732861075497679e-02,9.986279906294718775e-03,3.378642138964349853e-03,8.145065659822287463e-04,2.560497176784735083e-04,2.425193314810185509e-05,1.568738413107757389e-05,1.433270390916973999e-09};
    vector<float> cluster1_1_6_pcaEigenVecLoad = {-2.704622249144713608e-01,-3.184832850773096635e-01,-3.222826706796586005e-01,-2.219197591910284650e-01,-1.373330562909859665e-01,3.594927935302338340e-01,2.526230547914502522e-01,3.132879228764254287e-01,-3.102216985954561745e-01,3.441621808109817104e-01,3.841299341603782724e-01,3.589126689662089364e-01,3.022656937315041925e-01,2.991356174151325042e-01,-3.856995312403935228e-01,4.356132057088006326e-01,2.243935345145764149e-01,2.917637938634476402e-01,1.884232627766731505e-01,3.077255319229240671e-01,2.464615583434179302e-01,1.593481629012963863e-01,-3.267011049240377274e-02,8.282846146741931759e-02,4.404686012544192092e-02,2.492461333245079291e-01,-1.863213292268499910e-01,-2.064237853779731513e-01,5.806976823860912074e-01,6.150958497267555725e-01,5.408946753852255512e-02,-2.631430635711887733e-01,-2.509168926332064897e-01,-4.391242688893535334e-02,-1.056649757343432888e-01,-3.047935769694893327e-01,-7.574408428604322008e-02,-3.080229052223564801e-01,4.081526653923042147e-01,-9.234681416926354691e-02,1.609559332693280553e-02,7.606767762168109570e-01,-1.771609794785388159e-01,-8.945076665954851403e-02,1.148184111980223576e-01,7.026181760329032189e-01,6.112583539146074219e-02,1.796479821675212377e-02,-6.003609732873571581e-01,2.324418444509530335e-01,-8.381479269629313333e-02,-2.231143430403695338e-02,-2.142014479476168909e-01,7.917821664796891035e-02,1.222646729957137662e-01,-1.302761596913005193e-01,7.555870246175208594e-04,1.033345095233286978e-02,1.169855100395207279e-02,-9.091510283652423641e-02,4.306207110342735733e-02,6.983209220940711504e-01,-6.951731095615123479e-01,3.257386025609144975e-02,-2.495391198105623501e-02,7.905727151159397045e-03,-3.008985712777127730e-02,1.182861149701969379e-02,9.845143349424392842e-02,2.993409225023178633e-01,4.900713602138352318e-03,-2.121796706359654894e-01,-8.263901289627388624e-03,1.989176241641121834e-02,2.209227801363257138e-01,-2.714957746322944065e-01,8.553548839391564851e-01,6.614882413275998685e-01,4.520276221215540485e-02,-6.985676410921068946e-01,1.520592851684430535e-01,9.645107572332474455e-02,-1.262173183007708199e-01,1.004527175580696707e-01,-5.554519465350311186e-02,-9.055011294777612352e-02,1.654255154879011314e-02,4.887355071059239914e-02,-3.125119764094028141e-01,2.806817897321540745e-01,-1.449636764732082916e-01,6.676244009739722429e-01,3.793908314135328030e-01,2.852945225547608987e-01,-1.431903997027917687e-02,1.308389622869556880e-02,9.732963942878707087e-02,3.391923276284837252e-01,-8.115481871706256567e-02,-4.772077273011023912e-01,4.614886895262528821e-01,-4.350465063977735913e-01,-4.185901812855674642e-01,2.315016548232476934e-01,-3.255997683953250066e-01,-1.662470347558242870e-02,1.816004492167578796e-02,4.758906048440809250e-02,-1.785073854883173217e-01,2.176633023738024433e-02,3.190697336332564554e-02,3.959862094017156664e-02,1.331478797858360146e-08,-7.742357918403541535e-05,2.936510147718367492e-01,5.540490454488030680e-01,5.123014435037835570e-04,1.254627595313489674e-05,-3.344030121681307866e-01,-7.017029199293591812e-01,6.486344027979961840e-06};
    cv::PCA pcaANN1_1_6;
    pcaANN1_1_6.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_6_pcaMeanLoad.data());
    pcaANN1_1_6.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_6_pcaEigenValLoad.data());
    pcaANN1_1_6.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_6_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_7_pcaMeanLoad = {1.733709441377071120e-16,-3.856808169052736105e-16,9.345342871166244855e-16,4.264739802317928896e-17,-3.801181128152936981e-16,-3.356164800954543994e-16,2.753538524540054393e-16,1.668811226993972163e-17,5.191857150647913466e-17,5.544161743013307873e-16,-5.099145415814915132e-17};
    vector<float> cluster1_1_7_pcaEigenValLoad = {4.693519332034695957e+00,4.502744264437920307e+00,1.629160433249823736e+00,9.251663428684321622e-02,5.712382002585907753e-02,2.947380839105697217e-02,3.699502006927362242e-03,3.076801827576456250e-03,1.796551498559588054e-04,1.409843854989286224e-09,5.316010993544045247e-11};
    vector<float> cluster1_1_7_pcaEigenVecLoad = {3.179176756595226694e-01,4.059207842211314810e-01,2.047659059363116096e-01,-4.380443958904658430e-01,1.158646966831859693e-01,4.212447206572593750e-01,2.770273873349748395e-01,-1.813047054200903063e-02,4.360533826052782058e-01,-1.842020880017255224e-01,-9.125298797885787738e-02,-2.259734030895453605e-02,-2.109460866566460202e-01,-4.111105740821858201e-01,1.135514681241095447e-01,-4.423924793044792803e-01,6.175519641537260962e-02,3.394925034928555907e-01,2.473358986507699919e-01,9.849020513249998054e-02,-4.218027033294031169e-01,-4.577252570463555270e-01,5.425490606278318140e-01,8.297613587504969190e-02,1.091420619251957380e-01,1.533811007329635434e-01,1.807506561193388261e-01,-2.969090934498541667e-01,2.501413549760511668e-01,6.458457791180147733e-01,-1.952552279154065873e-01,1.568853780337773896e-01,8.174517727034183792e-03,6.502410537509584199e-01,-3.197352869614060000e-04,-1.777835697587141495e-01,1.540595328172574274e-01,-7.224627152836170241e-02,-2.099327408617499280e-01,4.057576047353164683e-02,-6.673312949522562931e-01,-1.047018065855997299e-01,-3.126645751347835456e-02,-1.167747566655506913e-01,-3.071972925421130318e-01,1.439527260069123626e-01,5.838764559357682016e-01,1.623869732438077695e-01,2.185071562675234766e-02,-2.157295409190105595e-01,4.153787245692047159e-01,-2.193948094013287164e-01,-1.737427458119290835e-01,3.683317821177681944e-02,-4.673250589253843401e-01,-9.687688859197230579e-03,6.866366242286964239e-01,-7.237331084280604343e-02,8.664519474486477579e-02,-2.357757720023288261e-01,-1.351870465659453791e-01,-5.564345038268579957e-01,1.312525585205844836e-01,-4.615274768183859344e-02,-4.142451693236541554e-02,-3.333655635278492402e-01,2.624683367085490771e-01,-5.255614796223450069e-01,4.126054989694932784e-01,-1.419238146501078934e-01,-8.941252660173377997e-02,1.790796032488646272e-01,-4.650726132823874703e-01,9.965915701627996170e-02,6.163593299673917475e-02,9.433517316480162507e-02,-4.307239671412814164e-01,1.131652582479290153e-01,2.634301035800868523e-02,4.560689759312449021e-01,1.225917592389090260e-01,-6.629673762409992177e-01,-2.927652658961310550e-02,3.849709941581372103e-03,2.359626235506368311e-02,-3.097957912058146596e-03,-2.672481832183367656e-01,5.010851926381139076e-01,5.765656062541226617e-03,7.520825132077788022e-02,-1.407264997850564969e-01,-2.281292502229727015e-01,-4.870451527479791043e-01,1.957228563702020085e-01,2.128719634994071797e-01,-1.408405288106264266e-02,-1.198474986009843007e-01,7.646858203687427746e-01,-4.819228247134117737e-02,4.263402549079732540e-02,5.737348969961628131e-02,3.666414301127828013e-02,7.917507112770326705e-01,7.402746384453477713e-02,4.734079656200073649e-01,1.296215469873548357e-03,1.715435757000487093e-05,3.046820091552351895e-01,2.103549311551698997e-01,-5.301874899154291319e-05,-5.686709341980399068e-02,-7.613055631312759530e-02,-6.823969535314776435e-05,-1.702509065009620353e-03,-8.181006265488535711e-02,-5.712691882673940347e-01,-1.107315171517346758e-03,-5.589930930498098204e-05,7.795834154448308961e-01,2.239965762003077732e-01,3.830228202506231573e-06};
    cv::PCA pcaANN1_1_7;
    pcaANN1_1_7.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_7_pcaMeanLoad.data());
    pcaANN1_1_7.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_7_pcaEigenValLoad.data());
    pcaANN1_1_7.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_7_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_8_pcaMeanLoad = {1.777523332459375567e-15,4.381772109367700196e-16,7.674463880806884367e-16,3.195130533766912405e-15,2.784949156249142091e-15,-3.950540834373901949e-15,3.665015146947170448e-15,-9.998966413172325939e-16,6.963963562976207729e-16,-5.464993470794702271e-15,9.816145137360371281e-15};
    vector<float> cluster1_1_8_pcaEigenValLoad = {6.936713944536848864e+00,4.027646078528110074e+00,2.565083031135659969e-02,5.434146276256235711e-03,3.458283527973479102e-03,8.507066224984796395e-04,2.837015025883799033e-04,1.234598196134900584e-04,2.724514751658041009e-06,2.916324703306439545e-07,4.481040341424201044e-09};
    vector<float> cluster1_1_8_pcaEigenVecLoad = {-3.376503603283835808e-01,-2.973393244017975556e-01,-2.834171001910115173e-01,3.770592114107993442e-01,-3.692853929672611502e-01,-3.600487575768591131e-01,-1.549300819342218638e-01,-1.371446295668042603e-01,-3.164540810853091468e-01,-3.151045546516161866e-01,-2.585146107040260377e-01,2.277342694199433470e-01,3.093200359308452829e-01,3.294507883384012459e-01,5.320348266958872113e-02,1.116209344752185639e-01,-1.513744797939946263e-01,-4.545176359914859243e-01,-4.640797809503348081e-01,2.733818550553179794e-01,-2.772836186506850709e-01,-3.635053657001632854e-01,-3.529410893986282410e-02,7.877218638541096107e-02,4.595212487613453689e-01,2.462249815348419857e-01,3.628163513901130899e-01,-5.702304766680320602e-01,1.657702801315216745e-01,-2.184856199360915574e-02,-3.703821110857047350e-01,1.403893999861995090e-01,2.812739061790804906e-01,1.507907967838729713e-01,4.072413545385574762e-01,1.301853910988992058e-01,1.030862206232359690e-01,-2.116748854191097262e-01,-1.511084146373989912e-01,3.304131212108934457e-01,6.123524094592835976e-01,3.192904292932650934e-02,-2.366987656056453726e-01,-4.183390087823223857e-01,1.056985423245719730e-01,5.497518094660641674e-02,-1.403865845845028992e-01,4.564020233507263269e-01,-9.638712000502458119e-03,-4.190467583368787975e-03,1.430105681226210290e-01,-4.773244318056366238e-03,4.486677590458914566e-01,-4.616090363920243300e-01,5.681755150045669778e-01,1.712650421924931665e-01,5.827877861891204159e-01,-1.448050316788959402e-01,-9.427438704203559838e-02,-5.102255870388625603e-01,-1.702529069718319160e-02,-1.964787111704789646e-01,-1.397302750242189751e-01,-3.614507235944773300e-01,1.169298700466787078e-01,3.716219320085601963e-01,-3.218142876759846893e-01,-1.725702459906064690e-01,4.506127757530974387e-01,-4.239870658989651209e-01,-2.232853074416540073e-01,-6.515846098932674690e-02,-3.490043535935775099e-01,3.254131129299254188e-01,6.595743492683409093e-02,-3.400838497844305142e-01,2.864106739747346309e-01,-5.809310868294750296e-01,2.274340047725660618e-01,3.762586471151851408e-01,1.705198031426795324e-01,-2.207799446209463001e-01,3.631526699428271332e-01,3.731114659415795121e-01,-3.287684148811446105e-01,6.946312631681746119e-02,5.872520645265870420e-02,-6.282527334512323647e-02,1.033102303062684996e-01,-5.700195873133945962e-02,-1.134217660743923745e-01,-5.719310813827500617e-01,-6.712269529696583692e-02,-3.086608555091742145e-01,5.433655551713363341e-01,-3.832175822248340413e-01,1.208320382098652078e-02,-3.226085494066779358e-01,2.648085805689447125e-03,-5.602811624391146328e-01,4.592621951413402570e-01,-4.299574323377762797e-01,-1.749386238859518550e-01,4.169782245998477355e-01,-1.972575575333014308e-01,-1.320537318136047744e-01,9.991517109880371228e-02,1.355842943343190388e-01,-3.332408132758572089e-02,-3.616873193882517621e-04,-6.331313913581836095e-02,-7.428516390882333731e-02,1.298880343903150185e-03,1.021687283604160628e-03,-3.705774421844573174e-01,-4.783713354126968853e-01,-1.160097621829720219e-03,-1.393214842488676249e-04,5.720688826334621169e-01,5.450132869081683040e-01,-8.907340892069451552e-06};
    cv::PCA pcaANN1_1_8;
    pcaANN1_1_8.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_8_pcaMeanLoad.data());
    pcaANN1_1_8.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_8_pcaEigenValLoad.data());
    pcaANN1_1_8.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_8_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_9_pcaMeanLoad = {2.572365800452249416e-16,7.541137525755779833e-17,3.837601096440163874e-16,3.251068177770269490e-16,1.675808339056840074e-18,-7.021636940648160269e-16,-7.541137525755779833e-17,5.530167518887571959e-16,-1.357404754636040395e-16,5.195005851076204022e-16,1.586990497086827481e-15};
    vector<float> cluster1_1_9_pcaEigenValLoad = {6.389768672807737637e+00,4.120286464211999622e+00,3.639228376242439889e-01,1.171413275538805560e-01,1.411575490368624508e-02,2.441272114164730160e-03,1.600715885478296322e-03,9.472675588808416799e-04,1.628434005527930003e-04,1.541223532165655817e-09,9.408403359488363122e-11};
    vector<float> cluster1_1_9_pcaEigenVecLoad = {-1.096329320609989305e-01,-1.311103840697931400e-01,-3.558139068941107430e-01,1.650010634408670962e-01,-3.865480468713812234e-01,1.974858666468390089e-01,3.792651177539830831e-01,3.576362848388100479e-01,2.268836197540045063e-01,-3.931933005555202087e-01,-3.882252564722007970e-01,4.523895326647961457e-01,4.575531403984691159e-01,1.876358660280909030e-01,-4.422217842593166859e-01,9.217763089866255755e-02,4.011822946326513151e-01,1.153826297128537348e-01,1.075566547442493304e-01,3.965006887638854449e-01,-4.324414016273522149e-02,-4.258078816243731496e-02,4.493977694017989855e-01,1.197136831680592484e-01,1.815258086332628695e-01,2.150174542510081277e-01,8.390415005367786450e-02,-4.779282043691263637e-01,2.548818292349290804e-01,5.752676063131293427e-01,-2.566739937065213861e-01,8.216326061928315438e-02,-2.325882564802114749e-02,1.814275368937440236e-01,-4.255223654749765161e-01,-5.086200887529058745e-01,-1.792450231848735920e-01,2.511613727579564692e-01,2.038765417907398569e-01,-3.238114756908158642e-02,3.416243128789300809e-01,4.634584853765576218e-02,1.446805178224599975e-01,4.997077276544117930e-01,4.708444924222899841e-01,3.248229251979968257e-01,-5.577698238528703278e-01,2.018176531177321986e-01,-2.365857403461920361e-01,-1.956442618575528758e-01,-3.518813001923653538e-01,-2.870386323811233709e-01,-2.653322624527179163e-03,-1.411815695981674113e-01,2.361352066532844060e-02,-1.228257171745594650e-01,2.341648277442708731e-02,7.474620356718637837e-02,-7.565551369470668863e-02,-1.236819997066194721e-01,1.176373135440865469e-01,-7.644286005392261218e-01,5.082961408466990516e-01,-3.254656501604048097e-02,1.077226369788026605e-01,-2.975558564565598529e-01,3.993934479995362441e-01,-5.002147177511869769e-01,-2.027451092730033974e-02,-7.832066538922868859e-02,3.259815131515050313e-01,-8.093466191237350872e-06,-3.187928394133200671e-02,-2.498159210633963678e-01,-1.427927058016403503e-02,8.396175958581943155e-02,-6.377955962809137569e-01,-3.614267536202753761e-01,4.419856354161145195e-01,-4.720786019209475270e-01,-1.593102134112729384e-01,4.325271965840245536e-01,-1.181124742007055306e-01,1.635944817666603879e-01,6.597472281442534614e-02,-9.954400607204400009e-02,2.958295633409023240e-01,-3.101792365900875037e-01,1.194057921798403199e-01,-1.897081545583670717e-02,-5.988907133089104579e-02,-1.835468915310024540e-01,-5.746721935155125749e-01,2.272387743823801043e-01,2.021717695624374034e-01,-7.328751051375446968e-02,-3.663958779341572880e-01,6.169298309471238362e-01,-7.160846899381448361e-02,5.958635868695170978e-02,1.129323901850323442e-01,5.470796083081680417e-02,7.662690103372468142e-01,2.085861962103766620e-01,4.668412485008782142e-01,2.220166684183074758e-03,-3.459113059304346741e-05,1.452843163695706763e-01,3.331263548048884471e-01,1.369106597398953968e-05,-6.096416920969920106e-02,-1.153975505924189904e-01,3.690270638950522426e-04,5.254373447479614677e-03,-1.832807865613028386e-01,-4.409388879157074559e-01,-1.483953810839851086e-03,-4.029596625852765101e-05,7.461560510352863718e-01,4.451617962019540631e-01,-1.151827407961865423e-05};
    cv::PCA pcaANN1_1_9;
    pcaANN1_1_9.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_9_pcaMeanLoad.data());
    pcaANN1_1_9.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_9_pcaEigenValLoad.data());
    pcaANN1_1_9.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_9_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_10_pcaMeanLoad = {-4.512506412102104170e-16,-3.057689794220398478e-16,9.913352174946134362e-17,-2.879700061988411301e-15,6.285966492749935494e-16,1.514361103348102602e-15,-4.731372628951564340e-16,4.892303670752637393e-17,2.928944960779539642e-16,4.378611785323610507e-15,3.146523729294591327e-15};
    vector<float> cluster1_1_10_pcaEigenValLoad = {6.195904165705588440e+00,4.308118047778482840e+00,3.035198083839200089e-01,1.835501747181848831e-01,4.735007451945693821e-03,2.764950200145953590e-03,1.227921388265535915e-03,1.090524879208889337e-03,7.802315566466322893e-05,8.023479406393205790e-06,4.989447777152656569e-10};
    vector<float> cluster1_1_10_pcaEigenVecLoad = {-2.509908853043963384e-01,-1.002491814584642454e-01,-1.865332815729411550e-02,3.938268861773686069e-01,-3.757594875888745634e-01,-3.945489100634096413e-01,-3.049626436715123790e-01,-3.145585274577050727e-01,-2.222812215164082505e-01,-3.556952859248150300e-01,-3.267487109979154702e-01,3.753708998109355210e-01,4.635554655737990637e-01,4.671543798400663583e-01,-8.665201434551886295e-02,1.437139646551506833e-01,-4.112270891579619496e-04,-2.661902254064485440e-01,-2.704612284146752921e-01,3.812300476948286554e-01,-1.929944146565720497e-01,-2.668850940793205950e-01,2.216756541566533567e-02,1.091312446800981051e-01,1.637383696763835064e-02,1.416872672308321091e-01,-2.948608337450059347e-01,1.715869127824921556e-02,5.764042947128721339e-01,4.650379660018107431e-01,2.825797734073537959e-01,-3.892561193235839490e-01,-3.164559664885387980e-01,-8.260803051746930248e-02,1.890860335447851204e-01,5.571508210046249854e-01,5.496607849711002830e-02,2.165508952795725528e-01,-4.379893954658176658e-01,3.025038592441854912e-01,1.619135355870662818e-01,-4.848101105097770147e-01,2.263971220838946752e-01,-3.512832602967289053e-02,3.876568351678367774e-01,5.931759769905883273e-01,-3.139242038135719448e-01,4.315858147150006957e-02,-4.681035379488887593e-01,-7.092017477558892891e-02,-8.999944648505224520e-02,1.123620501482296002e-01,-2.886390470707692057e-01,1.714292321862827262e-01,1.996926746798790564e-01,-2.637346275939189133e-01,2.362886845131493274e-01,4.273083605605488416e-02,1.806650040790981279e-02,-1.546616619382337743e-01,1.239402315151638956e-01,5.298288086904751060e-01,-6.710645862175140808e-01,7.750116655255305520e-02,-2.957343659262772970e-02,3.086271309652139361e-01,-5.115340805052304152e-01,1.679531311898587731e-01,4.180660387186823646e-01,-6.124778323446740391e-02,-3.241170524151655297e-01,2.294348837889207682e-01,-3.412383977159821336e-01,3.192329296708817932e-01,1.020108012093190325e-01,-8.322704302223828121e-02,3.717736478597910010e-01,-3.026536555546713858e-01,1.534004339260341410e-01,-3.786528069949282593e-02,-2.885163501486545101e-01,-1.696812323963737268e-01,3.649750594394481906e-01,5.704240808781825138e-05,-7.345595663753075322e-02,-1.580131372118653010e-01,4.036572051698620323e-01,-6.670022650548609322e-01,4.505207262746884767e-01,-5.073695840579041105e-01,4.212479924181402602e-01,-1.562587129554817433e-01,-5.019402331812389262e-01,1.819318855103529697e-01,8.251731032146622513e-02,-1.223001229099758835e-01,-1.604596665715671278e-01,6.101495998802455856e-02,3.821987339784813087e-02,8.669428941682781609e-02,-9.440956475639711342e-04,1.292149581187793661e-01,8.370760975275697291e-01,7.899581271402689175e-02,3.890977139049233702e-01,-1.784472105698737751e-02,1.454933062194731230e-02,6.415641164465132884e-02,3.344754493428269693e-01,-3.054427213989478057e-02,-7.210980795194385506e-02,-1.027056943401374323e-01,-6.431192062197254221e-06,2.130273742122826806e-04,-2.631441240211601640e-01,-5.113390296187797501e-01,-6.318654878111364375e-04,-2.593708068155896375e-05,5.794876207022114922e-01,5.636780418221314370e-01,7.830794910513714909e-07};
    cv::PCA pcaANN1_1_10;
    pcaANN1_1_10.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_10_pcaMeanLoad.data());
    pcaANN1_1_10.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_10_pcaEigenValLoad.data());
    pcaANN1_1_10.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_10_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_11_pcaMeanLoad = {1.359864480943843975e-16,-6.761397897282539017e-16,-2.382471735040061435e-16,-1.380384348360476819e-15,-9.626052655446115644e-16,1.025160386114722510e-14,-2.708893388334350696e-18,1.239928226175340763e-15,-1.073669894466319988e-15,-3.594142817058339211e-15,1.599262934137892316e-15};
    vector<float> cluster1_1_11_pcaEigenValLoad = {5.725428705396709894e+00,5.186152556448175410e+00,6.004643980363514461e-02,2.368683538029330710e-02,2.735532454229598967e-03,1.662267140849612397e-03,2.481056524192957633e-04,1.919657945004034783e-04,5.571881387136158489e-05,1.558138634172410297e-06,2.542208551557454127e-09};
    vector<float> cluster1_1_11_pcaEigenVecLoad = {4.119674058317018273e-01,3.924058034818136420e-01,3.925657356829088673e-01,-3.385742475027234688e-01,4.142177469130918221e-01,1.879348092829638273e-01,-5.431418309875709477e-02,-1.049195430029096487e-01,4.004328245517948526e-01,1.585036286453108123e-01,3.516164617768553768e-02,7.298857404322710296e-02,1.471760238995042658e-01,1.475152976189197940e-01,2.568507637269525357e-01,-5.086557842767510523e-02,-3.899869142893597207e-01,-4.325166039464254375e-01,-4.197207951805529413e-01,1.186608009118471224e-01,-4.046833547504601891e-01,-4.353349812757527637e-01,8.939356886482427433e-02,2.738308410025688255e-01,1.528673263814467609e-01,1.183147528954565930e-01,-1.381846940979354066e-01,-1.308256192854639899e-01,4.536370239407333527e-01,6.220585339147909343e-01,1.671481915541086494e-01,-2.928573099269319857e-01,-3.701364839702687703e-01,1.057664519075501158e-02,1.218926387360866198e-01,3.742739544449791844e-01,1.144644009680147040e-01,3.156438416680813486e-01,-5.776706021677007197e-01,1.337966300994315183e-01,4.281148897596250003e-02,-5.385272953146625907e-01,2.456179130967487412e-01,1.686377742221563392e-01,2.151747475486572581e-01,6.439230341542999669e-01,-1.032235223148143810e-01,2.330365724375212388e-01,-4.814095241403520964e-01,1.019739778034080696e-01,-8.711576748647736901e-02,-5.955352819857771124e-02,-1.617942579354857691e-01,-2.110291932075150298e-02,4.406693744723896855e-01,-9.173731617228246885e-03,-2.134282716489136478e-01,2.917944889803237088e-02,3.354495222335494020e-01,2.312157778560372245e-01,-1.938563931940034124e-01,1.592908576054981040e-01,-1.502681970805702823e-02,4.418292188583138325e-01,-3.862005274596140847e-01,6.164268549620763871e-01,2.354782632546307264e-01,6.520428969504911410e-02,-3.358616002769991837e-01,4.246033498314907284e-01,2.043856420371527594e-01,1.022821349871730762e-01,5.412440872811939974e-01,-4.319337091834447584e-01,1.354497686393744786e-02,2.305764359427421584e-01,-2.492215735978743352e-01,-5.524973706730349488e-01,1.056763241213120597e-01,4.940132211797718109e-01,-1.122654149712147692e-01,-2.399567557812336549e-01,1.752689496503019029e-01,3.958437340742227972e-01,-4.145897172936094388e-01,3.209534264465650766e-02,-9.339338825738918715e-02,1.728591862906483576e-02,3.045285236630534409e-01,-5.994060433872201721e-02,-2.634241265279914646e-01,-6.361429302275349862e-01,-1.793967388771305904e-01,-3.644980497636060579e-01,3.185551581875418758e-01,-2.454674108344435390e-01,-8.888011014660260334e-02,-2.961599437790335965e-01,8.494328132260338393e-02,-5.604749348360964500e-01,5.011367651472810048e-01,-4.721556586775186304e-01,-1.670115240710348670e-01,3.568497932999206146e-01,-1.864778222034776112e-01,-4.703534058759920033e-02,3.947977631920746716e-02,1.338182321343242276e-01,-1.008222722953096978e-02,-3.205484775149357660e-03,5.380509556892514728e-02,6.463156474960006503e-02,-3.437861196290166042e-04,-2.307839579534219122e-04,4.037533164334168312e-01,4.527465154334193165e-01,1.182773429169592253e-03,8.377664204669606077e-05,-5.091286580255549588e-01,-6.047462747973219033e-01,-5.913458728865881553e-06};
    cv::PCA pcaANN1_1_11;
    pcaANN1_1_11.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_11_pcaMeanLoad.data());
    pcaANN1_1_11.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_11_pcaEigenValLoad.data());
    pcaANN1_1_11.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_11_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_12_pcaMeanLoad = {3.490347097296354903e-16,-3.588201471274127844e-15,2.615033489302503759e-15,-3.306987010388163611e-15,-2.213409844513157487e-15,-2.043902072647360916e-14,2.251429696822992509e-15,-3.277537206754725746e-15,-1.312230271423270316e-15,1.291514126486415345e-14,-6.980733149359420846e-15};
    vector<float> cluster1_1_12_pcaEigenValLoad = {6.654006512207996771e+00,4.284448576295234012e+00,4.808386928758921069e-02,9.765799031857770249e-03,2.424074534654846024e-03,1.001773892829778499e-03,3.057110990134902923e-04,8.237860313764412028e-05,1.324630670224837979e-06,5.881561161045901326e-07,6.295984755930014665e-09};
    vector<float> cluster1_1_12_pcaEigenVecLoad = {3.673774697911709186e-01,3.367129274312628540e-01,3.107949716105429805e-01,-3.753479234024502675e-01,3.837850925599146090e-01,3.621170087703091678e-01,3.548185710335641230e-02,4.215074765026256137e-02,3.549891615447940407e-01,2.561768134986736056e-01,2.026804963434045981e-01,1.539202102114528847e-01,2.388994758541494734e-01,2.839673531407969076e-01,1.128954212750344493e-01,5.453315768242233269e-02,-1.629192222212116903e-01,-4.799286715118755708e-01,-4.799792536627248696e-01,1.920022189176414373e-01,-3.614769037431683207e-01,-4.099929506462407502e-01,-3.057710462732105700e-02,9.921939359302862915e-02,4.797679980187032900e-01,3.703679046473765668e-01,3.783575202300398233e-01,-5.262510023470571285e-01,2.930521739215103949e-01,4.864289792591813127e-02,-1.459060572462511085e-01,-3.408781573753338207e-02,3.017946991322348338e-01,-1.376265023541500820e-01,-1.463615455288710086e-02,2.481862475586755212e-01,-3.665482998961286376e-01,4.031611193863455372e-02,-1.965935177584225146e-01,-1.898316190429637229e-01,-9.604233668051510853e-02,-5.004185571229096130e-01,5.870278096423684477e-01,-3.230103767051031860e-01,1.673638906383347891e-01,2.973945045296736978e-01,9.757585241432861767e-02,2.084268282975498734e-03,-1.289921587889994448e-01,-8.044597009432792600e-02,3.107055726652243610e-01,5.970801798063352095e-01,2.677709830883021752e-02,-1.297308553235908268e-01,-6.167009913111907160e-01,3.157447113153630247e-01,6.159362041013759503e-01,-1.828346381425011158e-01,-9.061687629626401924e-03,-4.757403433761922540e-01,-1.998772591518523656e-01,-1.051142703849005239e-01,-4.221660476803064388e-02,-2.721715614295307506e-01,5.329517304552378737e-02,3.624754774419715608e-01,-2.419527542299148293e-01,-1.315700456079477165e-01,4.230318520666275783e-01,-3.559096433360884881e-01,-2.442898582812622066e-01,-5.225658528911382439e-02,-4.024317057885361537e-01,4.371724309765256389e-01,1.885993135754537170e-02,-3.455713382927652622e-01,2.885585228017356618e-01,-5.443764475776426970e-01,3.017455007233326714e-01,3.359737560260992462e-01,-1.009825724392585458e-02,-3.419133470142614595e-01,3.178650111546779677e-01,4.126381581464460546e-01,-3.283241699799147595e-01,4.833384370148970793e-02,-2.905207344020861726e-02,-2.082068264578439479e-02,2.033678806247310733e-01,-1.878270168934617346e-01,-8.342732807170694098e-02,-6.307964352604148450e-01,-2.081349702934623749e-02,-3.367410157567596318e-01,4.395459268828870170e-01,-2.996154475434474884e-01,-1.800041891576248040e-02,-3.483883216983019726e-01,1.437245384018975228e-03,5.391841028049348949e-01,-4.465076912092962313e-01,4.350302192197184614e-01,2.237710651394901329e-01,-4.233758886429052626e-01,2.150503847410674962e-01,1.161143522859643257e-01,-9.633280800560101165e-02,-1.121911847369132381e-01,9.870611490737378479e-02,6.934883555305012236e-04,8.243853433557055133e-02,9.307368217036633695e-02,-8.595261745705811860e-05,-8.829473958482723754e-04,3.251536062116035519e-01,4.657326505314764442e-01,1.494354872407125745e-03,-2.538359266192918742e-04,-6.892121784660290018e-01,-4.323111112164568226e-01,-3.896362194521585580e-07};
    cv::PCA pcaANN1_1_12;
    pcaANN1_1_12.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_12_pcaMeanLoad.data());
    pcaANN1_1_12.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_12_pcaEigenValLoad.data());
    pcaANN1_1_12.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_12_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_13_pcaMeanLoad = {3.249478896942924080e-16,5.158734930861000866e-16,6.042233801458386558e-16,2.890089525852462104e-16,1.076670657558507920e-15,-4.439956188680077899e-16,-2.777780347386693229e-16,4.088054096154001040e-16,2.695420283178462359e-17,9.538792891026002755e-16,1.883799286799169752e-15};
    vector<float> cluster1_1_13_pcaEigenValLoad = {6.303708286656768855e+00,3.868715765737717582e+00,7.188808921742889657e-01,8.475960515881164614e-02,1.867316281212805587e-02,4.141203671961261358e-03,2.121942593188447072e-03,1.215718253970785121e-03,1.011463380300385952e-04,9.947185672877268145e-07,2.656739583284659724e-10};
    vector<float> cluster1_1_13_pcaEigenVecLoad = {-3.253738252055157210e-01,-2.391026279458106363e-01,-2.644038622749358969e-01,3.953371206406430249e-01,-3.952551982826327248e-01,-3.418332168866541343e-01,2.103788058262861249e-01,2.152954445128545946e-01,-1.129191097896988794e-01,-3.556657304901146288e-01,-3.283658604849646334e-01,2.902035532605140578e-01,3.752018561290370591e-01,2.824441234793503286e-01,-3.216171235138159251e-02,-4.550101565004579379e-02,1.207490972266907631e-01,4.266100914208484363e-01,4.030375315644711964e-01,4.556481115991308228e-01,-2.235975440294395433e-01,-2.747712394795367996e-01,-2.015383267780728252e-02,-3.570096318986547002e-01,-5.883775972367051299e-01,-1.183030643238796031e-01,-3.352639991103260886e-02,5.309744292243618879e-01,2.341343964766972457e-02,2.388958545805019984e-01,3.756374972765261777e-01,-2.781899624538562710e-02,1.714626064663549443e-01,6.264886624808994886e-02,-1.454070095972813947e-01,4.573133637241029643e-04,-8.302237997034432604e-02,2.534563073912692310e-01,-1.781803491856054911e-01,3.179741615494079410e-01,6.548468203338547733e-01,-4.189840624319390305e-01,3.121216757439592149e-01,2.629660610391272302e-01,-5.582017513427049993e-01,-3.609435907685754064e-02,2.280795962203283622e-01,-1.194722825152148143e-01,-6.791692342132166216e-02,2.951633745613486126e-01,6.354928037085666448e-01,-3.069081506697394768e-01,-4.614466043732971118e-02,1.398088402529756857e-01,9.674910520119184287e-02,1.619409812370473378e-01,6.200556860521591052e-01,-4.225647098625299747e-01,7.701443281903605498e-02,-4.295734954141290918e-01,7.878114542035857468e-03,1.632997649573381393e-01,-9.176108773334801239e-02,-2.056527546523801153e-01,6.760417012641069257e-02,3.718442758520766334e-01,-4.631627651532370105e-01,2.213739806564555823e-01,3.027576442150807234e-01,-4.355497070198437182e-02,-3.440051184779344129e-01,2.784420118371513375e-01,-4.882386430995891424e-01,4.452105006228187500e-01,-5.673201178440989007e-02,5.449218132026121403e-02,6.532863153912008003e-02,-3.112246675465058995e-02,1.993477064614118111e-01,-3.073051484081424922e-01,-2.071466244630825460e-01,7.649827894761077052e-02,1.986049277246051681e-01,-1.680781663019799768e-02,2.994345480426884726e-03,-2.635861521760177739e-01,3.832230955000952011e-01,-7.483453296308303360e-01,4.982348268289268911e-01,-4.085610653306060436e-01,2.896885733466789681e-01,5.850194692903088606e-03,-5.647316520920890870e-01,2.833596465961075173e-01,5.389548487057143483e-02,-6.690889978423827933e-02,-2.732953748359502333e-01,1.159040417193329398e-01,-7.852424961748541432e-02,3.688315530387898528e-02,6.155104874325273423e-02,5.939829564723995980e-02,8.699080527347461400e-01,2.310569850746755360e-01,3.141706917321484549e-01,-2.294599367805760706e-03,1.471291415543105139e-03,2.738055081873961780e-02,2.858187665925661647e-01,-6.548116928148934104e-03,5.178776645635612547e-02,9.069699612958483093e-02,2.246874929011141913e-06,3.249611147694949953e-05,3.011512786976099920e-01,4.144084452803732943e-01,1.204489944140623965e-03,2.402815174354372627e-05,-5.200233424331940357e-01,-6.754553285252604677e-01,3.827295594649044586e-06};
    cv::PCA pcaANN1_1_13;
    pcaANN1_1_13.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_13_pcaMeanLoad.data());
    pcaANN1_1_13.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_13_pcaEigenValLoad.data());
    pcaANN1_1_13.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_13_pcaEigenVecLoad.data());
    
    vector<float> cluster1_1_14_pcaMeanLoad = {-2.412034897088686815e-16,2.265480878025070082e-16,-4.207321630617987719e-16,1.518055380800626473e-15,-1.343411841416483755e-16,-1.155334183618176034e-15,2.195257077223754009e-16,9.260382079582261106e-16,-4.534014964780632334e-17,-6.466696091182074202e-16,6.582718022940770474e-16};
    vector<float> cluster1_1_14_pcaEigenValLoad = {5.798590229173711919e+00,4.794603232136784854e+00,3.111838824066562315e-01,7.025549613284605421e-02,1.945770857837207657e-02,5.320026974533403029e-03,9.087045059934869976e-04,5.057884986104379480e-04,1.177277065077671453e-04,2.626758657523847787e-06,4.191147668919737078e-10};
    vector<float> cluster1_1_14_pcaEigenVecLoad = {3.544224633507881417e-01,2.670735764558530012e-01,2.889838894877438946e-01,-4.061152688078660811e-01,4.106575826447927402e-01,3.880479778832837678e-01,-5.144194550497212942e-02,-6.738221500320232260e-02,1.838407920774414728e-01,3.324979523880389753e-01,2.895777566322123020e-01,2.325613292447474001e-01,3.375705838600529529e-01,3.013500849092548006e-01,8.963186350393510804e-02,-5.151446441575200513e-02,-9.630040333938930108e-02,4.460793799993240660e-01,4.378560026367110392e-01,3.898885023968212127e-01,-2.711568432504469772e-01,-3.239510865031358100e-01,-1.129209138874900514e-01,-3.394112059151562222e-01,-5.007838975624429034e-01,-1.229533514151348594e-01,-1.314709904559462628e-01,5.068215224392914608e-01,1.938801228421236644e-01,3.267076111019580620e-01,4.097590724328102896e-01,-3.804338205875174538e-03,1.405341569492379594e-01,-1.031264886742748743e-01,-1.177394562959794277e-01,6.964967665124638385e-02,-7.061217260949742558e-02,1.413104100037161637e-01,-1.174930310271119632e-01,4.584466863834557593e-01,5.028580310663659514e-01,-5.677189511019271606e-01,3.005738744455609401e-01,2.370715545311787575e-01,6.137413764131539606e-01,-2.443167125774003134e-01,-2.535702853506765497e-01,7.657921586081344045e-02,2.234482294642889666e-01,-2.654723723900277443e-01,-4.459192868067670124e-01,4.118596543095324192e-01,-2.747705035685928110e-02,-5.380491679027435414e-02,-3.068495730352102657e-02,2.045686652632203728e-01,6.270171547244144383e-01,-3.039670877007910055e-01,4.363180570741635039e-02,-5.541972995623906106e-01,1.472937687040212773e-01,-1.353007198989576998e-01,1.294710828933971769e-01,-2.485466868841367527e-01,7.986168991450030841e-02,1.965933154255481430e-01,-2.894155542251154456e-01,-1.430193990409688587e-01,5.683464647818339266e-01,-2.329111662540837759e-03,-2.893831673581418462e-01,1.724631438611420320e-01,-5.051181684665545513e-01,4.241698146827707627e-01,4.191372482744436939e-02,-5.429915085084933285e-02,1.396612051488467232e-01,6.701532750474918643e-02,-2.648422132650500929e-02,6.499630265975525623e-02,2.294902940756064769e-01,-1.369319836659708793e-02,-2.856331773174973221e-01,1.425281158107840063e-01,-1.055571612072451343e-01,2.259219202658235004e-01,-3.154219617843405654e-01,8.210694828628286590e-01,5.368843063312062069e-01,-4.552880147598892258e-01,2.879255315888206712e-01,1.349972562728509948e-02,-4.763093246316705831e-01,1.993017011231454361e-01,2.408096723814711904e-01,-2.582320034998199509e-01,-1.659350973445505584e-01,2.861418779040161842e-02,-4.203184363349280611e-02,2.628696705621256374e-02,3.636946883515649459e-02,5.660064670962301758e-02,8.638930767814401168e-01,2.098149020267356946e-01,3.444223898018901608e-01,-2.023813624029932937e-03,6.671005772067823770e-04,1.541740443899727343e-02,2.921471200582353434e-01,-1.516980911969450022e-02,3.462288338601577503e-02,5.521063221715163255e-02,-8.369165666791636172e-06,-3.010497842716134830e-04,2.820755418272409831e-01,4.556572152242742146e-01,1.315102949487727008e-03,2.679471694059458019e-05,-4.253024134102119658e-01,-7.264151493331996168e-01,-2.254510050536795277e-06};
    cv::PCA pcaANN1_1_14;
    pcaANN1_1_14.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_1_14_pcaMeanLoad.data());
    pcaANN1_1_14.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_1_14_pcaEigenValLoad.data());
    pcaANN1_1_14.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_1_14_pcaEigenVecLoad.data());
    
    
    
    // GrandChild of parentCluster1 - childCluster2
    vector<float> cluster1_2_0_pcaMeanLoad = {1.468895791607136347e-16,1.984636904034295566e-16,-1.969378291240592762e-16,2.233860912998110253e-16,-4.394480484586446552e-16,-6.846336112363925680e-15,-3.698687741193592273e-16,1.033516706560145724e-16,-1.188137316203002138e-15,2.001523102192660249e-15,-5.718928075079861492e-15};
    vector<float> cluster1_2_0_pcaEigenValLoad = {7.912448899476291153e+00,2.992207711711449392e+00,5.000016024150560900e-02,4.085012411535939025e-02,2.151520195144552942e-03,1.628895871513041417e-03,7.048139025961283610e-04,2.213228177192357819e-04,6.032129502634025228e-05,4.119973592216195110e-05,2.858621340857207653e-10};
    vector<float> cluster1_2_0_pcaEigenVecLoad = {3.465569675996804655e-01,-2.666969870937059214e-02,-3.077348318533177918e-01,-3.347761353586898858e-01,-3.452224292904527148e-01,8.721113493374518799e-02,-3.510743707151862125e-01,-3.488216077142675120e-01,3.437441997367459146e-01,-3.315877299357357644e-01,-2.694191433764910881e-01,1.173602946887290777e-01,5.708468167219820089e-01,2.847272026627006292e-01,1.807805168659281092e-01,1.338280188162262185e-01,-5.596497850792531148e-01,7.398628426806876102e-02,-6.734728254489588672e-02,1.465702921975049755e-01,-2.066860118486406050e-01,-3.758721757728952229e-01,3.660146396726448037e-01,-5.992717939445002528e-01,9.778779893492398068e-02,4.642794787971447068e-01,-1.978783957601940868e-01,-1.227343706667607809e-01,3.549518512774116896e-01,1.224533992446904113e-01,1.001223584079322659e-01,-2.038071564131666846e-01,-1.871406739683709186e-01,1.886043158458413083e-01,1.623763940694044061e-01,-4.173409372713295928e-01,-3.261252983080445422e-01,-1.076051336134721675e-01,-1.831395583058411103e-01,2.242837846106472688e-01,7.474370649689324742e-01,5.862009892666396327e-02,2.818440192213600686e-03,-1.595696070277496459e-03,3.171742650377288864e-01,-2.770911004676014366e-01,-7.883384605146177837e-02,-2.510259084242381644e-01,5.241278290319953959e-01,-4.667117232141130834e-01,-2.384859074183987362e-02,-2.139734690846087084e-01,1.235550669684987030e-01,2.843989433430105934e-02,4.454596827871873943e-01,2.608997983722136649e-01,2.544273093254090790e-01,4.254558121549782967e-01,1.274859352568468752e-02,-4.714550578702246253e-01,5.280355898176888885e-02,1.389503562847512266e-02,5.218273706302437726e-02,1.586597090857739256e-01,-8.591036034901766705e-02,6.522999110439088311e-01,-1.970693293830387272e-01,2.204968404517516356e-01,-5.465818791659627918e-01,4.970059482527015016e-01,1.420980725850298498e-01,1.069063228118831560e-01,1.072901620929364724e-01,-8.767801531386991420e-02,2.271621231551425035e-01,-3.931435680249659725e-01,3.313521192320215136e-01,-3.951480727725907582e-02,-1.843792597177846410e-02,-3.174043884016145567e-01,2.074989589052148031e-01,-4.466370882308957624e-01,-5.152218017492704583e-01,-2.482345971840690946e-01,-1.489117202222509928e-01,-5.134977906323440200e-01,1.727624044439657891e-01,1.097138120519265542e-01,5.574640379244504701e-02,1.591837470857537240e-01,-1.648741876845654653e-01,-2.169416382156543754e-01,-1.611088934963274266e-01,5.408475532632941313e-02,7.684059953428490353e-01,-4.709146170709960222e-01,-7.477131735572221938e-02,2.236650070287500014e-01,-2.448119954278718188e-02,-4.961783619090029407e-01,-2.057722712436429180e-01,1.630508017799782994e-01,-3.647180384296289657e-01,-1.143950312219180893e-01,-2.065681871132744318e-01,1.750359292386902410e-01,-6.576548211349222397e-04,-1.852287509815327970e-01,-6.529981475590654894e-01,6.891353283562325072e-02,4.880777979946416267e-01,1.725590398657838587e-01,-1.644321390374530397e-05,-1.160054642463527436e-04,2.376512341669688722e-01,2.957979385955305518e-01,1.076232497790455739e-04,3.255908203871259269e-05,-6.717696501111314333e-01,-3.698032207720523545e-01,-3.540118098012681355e-06};
    cv::PCA pcaANN1_2_0;
    pcaANN1_2_0.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_0_pcaMeanLoad.data());
    pcaANN1_2_0.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_0_pcaEigenValLoad.data());
    pcaANN1_2_0.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_0_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_1_pcaMeanLoad = {1.922389949494136706e-15,-1.053050047050225447e-15,4.182919749951243129e-17,-1.285632687852661507e-15,-5.352907009422900511e-16,-9.774991347430179558e-15,-7.644285843035896853e-16,-8.044892679382330556e-16,-5.284626995857519015e-16,-5.443239621964126139e-15,-3.818144542345200765e-15};
    vector<float> cluster1_2_1_pcaEigenValLoad = {6.587023796777819129e+00,4.303205477184127936e+00,8.116855357656796444e-02,1.709412247357579642e-02,8.290131065239686112e-03,2.233328076923309438e-03,5.427757062710015417e-04,3.247299119891722784e-04,2.597802103642604991e-04,4.776738552132488429e-05,6.298301872477039609e-10};
    vector<float> cluster1_2_1_pcaEigenVecLoad = {3.782536213215109688e-01,3.268422960690711143e-01,5.445866844503437915e-02,-1.323697078001968286e-01,-2.109557002738566556e-01,-8.607747852348947293e-02,-3.625539777131518426e-01,-3.766353283663584350e-01,3.773144050925716364e-01,-3.846565608366674383e-01,-3.377466478652791371e-01,-1.103622011401274999e-01,2.558898223794124349e-01,4.767010063334161107e-01,4.509094455077449215e-01,4.008764054943383393e-01,-4.694769604718532219e-01,1.651388023951362305e-01,-8.318513257489287827e-02,-1.184135374433240712e-01,-7.445205740857283039e-02,-2.385611702238662757e-01,2.068835181129861922e-01,3.874944330204814769e-01,-6.358945920498845078e-03,-1.747572871602475764e-01,-3.040552227980070077e-01,-1.650127012107155955e-01,4.301998902650369661e-01,6.617191484906250754e-01,7.119853710242930733e-02,-4.413875626104448585e-02,-1.637874234423716269e-01,-4.388986550571787743e-02,3.409740663819252338e-01,1.373159880344947958e-01,-6.298408294577247934e-01,5.874852749716631406e-01,1.219976040697101291e-02,-1.367231808920703340e-01,5.473115410406784870e-02,1.431248051433271495e-01,2.140614592949075246e-01,1.815810745944404780e-01,-4.210481683950445531e-01,1.919568170954793762e-01,4.496054720942309624e-01,-1.436553880284619500e-01,-4.767331077666543959e-01,6.643146923545399651e-02,-4.011701687384743309e-01,6.111330879003574329e-02,-3.038899533260295827e-01,2.410116446579020077e-01,-1.276456645535077039e-01,1.237808183134885692e-01,8.372348608178276086e-02,4.992822748018358459e-01,3.164438266963207069e-01,-5.767877654419190786e-02,3.979053926875799618e-01,-1.845560880254428979e-02,1.642180960980295645e-01,3.918352926740568676e-01,-1.193237577942883459e-01,5.210685275235014124e-01,1.566405992457971796e-01,2.581514547408220173e-01,-3.744708895814419930e-02,-8.884199244031765197e-02,-2.990130256209385107e-01,-3.966202297718265379e-01,2.116472853322997616e-01,-4.154393328298738863e-01,-2.256972105697061803e-01,9.996963592853379266e-02,6.119578394124667309e-01,-3.614986022809125732e-01,1.870672473582123685e-01,5.351565491523295470e-02,-1.215221086044801779e-01,-8.055360689332356772e-02,4.140417560315588497e-01,6.137079412441905912e-01,-4.321511628092600810e-01,1.700287017525022870e-01,5.098818178270316664e-03,-2.155128208780788257e-01,-6.022488391764899696e-01,3.078235286843560847e-01,-3.821313223099274126e-01,1.079091728535405831e-01,2.466276807772128932e-02,-9.745913714879653189e-02,-1.640787152153988515e-01,1.407140471502631440e-01,9.073602283392687151e-02,-5.142779799067505042e-01,2.352203306917580172e-01,-9.852739616501092479e-02,-5.047398886315695998e-01,3.862329046131127708e-01,-4.436674900925068332e-01,-4.279145620656549243e-02,-1.993609405457456019e-01,1.669928179333515506e-01,2.260530546885264683e-02,-6.530137454603622549e-02,-5.568935039534913534e-01,7.172977051994647302e-02,2.824627270932420497e-01,2.574261299449762119e-01,-5.358879978644577987e-05,-1.809032903952236004e-04,1.681337027133336937e-01,4.517531776276062505e-01,2.550801337948311481e-04,5.620089296114743905e-05,-6.926960707074839574e-01,-3.765219379282965240e-01,1.680035223001393141e-06};
    cv::PCA pcaANN1_2_1;
    pcaANN1_2_1.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_1_pcaMeanLoad.data());
    pcaANN1_2_1.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_1_pcaEigenValLoad.data());
    pcaANN1_2_1.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_1_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_2_pcaMeanLoad = {8.064736186498478040e-16,4.874794644199036222e-16,-1.579109183370331400e-17,-7.331578351362253436e-17,2.309447180679109746e-16,4.526121696835212285e-15,-2.707044314349139455e-17,-3.080672826485869714e-16,-3.758843823986878028e-15,2.749341881760844607e-16,8.061916348671031597e-16};
    vector<float> cluster1_2_2_pcaEigenValLoad = {7.725129937479252362e+00,3.144522009877675384e+00,1.082129727825286436e-01,1.113324165260440660e-02,6.741321287121878995e-03,2.759259838402341059e-03,1.477778016344342017e-03,3.945863923159639419e-04,3.611437490144686884e-05,2.933801510377345245e-05,1.916794417645027702e-10};
    vector<float> cluster1_2_2_pcaEigenVecLoad = {3.320439674454554457e-01,-2.281597309429722331e-01,-3.363808020774316510e-01,-3.412616472714620208e-01,-3.574009783272574792e-01,-3.054652898783401585e-02,-3.398298715844040307e-01,-3.373314803802535122e-01,3.228883131756026814e-01,-3.136933562912650464e-01,-2.178820354427321859e-01,-2.104935305718799443e-01,-4.191376525965168076e-01,-1.924438306327038162e-01,-1.419872280720591573e-01,-4.953327794225181879e-02,5.609224510527205387e-01,-1.758255519787636778e-01,-1.920483576085013910e-01,-2.483344669761267665e-01,2.749126720596667961e-01,4.479836805334902472e-01,2.710201619485729241e-01,-6.391132594423657443e-01,2.273019904215362597e-01,5.762290012830487695e-01,-6.917942262150283961e-02,-3.165364199964197049e-03,2.973133491993956712e-01,-1.499884363234236517e-01,5.130458382403182971e-02,-1.204793178002304121e-01,-3.925887958710719272e-02,-2.522094074822036069e-01,3.094919980840070139e-01,1.434112749345778648e-01,1.347432425195875527e-01,-5.981820617408182272e-01,5.386384693059570461e-01,2.657551034018408864e-01,-2.376548966646707672e-02,1.159404678344224532e-01,-1.625331456966704335e-01,-2.070739338900500492e-01,-8.030388140649070972e-02,8.779263634787670689e-02,7.067105876760687577e-01,-2.206715754315207167e-01,2.227191502929986300e-01,4.094496970914006384e-02,-1.367630092654892882e-01,-5.949095614674104748e-01,9.052772120085922358e-02,-6.680593568560574957e-02,3.387951989316009827e-02,3.123074462917250771e-01,6.751298347409712131e-02,2.508706431710572282e-01,-2.405845120394261294e-01,-4.679684675495978108e-01,-2.554421303067159754e-01,1.978745066497906158e-01,1.559040082155614682e-01,4.469816424310214809e-02,4.314322848348196154e-02,6.523222027865127615e-01,-1.080963933715779063e-01,2.853788735570421120e-01,-2.646021790895380921e-01,4.394248772793004632e-01,1.914210893536472669e-01,2.748746116443135171e-02,-1.399336247213686102e-01,-1.888407635212120406e-01,3.327477859351987699e-01,-4.050270424342469200e-01,5.256973377364231315e-01,-4.765072089225778906e-02,-2.323645216503814892e-01,2.696339347583513041e-02,-4.287574411485702841e-01,3.774796177113801665e-01,2.771665087999954924e-01,4.083959236617592525e-01,3.285082865112186612e-01,3.600808935424665291e-01,-3.640170508873251110e-01,5.470325913145036162e-02,1.916860598871094057e-01,-4.551381856265855619e-02,3.397124676705949309e-01,1.690100619935015758e-01,1.402274996928717975e-03,2.709293002164839814e-01,-6.112196901204526300e-01,5.024617563125421960e-01,3.208657834038284862e-01,1.209611817686393892e-01,-1.294404597115690614e-02,-4.004592892108830848e-01,-2.244263953412651835e-01,1.704655562473072761e-01,-3.340788404961016894e-02,-1.656763387904382490e-01,-2.108228848740737182e-01,-2.770621346552845088e-01,2.280214455101751969e-01,-4.302101133494901641e-01,-6.100248105560539535e-01,3.503431117362631325e-02,6.271574763608263048e-01,2.605322881023128812e-01,-2.746767955090427985e-05,-7.950492535336258263e-05,1.789458191444597834e-01,3.632334128640153370e-01,6.424070437545377845e-05,2.466660067732359633e-05,-5.285741684987071975e-01,-3.089427857333951755e-01,-4.375496520916009329e-06};
    cv::PCA pcaANN1_2_2;
    pcaANN1_2_2.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_2_pcaMeanLoad.data());
    pcaANN1_2_2.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_2_pcaEigenValLoad.data());
    pcaANN1_2_2.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_2_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_3_pcaMeanLoad = {-1.177805200681715036e-15,1.506495024127775069e-16,8.559630818907812329e-17,7.221215818133136152e-17,4.292265781554135954e-16,1.709747348664022354e-15,-1.438017977576512521e-16,-2.791995943476475842e-16,1.883585669113477618e-15,4.754485845775158029e-16,3.155858068105684170e-15};
    vector<float> cluster1_2_3_pcaEigenValLoad = {8.053906504502414521e+00,2.752667137571218170e+00,1.606743511069035901e-01,1.457367530475986092e-02,1.021350840394329162e-02,4.269942978699954074e-03,2.246270544522118232e-03,1.666204257595089262e-03,2.514387312158048522e-04,1.285192930719247240e-05,1.559044499277038419e-10};
    vector<float> cluster1_2_3_pcaEigenVecLoad = {-3.358386313727259043e-01,2.280821692331077288e-01,3.382538197019940851e-01,3.352359347232644060e-01,3.503718902216141351e-01,1.157548184675957909e-01,3.329763565794209290e-01,2.961305160897245714e-01,-3.331312762940023542e-01,3.309677465618889869e-01,2.305425919801235013e-01,1.675052881652311920e-01,4.395293795889443356e-01,1.503019961040131247e-01,1.133052012415430160e-01,4.618246018556263627e-02,-5.677105507686107666e-01,1.748066392345099529e-01,3.210793026764181546e-01,1.945493902424651200e-01,-2.025156014866336118e-01,-4.542991760436808080e-01,2.900885597985326525e-01,-5.516923873807934031e-01,2.049729967405837239e-01,5.966808966502302747e-01,-1.041592146938659195e-02,-6.326599683767110405e-02,3.580079300158473532e-01,-2.227025648261075075e-01,8.257576217143210162e-02,-1.491684120346487841e-01,-4.994953055380200319e-02,-1.394259527123860032e-01,5.516683971806479736e-02,6.103780441819048885e-01,-2.317243734449350723e-01,-4.880640618112518370e-01,4.261658096109495752e-01,1.993575282411061966e-01,6.785907366295743093e-02,1.598506448379709566e-01,-1.916458756411853481e-01,-1.575024046633771990e-01,1.669184415437353908e-01,-6.104049574643574672e-02,6.354917557512868020e-01,-3.107355544732836039e-01,2.997734793226665695e-01,-3.520833640779987284e-01,-2.748866442459805826e-01,-3.688640055871280077e-01,-6.727536428896016552e-02,1.084934026313757738e-01,1.620462473707015849e-01,2.178686342047586599e-01,9.720761996165847019e-02,-2.098923000829882538e-03,-1.312115505926097700e-02,-3.533962224138776920e-01,-2.605516718001184007e-01,1.211092474428464155e-01,2.491897265457985733e-01,1.359985868884208138e-01,-1.295752123484495144e-01,7.988009652260814608e-01,-2.437102008202958747e-01,3.021361632628177252e-01,2.836888887529236125e-02,2.715435431098075503e-01,3.618395318056087939e-01,2.167383894955337564e-01,-1.938804829539642616e-01,-2.451607933151888352e-01,4.381089327693247770e-01,-5.116062535496782582e-01,2.133100069220364714e-01,7.675418520286868967e-03,4.931895374742872179e-02,1.853265112608833975e-01,5.104003198294355670e-01,-3.478014809527705253e-01,-1.165268445744702770e-03,-7.200997421385608721e-01,1.722426170950618618e-01,-1.299809081995529636e-01,1.153723348398721510e-01,-5.718503803989282569e-02,-8.513702403881072411e-02,4.677565639989291202e-01,-9.582442928018777839e-02,1.768456051032250842e-01,-3.770723752568946319e-01,-1.289721155391058416e-01,2.103823938222059431e-01,-6.831368690496241181e-01,-1.500985145008385813e-01,2.030149185843371229e-01,-2.391768667639503423e-04,3.826038674057293809e-01,1.526367935565200451e-01,1.520415126266812418e-02,5.298132666539290270e-02,9.234666728939554259e-02,2.597049378320466229e-01,5.668673697590735118e-03,2.024894476034655444e-02,6.075919568038828933e-01,6.177752874078966672e-01,-6.862629542390455764e-03,-6.834817548052479763e-01,-3.136821644545353394e-01,5.487950798444071342e-05,3.059388261828263595e-05,-1.394039815385292591e-01,-3.946877896760290216e-01,-5.164316667205023739e-06,-5.290998915057467181e-05,4.418704432127804060e-01,2.529718834260073490e-01,-5.189207911966616228e-07};
    cv::PCA pcaANN1_2_3;
    pcaANN1_2_3.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_3_pcaMeanLoad.data());
    pcaANN1_2_3.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_3_pcaEigenValLoad.data());
    pcaANN1_2_3.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_3_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_4_pcaMeanLoad = {9.256679725900211404e-16,2.076458396113935264e-16,-5.776168148961731973e-17,-9.481802176834104732e-16,-1.508024207505855153e-15,5.399236150523075376e-16,-2.448206653906087971e-16,-1.931313658011819958e-16,1.110801567108025211e-15,3.128905854229885735e-15,2.233155470513974248e-15};
    vector<float> cluster1_2_4_pcaEigenValLoad = {6.580187596997506105e+00,4.346659817734520814e+00,4.997399200078174453e-02,1.421059282850861347e-02,6.550873361848344283e-03,1.722660633476110099e-03,4.367145989363077694e-04,3.502884953753099230e-04,8.897515796190886054e-05,4.777858670059185228e-05,4.702599091795190331e-10};
    vector<float> cluster1_2_4_pcaEigenVecLoad = {3.878617246948791730e-01,1.747043563431320556e-01,-1.575102114927992569e-01,-2.648742151966343994e-01,-3.100956954705099688e-01,4.721609108259523097e-02,-3.768690009501119431e-01,-3.660599212497960830e-01,3.881361462550576014e-01,-3.593063366659029478e-01,-2.643942752101603455e-01,3.257225949985426833e-02,4.270018427958586771e-01,4.378229821741644878e-01,3.495727867676096112e-01,2.875604937589463228e-01,-4.757269333957705459e-01,1.136633754067197383e-01,-1.453857721655630320e-01,4.138782261990864991e-02,-1.851774207898438940e-01,-3.516407396392050577e-01,2.898164425681918899e-01,2.469660662802079520e-01,-1.898184555341497493e-01,-1.557681864005433237e-01,-2.206869993942418284e-01,-1.473839336912745046e-01,3.952748611315175520e-01,7.212353421454603675e-01,1.244275021571973755e-01,-1.057557424565982590e-01,-1.456211770228499347e-01,-1.542772338764031859e-01,4.422343745019186034e-01,-1.028264904368398659e-02,-6.436153750764909143e-01,4.746883946728872039e-01,-8.642450167615178813e-02,-2.273853059417441091e-01,7.518366145203177198e-02,6.077050117660399292e-02,2.115677804618570357e-01,1.663487385965842780e-01,-3.132635608456628695e-01,3.347130409174924326e-01,4.716390073789878956e-01,-9.091785966665935897e-04,-5.748061157411414879e-01,2.017991356662935110e-01,-3.218912471824325050e-01,2.119321621402638078e-01,-1.585216001343733028e-01,1.370567723943994232e-01,-6.181510348919713738e-02,3.154361004333280927e-01,1.472069420484911906e-01,3.326133836207588179e-01,1.714283164406857352e-01,-1.437974702840181217e-02,8.942916567541214778e-02,5.820510132707212153e-02,1.103598400199592641e-02,3.338577593558390011e-01,-1.183455077145939421e-01,7.756482513840247117e-01,5.904430531074758015e-01,-2.814815314385832323e-01,3.882945957580180019e-01,-2.724825273391672797e-01,-8.262985674130936264e-02,-2.153138275473626684e-01,-9.180369768957535306e-04,-7.639863721196459012e-02,-2.308012946856548286e-01,4.748389539657530412e-01,-9.674257463136259894e-02,-2.394974906365706854e-02,1.488958681908411352e-01,-3.387347579210490123e-01,2.029778746006735343e-02,-3.167832296853458351e-01,-6.239326393450891350e-01,-1.325181315114588587e-01,-1.408318758358684808e-01,-4.334122881314883546e-01,-8.889070283155445229e-02,3.732521929230586677e-01,-1.725774739965904303e-01,2.095626288101388734e-01,5.851096062155135280e-02,-3.099796973362924368e-01,-2.528476073019980119e-01,1.287643907427561962e-01,7.154736278283545525e-01,-4.806594302166074528e-01,-2.817619989148585982e-02,4.316479841577352400e-02,2.615905050389833938e-02,-2.207970329493525452e-01,-4.389524101202276762e-01,3.812509810305277358e-01,-4.110977698304132399e-01,9.741019677038505187e-03,-1.923186786252957525e-01,2.525577403977099025e-02,1.314884638017287388e-01,-6.451505832611124924e-02,-6.182960868978409907e-01,5.248894476275490356e-02,-3.396209643244833543e-01,-2.426604311412537407e-01,4.482734022251445036e-05,1.632836994065243834e-04,-2.128446445305448576e-01,-4.520222506809036256e-01,-1.642215089745874507e-04,-4.813186884732736730e-05,6.676829200214454696e-01,3.610346496739844091e-01,-4.864826776674572941e-06};
    cv::PCA pcaANN1_2_4;
    pcaANN1_2_4.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_4_pcaMeanLoad.data());
    pcaANN1_2_4.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_4_pcaEigenValLoad.data());
    pcaANN1_2_4.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_4_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_5_pcaMeanLoad = {-1.012169139259401994e-16,4.892150839753776221e-17,4.892150839753776221e-17,-1.265211424074252492e-16,3.660678386988170232e-16,2.354136723060825897e-15,1.018495196379773275e-16,-5.693451408334135599e-17,3.424505587827643232e-16,-7.481616887692413079e-16,1.377393503675502781e-15};
    vector<float> cluster1_2_5_pcaEigenValLoad = {6.123327463160681994e+00,4.229727651353923257e+00,5.368912201511331084e-01,5.588616551828151646e-02,4.038874143229285313e-02,1.291799365906800938e-02,2.033875697457677642e-03,9.290643568023019584e-04,5.100262990567322983e-04,4.432768780541044912e-09,6.535080822027907636e-11};
    vector<float> cluster1_2_5_pcaEigenVecLoad = {2.857018020875778386e-01,3.951306544516452468e-01,3.441726470045979730e-02,-1.626233607705689921e-01,-3.918883027956703291e-01,-1.844665807557083481e-01,2.006288531224687255e-01,2.899924800147563042e-01,3.411887906285170358e-01,-3.992750368242839465e-01,-3.831880194931013284e-01,-3.311652033434286380e-01,-2.911350395473747982e-03,4.727886710978557727e-01,4.392923650276644998e-01,1.007787636099032741e-01,-3.598828097313410135e-01,3.999890653928958040e-01,2.898263365925656809e-01,-2.591684226676342351e-01,2.314927462786342885e-02,-1.498249267247085958e-01,-2.346764290406917475e-01,-2.515811968100964413e-01,-2.334268668648800671e-01,9.254763293199577689e-02,-1.353273183231741006e-01,6.645709798697815307e-01,3.519694959236260856e-01,4.506389356075522490e-01,5.540467261146535261e-02,-1.571839826678352592e-01,6.227503238274067349e-02,2.514989513062501070e-01,-3.917686712375690328e-01,3.302064488758298388e-01,2.079237961980256177e-01,-1.261985252215827580e-01,2.212317114321331879e-01,2.430666160671930143e-01,-6.043205445121895281e-01,6.590143848942471572e-02,-3.149640235912318231e-01,-1.956972350216279466e-01,2.279138034006934765e-01,-1.803406072728152842e-01,-5.339859788193020984e-01,5.943602662118553370e-01,-3.390908247975541467e-01,-3.105449119782516809e-01,-1.174772011680241673e-01,3.647662700260025093e-02,-1.679010628777630187e-01,-1.052584409790098957e-01,1.063256258802532800e-01,-2.698713121085287714e-01,-6.041051551178724943e-02,1.519415012257952502e-01,2.419346900652817878e-01,1.567814347323530921e-01,1.289911264695478288e-01,-7.100227243798052923e-01,1.476156595736264621e-01,1.182104759372410718e-01,-4.157204377839270881e-01,-2.965846428600528162e-01,1.897366620591472430e-01,-1.784575712906088518e-01,-3.285453714573471906e-01,-2.644816858255956762e-02,7.668225482420036876e-01,-2.077562122428901759e-01,2.476722617545411842e-01,6.907053189683605432e-02,1.927834113382052295e-01,-2.820024952691420062e-01,-9.761518698481511103e-02,5.883846996924360084e-01,-4.540953756380384787e-01,3.031352545690284561e-01,-1.197940215902728867e-01,9.402010038038385517e-03,1.679116176556691778e-02,-1.911624858630924795e-01,4.730117895555816521e-01,-1.175287709022904969e-01,2.477831999045496669e-01,-7.413588004283838684e-02,-9.913875205218909692e-02,-4.862040291926627428e-02,-3.110094843335852177e-01,-4.290709078573415325e-02,-8.105335256376591802e-03,8.600818623347704361e-02,3.121480149833781234e-02,-1.095187104965276992e-01,-1.999322779408554684e-01,3.931714574436055432e-01,-8.211279555740524927e-01,-2.989315818226814803e-01,-4.248605912073196156e-01,-8.351199618944819825e-02,-5.477869666811359117e-01,-2.121334057702943809e-01,-3.202618331479850089e-01,-7.232479933890395346e-04,-3.402613791636938914e-04,-3.666165598667520120e-01,-3.756484062107070532e-01,-5.324631785723228910e-04,-2.902050552837632802e-01,-4.123046860224273691e-01,6.938490468398751491e-04,4.503146611477721294e-03,-1.711524050590167434e-01,-2.817301841177266009e-01,-4.591945044977990137e-04,-5.400601795565518267e-05,7.358571216984449714e-01,3.092153815232112080e-01,1.068596721849299958e-05};
    cv::PCA pcaANN1_2_5;
    pcaANN1_2_5.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_5_pcaMeanLoad.data());
    pcaANN1_2_5.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_5_pcaEigenValLoad.data());
    pcaANN1_2_5.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_5_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_6_pcaMeanLoad = {1.499930047718503910e-15,1.283322382189286110e-15,8.028760387794529756e-16,7.624507952717558757e-17,6.495466721383596961e-15,9.261986170750859850e-16,4.062992828495128570e-16,7.869617973479417791e-16,-2.651077234995914670e-15,1.395643153707507967e-15,-5.465083552686142579e-15};
    vector<float> cluster1_2_6_pcaEigenValLoad = {5.881251355515491497e+00,4.989789767999529779e+00,7.181237151518948814e-02,4.263702400171510976e-02,9.770279378963749040e-03,3.583198192798143448e-03,6.421964957930751490e-04,3.927286010320315559e-04,2.093510099395813661e-04,7.016610429542223895e-05,9.853324301715192267e-10};
    vector<float> cluster1_2_6_pcaEigenVecLoad = {3.569408342508905152e-01,3.674325851131396425e-01,9.420816312155537442e-02,-6.644111795311700985e-02,-1.513068515176841933e-01,-5.664350982727909406e-02,-3.871978682649073189e-01,-3.856082866559681355e-01,3.499673082827765569e-01,-4.060157068578799100e-01,-3.350416012338971461e-01,-2.219983712359293870e-01,1.924505714830995473e-01,4.352687594268164761e-01,4.393717603797147597e-01,4.095663464845342161e-01,-4.429199075862099710e-01,1.428076325216041109e-01,-1.398728571261670106e-01,-2.344589012921104720e-01,-7.509671799992923003e-02,-2.582276083746700701e-01,1.951960597693099819e-01,5.202511580934132684e-01,5.247260764954497086e-02,-2.236192695738919156e-01,-1.202759718637917835e-01,-1.433538167354425352e-01,4.323685122932518499e-01,6.107795007023518741e-01,8.911012021936293159e-02,-4.094179960897187213e-03,-1.884413637138631359e-01,-1.389950112936057247e-01,-1.604784209794339889e-01,1.712052158270981408e-02,3.350034546778482558e-01,-7.989594127541871371e-01,-9.273857419084211018e-02,-3.841580652229274057e-02,1.065875605022182093e-01,-3.037613196636512192e-01,-1.001217551578432452e-01,-2.834396982328930559e-01,-3.160419824589791316e-01,2.328296151683739990e-01,3.163174784539249385e-01,-4.438828814010166157e-01,-5.276563311123246697e-02,1.098607317715251212e-02,-5.349353176369050500e-01,8.334495352217655140e-02,-2.408831887980080466e-01,4.233430395072648178e-01,-1.247716118694000287e-01,4.678899853071902953e-02,2.063823915914974813e-02,5.812144992555600131e-01,3.564779391439861778e-01,-7.235621052959079202e-02,2.804374528040868286e-01,-2.200644334883222197e-01,3.475767624444598414e-01,2.803577003628942022e-01,-1.123534368008694273e-01,4.337692424902609423e-01,2.053546811764780100e-01,3.577262583972702914e-01,-1.025727663220611652e-02,-4.056458292331758392e-03,-2.722484015122945689e-01,-3.689831616217749688e-01,6.983104060288604364e-02,-3.215226236308965091e-01,-2.416731535125790920e-01,1.434124981972633717e-01,6.574539658422753341e-01,7.433791574486436904e-01,-2.966639868804027969e-01,1.809618828899671183e-01,1.184017890402595391e-01,6.285235100128153118e-02,-7.960774396709528744e-02,-7.105243281764855867e-02,4.398267559155872447e-02,-1.247188800608403370e-01,4.860421028776579777e-01,-2.086845963442640894e-01,-9.348077789876850507e-02,3.739007121760297425e-02,4.067045143851458766e-01,-1.269956089646487596e-01,-2.116051128130320980e-01,4.145957717925333741e-01,5.324366295893043777e-01,-4.619903655045734525e-01,1.418689788865050705e-01,2.434030689120099122e-01,-1.239547449265670509e-01,-8.318013923057296366e-02,4.624579312195624681e-01,-4.031022460677792796e-01,5.348207214606824911e-01,3.318937047760953801e-02,2.907437373289253335e-01,-1.151852218062118655e-01,-2.875702569877676765e-02,1.359280844522871845e-01,4.496116661087189992e-01,-1.016560376902824053e-01,2.310333219032825736e-01,2.136889388528311617e-01,-5.784477754948876796e-05,-2.843520112004715170e-04,1.568173791430204356e-01,5.420233466922192989e-01,3.392012131557002510e-04,4.354101812916256125e-05,-6.878598982388148819e-01,-3.307993380267268413e-01,-4.707915958324600742e-06};
    cv::PCA pcaANN1_2_6;
    pcaANN1_2_6.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_6_pcaMeanLoad.data());
    pcaANN1_2_6.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_6_pcaEigenValLoad.data());
    pcaANN1_2_6.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_6_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_7_pcaMeanLoad = {-5.711758326045821057e-17,-3.284261037476347170e-17,-8.567637489068731586e-17,-1.066194887528553322e-16,1.542174748032371907e-16,2.341820913678786658e-15,-3.493692176098027209e-16,-3.284261037476347539e-16,3.807838884030547577e-18,1.903919442015273788e-18,3.046271107224438062e-17};
    vector<float> cluster1_2_7_pcaEigenValLoad = {6.850594220421433178e+00,2.790837664067621127e+00,1.144842191007961807e+00,1.908235420571668950e-01,2.022857588293247230e-02,8.558870642443859936e-03,4.752937492843480050e-03,6.733530390644823505e-04,4.912203913278796090e-04,8.509996455061656239e-11,1.939978110723143121e-11};
    vector<float> cluster1_2_7_pcaEigenVecLoad = {-3.577091067900167731e-01,-8.393921913086749287e-02,3.808735397376361576e-01,3.029796474262722028e-01,3.789919072012711276e-01,1.392656914572471538e-01,9.016965082373350204e-02,-2.151490687576954608e-01,-3.790615411754267861e-01,3.655533474385587178e-01,3.651995267034707782e-01,3.467038985807115864e-02,-5.394408715789396069e-01,1.705314971502292637e-02,3.580949376296072018e-01,-7.523026949536967649e-03,-3.648148172279889329e-02,5.674565709523152757e-01,4.569318414054578392e-01,-4.446316485597417989e-02,-1.434222048142528017e-01,-1.566864766116755625e-01,3.234111290608998601e-01,-2.327878140816944108e-01,5.829761805655638007e-02,6.059167209610705207e-02,9.380111448183632572e-02,-8.603762281279317969e-01,-1.508335957447733688e-01,-1.642423849910135958e-01,-9.335252542385433228e-02,1.358659257659917685e-01,9.054629087032786683e-02,-6.513921070343969832e-02,6.278491927066939260e-01,-4.358664425814813906e-03,-1.124475072023459477e-01,1.289725912299112542e-01,-2.931564970161895101e-01,2.753080522989380663e-01,5.835141766098810301e-01,-6.743149943002464675e-02,1.823955698517585045e-01,1.795151932323680588e-01,-1.098746884603112595e-01,4.005856658214915211e-01,-1.600191262575396955e-01,4.984137029740816072e-01,-3.860106606703018195e-01,-1.686926261499193669e-01,3.655823823397371664e-01,-4.574945748679986046e-01,-6.800375820274789929e-02,-1.492851835266445493e-01,-7.818288408552130642e-02,-1.726267907001834134e-01,8.097654681648551109e-03,-3.133539692859004799e-01,5.536217482781943255e-01,-9.248915773008287156e-02,-4.847418239470373258e-03,-6.261921719398568786e-01,3.682603699103959571e-01,-1.492416779118062309e-01,-5.070423802255889789e-02,6.551788077687926981e-02,-1.349620313892674894e-01,1.874997456506394267e-01,4.270562099300839742e-01,1.111063753671810983e-01,2.389991121929955775e-01,-1.000571500799044555e-01,-1.603434178337398430e-01,3.161843020649006408e-02,-5.738244134093020699e-02,-2.919102957914706045e-02,-8.086537305376938489e-01,-7.572347266781812025e-02,-4.780626835073695236e-02,-7.334684988455892896e-01,-6.950808882786395360e-02,4.597598076091471975e-01,1.412918220237670101e-02,1.405663783512257625e-01,-1.535639954220117398e-01,-1.201907950003427705e-01,3.021920713743256326e-01,-2.974688321196339302e-01,4.730045843395613153e-02,-1.026887637590369468e-01,2.598111833416693467e-02,-1.449391483661230939e-01,-6.094255570604552030e-01,7.068300918201191052e-02,-8.955687815424131365e-03,8.922555689492486786e-02,-3.363422214377282948e-01,6.474037515274687626e-01,-2.209990951206652066e-01,-7.977284450149570993e-01,-2.032644487988508886e-01,-6.931480702792876258e-02,-3.578201213684139015e-01,-1.796838306129522056e-01,-3.216023398425711388e-01,-9.640644860843479479e-04,-5.575546146118311235e-05,-6.922854025424575453e-02,-2.212809133263023142e-01,1.568027058095678897e-05,2.399479697762295916e-01,6.111888792301167772e-02,-3.996860678778101778e-02,-2.062127536361343383e-01,3.364581136030751068e-02,7.726748068746619458e-02,1.013978044166101238e-04,1.339785077112914999e-05,-8.237225454084763365e-01,-4.571073370436021799e-01,5.959164666189582058e-07};
    cv::PCA pcaANN1_2_7;
    pcaANN1_2_7.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_7_pcaMeanLoad.data());
    pcaANN1_2_7.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_7_pcaEigenValLoad.data());
    pcaANN1_2_7.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_7_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_8_pcaMeanLoad = {-6.191558494253010696e-16,1.237019097912344791e-15,1.318452957022561774e-16,-1.034080750605930737e-16,-8.014125817195963431e-17,1.465809463983906869e-15,3.490022533295016532e-17,1.874271360473249562e-17,-1.896245576423625727e-15,1.809641313560378760e-16,-7.367825348067256767e-16};
    vector<float> cluster1_2_8_pcaEigenValLoad = {6.272151424090319338e+00,3.279322137821447214e+00,9.139680998801754663e-01,4.562733324891382058e-01,5.240682487935444805e-02,2.032602618273782191e-02,3.969858368750970451e-03,3.084142674732040859e-03,4.996087752218328175e-04,3.719922718132257125e-10,7.021239371113743562e-11};
    vector<float> cluster1_2_8_pcaEigenVecLoad = {-3.863738615602547166e-01,1.121665641206501113e-01,3.738971652846564964e-01,3.359386436561159761e-01,3.835518575300477795e-01,2.507790242983308215e-01,2.416646582695389789e-01,1.059214722287214888e-01,-3.666745273203615429e-01,3.300575997066042544e-01,2.499369892570336982e-01,-5.232256328722529465e-02,3.912668010807763275e-01,1.411981679647290877e-01,2.448048648651873493e-01,-1.237612517589066208e-01,-1.148872731323850871e-01,4.087098976056712241e-01,5.123229768805824813e-01,2.017043207524050752e-01,-2.883795658892969738e-01,-4.271116273373694039e-01,-4.025917126729508348e-03,-5.396605341126022859e-01,-1.634073404904799465e-01,6.370650831423144145e-02,-9.640944434564784060e-02,7.108164756889621128e-01,2.175631156206141170e-01,2.265304009149445852e-01,1.509671896745027608e-01,-2.044059115289176276e-01,1.457319016184987007e-02,3.432258730260632218e-01,-5.780213439234657136e-01,2.189694342897766655e-01,4.343740929534097850e-01,9.713128523295606886e-02,-4.602682723497941719e-01,2.707759125245616794e-01,-1.159644831326696046e-01,-3.672663995142779608e-02,-3.615024960272527482e-02,-2.746722390519313120e-02,1.379457879470739612e-01,-4.187850746660694984e-02,-4.038373103706140443e-01,-2.724665222545006871e-01,-9.370577875381097543e-02,-2.654305584951996977e-01,3.542977110124917450e-01,5.002859991359310810e-01,-1.721755177533228764e-01,3.004422753057016671e-01,4.085798553326449034e-01,4.852962284090300837e-02,1.235049304877878784e-01,2.423281116244778710e-01,8.329893068760986508e-02,-8.215936520460664916e-01,1.200532344957882802e-01,2.598623451893251612e-01,-3.039561147659262108e-01,-1.347416134380986785e-01,1.612850541876409693e-01,1.523645131667567265e-01,-1.095641647625395232e-01,2.134710855121715323e-01,-6.875066831991284433e-01,6.180172967540654705e-01,-1.145750298232598623e-03,-8.070263754849871241e-03,4.016816223744899134e-02,-2.565714752438147395e-01,1.032867566932100557e-02,-7.195570813591500858e-02,1.225635360860231476e-01,-5.288921241766159770e-02,8.284894522336208600e-02,-1.055283038936839640e-01,-3.881118017810984977e-01,2.906079734625486299e-01,3.107853184876492939e-02,6.769634262185043605e-01,-5.028370810575322203e-01,9.908366885778623068e-02,-5.665588701719901504e-02,-1.378435599036165471e-01,3.592174124167384075e-02,1.574781777809246275e-01,2.377120747864669981e-01,1.368536996626773571e-03,8.108980873627433250e-02,-5.397494790038116774e-02,3.086580186989604582e-02,-1.387701889426016903e-02,3.817047833306038140e-01,-4.807322225114386560e-01,7.279870986478533812e-01,6.017849658265529422e-01,2.449358484338671760e-01,5.857559495552579903e-02,1.425892759709907753e-01,1.692781790606467940e-01,2.641330759434736830e-01,3.204438819242007232e-04,-2.797538258290924708e-05,4.455305738337707044e-01,5.071286795121510149e-01,-7.826909624595448987e-05,5.749227115590973547e-01,2.339929710773039073e-01,-8.193592341795374531e-03,-1.974821811101811972e-02,1.239354250942618779e-01,2.196067148297364269e-01,1.997002752685417683e-04,-1.130979735722488487e-05,-6.315102686772564589e-01,-3.896943409036872086e-01,-2.385438077711347265e-05};
    cv::PCA pcaANN1_2_8;
    pcaANN1_2_8.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_8_pcaMeanLoad.data());
    pcaANN1_2_8.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_8_pcaEigenValLoad.data());
    pcaANN1_2_8.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_8_pcaEigenVecLoad.data());
    
    vector<float> cluster1_2_9_pcaMeanLoad = {4.713974651264003572e-16,2.816525735031951715e-17,-1.441616461746617463e-16,-4.413792303188229923e-16,-4.135845684599550471e-16,1.989356598112041941e-15,-1.200729392303095338e-16,-1.667679711532076708e-16,5.381046535876834452e-16,-9.783720974321517522e-17,1.363791408541787227e-15};
    vector<float> cluster1_2_9_pcaEigenValLoad = {7.587654775147089303e+00,3.282104550487640271e+00,8.477507902923886451e-02,2.829381893948466550e-02,1.213997561188072394e-02,3.235091136718473183e-03,1.364150066098765521e-03,9.009376204775431350e-04,8.475956974951772620e-05,2.061562823328675438e-05,1.537494330136197239e-10};
    vector<float> cluster1_2_9_pcaEigenVecLoad = {-3.494368192042088261e-01,-2.822144911302288534e-02,3.292590774714901913e-01,3.500330741414495184e-01,3.620331346643745896e-01,-6.538004162205067471e-02,3.382108630135173266e-01,3.303465618601662546e-01,-3.510231739382024263e-01,3.334354118221262708e-01,2.300181392301074990e-01,1.399998458187113604e-01,5.423777930258385505e-01,2.255285902632239714e-01,1.114888741568411668e-01,-4.180733332448768012e-03,-5.411865813539911141e-01,1.967434547297952918e-01,2.103163692563295994e-01,1.404119814413858636e-01,-2.152996478780985212e-01,-4.254675537365391058e-01,2.593068490465119114e-01,-5.469971987414666836e-01,2.069409256537580455e-01,5.793703267111602884e-01,-2.021157949581475072e-02,-1.552027057888827333e-01,1.185885565622140925e-01,-3.800418066806987571e-01,1.588306416268172108e-02,-1.982479855679315506e-01,-1.803151588503961733e-01,3.062933362562720863e-01,-3.176720810458816269e-01,-4.235210431799075748e-01,1.188782951823941780e-01,-2.245564141959640325e-01,-5.938615587489586706e-02,1.826945925303979090e-01,7.155094872570585407e-01,4.983504490256506630e-02,-7.076924952725817397e-02,7.065026869987836577e-02,-1.634338964517371151e-01,5.217496691883531656e-02,3.315481510596789971e-01,-2.922084965662508430e-02,-5.029795981029021590e-01,5.630516079960944387e-01,4.755487036078452912e-01,6.023353794431626079e-02,7.373251312287570913e-02,-1.453095171301820587e-01,-1.828866385516372262e-01,3.957932496499114161e-01,-1.158007683144094422e-03,3.451408889649747458e-01,-2.519259888773204836e-01,-4.598412516011073370e-01,-3.289496110605034107e-01,8.895135830607968364e-02,-1.173648260118065612e-01,-1.715601167048166342e-01,3.195701842559106054e-01,4.334175576889861548e-01,-1.416203664151291508e-01,4.221473817996513889e-01,-1.986889222975861125e-01,5.971185368653062486e-01,-3.369139391311384291e-01,3.867687231314074353e-02,-1.904823923682850140e-01,-8.803905911112096250e-02,3.499784130663344262e-02,-1.729240600353748603e-01,4.642612679781265572e-01,8.266898220453980373e-02,-2.610396185763859053e-02,1.428761172411153468e-01,-1.925773899761880070e-01,3.698756990340977824e-01,-5.389593003499355134e-03,3.147544078860620154e-01,-2.530655283888515877e-02,4.141788443627221761e-01,-4.867730441345705095e-01,5.384652594049017527e-01,3.521179951498689537e-02,1.566757534053470624e-01,-5.619217479122163850e-01,-8.386015108829190587e-03,5.390746073432962915e-02,-7.485256451598695793e-02,6.529333973493534060e-01,-4.021196493513236603e-01,-5.426486125124029697e-02,2.407714304863507737e-01,-3.065534264289696345e-02,-4.843135798227518607e-01,-2.072325274415501295e-01,-1.176323104751030857e-01,-2.392018936836412812e-01,-2.278243411464589974e-01,-3.723657474809892176e-01,6.107410213628442636e-02,-5.252122123204255866e-02,-4.570761678420120488e-01,-4.946010660029433459e-01,2.902734765988599155e-02,5.011839627839438371e-01,2.362252820099105810e-01,-2.184365683478126135e-05,-1.486322201234426628e-04,2.202476041443610089e-01,3.228139937578307639e-01,7.220600912327797217e-05,5.110819452530760429e-05,-6.594162447754170486e-01,-3.247530686650589860e-01,-3.845219457406935598e-06};
    cv::PCA pcaANN1_2_9;
    pcaANN1_2_9.mean = cv::Mat(1, numVarANN, CV_32FC1, cluster1_2_9_pcaMeanLoad.data());
    pcaANN1_2_9.eigenvalues = cv::Mat(numComponentPCA,1, CV_32FC1, cluster1_2_9_pcaEigenValLoad.data());
    pcaANN1_2_9.eigenvectors = cv::Mat(numComponentPCA,numVarANN, CV_32FC1, cluster1_2_9_pcaEigenVecLoad.data());
    
   
    // Declare ANN regression for each cluster
    // Child of parentCluster0
    std::string frozenPathReg_cluster0_0 = casePath + cluster0_0_Folder + "frozen_bestModel.pb";
    Model modelANNReg0_0(frozenPathReg_cluster0_0);
    std::vector<std::string> operNameANN0_0;
    operNameANN0_0 = modelANNReg0_0.get_operations();
    Tensor inputPCAANNReg0_0{modelANNReg0_0, operNameANN0_0[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_0{modelANNReg0_0, operNameANN0_0[operNameANN0_0.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_1 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_1/900batch_1050epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_1(frozenPathReg_cluster0_1);
    std::vector<std::string> operNameANN0_1;
    operNameANN0_1 = modelANNReg0_1.get_operations();
    Tensor inputPCAANNReg0_1{modelANNReg0_1, operNameANN0_1[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_1{modelANNReg0_1, operNameANN0_1[operNameANN0_1.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_2 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_2/3600batch_2080epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_2(frozenPathReg_cluster0_2);
    std::vector<std::string> operNameANN0_2;
    operNameANN0_2 = modelANNReg0_2.get_operations();
    Tensor inputPCAANNReg0_2{modelANNReg0_2, operNameANN0_2[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_2{modelANNReg0_2, operNameANN0_2[operNameANN0_2.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster0_3 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_3/790batch_1673epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_3(frozenPathReg_cluster0_3);
    std::vector<std::string> operNameANN0_3;
    operNameANN0_3 = modelANNReg0_3.get_operations();
    Tensor inputPCAANNReg0_3{modelANNReg0_3, operNameANN0_3[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_3{modelANNReg0_3, operNameANN0_3[operNameANN0_3.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster0_4 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_4/600batch_1131epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_4(frozenPathReg_cluster0_4);
    std::vector<std::string> operNameANN0_4;
    operNameANN0_4 = modelANNReg0_4.get_operations();
    Tensor inputPCAANNReg0_4{modelANNReg0_4, operNameANN0_4[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_4{modelANNReg0_4, operNameANN0_4[operNameANN0_4.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster0_5 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_5/950batch_616epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_5(frozenPathReg_cluster0_5);
    std::vector<std::string> operNameANN0_5;
    operNameANN0_5 = modelANNReg0_5.get_operations();
    Tensor inputPCAANNReg0_5{modelANNReg0_5, operNameANN0_5[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_5{modelANNReg0_5, operNameANN0_5[operNameANN0_5.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster0_6 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_6/200batch_725epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_6(frozenPathReg_cluster0_6);
    std::vector<std::string> operNameANN0_6;
    operNameANN0_6 = modelANNReg0_6.get_operations();
    Tensor inputPCAANNReg0_6{modelANNReg0_6, operNameANN0_6[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_6{modelANNReg0_6, operNameANN0_6[operNameANN0_6.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_7 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_7/430batch_1579epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_7(frozenPathReg_cluster0_7);
    std::vector<std::string> operNameANN0_7;
    operNameANN0_7 = modelANNReg0_7.get_operations();
    Tensor inputPCAANNReg0_7{modelANNReg0_7, operNameANN0_7[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_7{modelANNReg0_7, operNameANN0_7[operNameANN0_7.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_8 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_8/1000batch_568epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_8(frozenPathReg_cluster0_8);
    std::vector<std::string> operNameANN0_8;
    operNameANN0_8 = modelANNReg0_8.get_operations();
    Tensor inputPCAANNReg0_8{modelANNReg0_8, operNameANN0_8[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_8{modelANNReg0_8, operNameANN0_8[operNameANN0_8.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster0_9 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_9/50batch_699epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_9(frozenPathReg_cluster0_9);
    std::vector<std::string> operNameANN0_9;
    operNameANN0_9 = modelANNReg0_9.get_operations();
    Tensor inputPCAANNReg0_9{modelANNReg0_9, operNameANN0_9[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_9{modelANNReg0_9, operNameANN0_9[operNameANN0_9.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_10 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_10/4200batch_386epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_10(frozenPathReg_cluster0_10);
    std::vector<std::string> operNameANN0_10;
    operNameANN0_10 = modelANNReg0_10.get_operations();
    Tensor inputPCAANNReg0_10{modelANNReg0_10, operNameANN0_10[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_10{modelANNReg0_10, operNameANN0_10[operNameANN0_10.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_11 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_11/240batch_928epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_11(frozenPathReg_cluster0_11);
    std::vector<std::string> operNameANN0_11;
    operNameANN0_11 = modelANNReg0_11.get_operations();
    Tensor inputPCAANNReg0_11{modelANNReg0_11, operNameANN0_11[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_11{modelANNReg0_11, operNameANN0_11[operNameANN0_11.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_12 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_12/230batch_2547epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_12(frozenPathReg_cluster0_12);
    std::vector<std::string> operNameANN0_12;
    operNameANN0_12 = modelANNReg0_12.get_operations();
    Tensor inputPCAANNReg0_12{modelANNReg0_12, operNameANN0_12[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_12{modelANNReg0_12, operNameANN0_12[operNameANN0_12.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster0_13 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster0/ANNReg_childCluster0_13/900batch_1231epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg0_13(frozenPathReg_cluster0_13);
    std::vector<std::string> operNameANN0_13;
    operNameANN0_13 = modelANNReg0_13.get_operations();
    Tensor inputPCAANNReg0_13{modelANNReg0_13, operNameANN0_13[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg0_13{modelANNReg0_13, operNameANN0_13[operNameANN0_13.size()-1]};    //Last tensor = Output (Standardized values)

    
    // parentCluster1 - childCluster 0 - grandChild
    std::string frozenPathReg_cluster1_0_0 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_0/1200batch_1849epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_0(frozenPathReg_cluster1_0_0);
    std::vector<std::string> operNameANN1_0_0;
    operNameANN1_0_0 = modelANNReg1_0_0.get_operations();
    Tensor inputPCAANNReg1_0_0{modelANNReg1_0_0, operNameANN1_0_0[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_0{modelANNReg1_0_0, operNameANN1_0_0[operNameANN1_0_0.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_1 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_1/3700batch_2236epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_1(frozenPathReg_cluster1_0_1);
    std::vector<std::string> operNameANN1_0_1;
    operNameANN1_0_1 = modelANNReg1_0_1.get_operations();
    Tensor inputPCAANNReg1_0_1{modelANNReg1_0_1, operNameANN1_0_1[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_1{modelANNReg1_0_1, operNameANN1_0_1[operNameANN1_0_1.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_2 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_2/4100batch_2828epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_2(frozenPathReg_cluster1_0_2);
    std::vector<std::string> operNameANN1_0_2;
    operNameANN1_0_2 = modelANNReg1_0_2.get_operations();
    Tensor inputPCAANNReg1_0_2{modelANNReg1_0_2, operNameANN1_0_2[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_2{modelANNReg1_0_2, operNameANN1_0_2[operNameANN1_0_2.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_3 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_3/1000batch_3019epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_3(frozenPathReg_cluster1_0_3);
    std::vector<std::string> operNameANN1_0_3;
    operNameANN1_0_3 = modelANNReg1_0_3.get_operations();
    Tensor inputPCAANNReg1_0_3{modelANNReg1_0_3, operNameANN1_0_3[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_3{modelANNReg1_0_3, operNameANN1_0_3[operNameANN1_0_3.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_4 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_4/6batch_1098epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_4(frozenPathReg_cluster1_0_4);
    std::vector<std::string> operNameANN1_0_4;
    operNameANN1_0_4 = modelANNReg1_0_4.get_operations();
    Tensor inputPCAANNReg1_0_4{modelANNReg1_0_4, operNameANN1_0_4[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_4{modelANNReg1_0_4, operNameANN1_0_4[operNameANN1_0_4.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_5 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_5/35batch_1746epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_5(frozenPathReg_cluster1_0_5);
    std::vector<std::string> operNameANN1_0_5;
    operNameANN1_0_5 = modelANNReg1_0_5.get_operations();
    Tensor inputPCAANNReg1_0_5{modelANNReg1_0_5, operNameANN1_0_5[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_5{modelANNReg1_0_5, operNameANN1_0_5[operNameANN1_0_5.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_6 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_6/1800batch_2372epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_6(frozenPathReg_cluster1_0_6);
    std::vector<std::string> operNameANN1_0_6;
    operNameANN1_0_6 = modelANNReg1_0_6.get_operations();
    Tensor inputPCAANNReg1_0_6{modelANNReg1_0_6, operNameANN1_0_6[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_6{modelANNReg1_0_6, operNameANN1_0_6[operNameANN1_0_6.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_7 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_7/6200batch_3129epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_7(frozenPathReg_cluster1_0_7);
    std::vector<std::string> operNameANN1_0_7;
    operNameANN1_0_7 = modelANNReg1_0_7.get_operations();
    Tensor inputPCAANNReg1_0_7{modelANNReg1_0_7, operNameANN1_0_7[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_7{modelANNReg1_0_7, operNameANN1_0_7[operNameANN1_0_7.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_8 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_8/3058batch_2874epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_8(frozenPathReg_cluster1_0_8);
    std::vector<std::string> operNameANN1_0_8;
    operNameANN1_0_8 = modelANNReg1_0_8.get_operations();
    Tensor inputPCAANNReg1_0_8{modelANNReg1_0_8, operNameANN1_0_8[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_8{modelANNReg1_0_8, operNameANN1_0_8[operNameANN1_0_8.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_9 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_9/90batch_1644epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_9(frozenPathReg_cluster1_0_9);
    std::vector<std::string> operNameANN1_0_9;
    operNameANN1_0_9 = modelANNReg1_0_9.get_operations();
    Tensor inputPCAANNReg1_0_9{modelANNReg1_0_9, operNameANN1_0_9[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_9{modelANNReg1_0_9, operNameANN1_0_9[operNameANN1_0_9.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_10 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_10/3batch_368epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_10(frozenPathReg_cluster1_0_10);
    std::vector<std::string> operNameANN1_0_10;
    operNameANN1_0_10 = modelANNReg1_0_10.get_operations();
    Tensor inputPCAANNReg1_0_10{modelANNReg1_0_10, operNameANN1_0_10[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_10{modelANNReg1_0_10, operNameANN1_0_10[operNameANN1_0_10.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_11 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_11/16936batch_3633epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_11(frozenPathReg_cluster1_0_11);
    std::vector<std::string> operNameANN1_0_11;
    operNameANN1_0_11 = modelANNReg1_0_11.get_operations();
    Tensor inputPCAANNReg1_0_11{modelANNReg1_0_11, operNameANN1_0_11[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_11{modelANNReg1_0_11, operNameANN1_0_11[operNameANN1_0_11.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_12 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_12/2111batch_3211epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_12(frozenPathReg_cluster1_0_12);
    std::vector<std::string> operNameANN1_0_12;
    operNameANN1_0_12 = modelANNReg1_0_12.get_operations();
    Tensor inputPCAANNReg1_0_12{modelANNReg1_0_12, operNameANN1_0_12[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_12{modelANNReg1_0_12, operNameANN1_0_12[operNameANN1_0_12.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_13 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_13/5555batch_2179epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_13(frozenPathReg_cluster1_0_13);
    std::vector<std::string> operNameANN1_0_13;
    operNameANN1_0_13 = modelANNReg1_0_13.get_operations();
    Tensor inputPCAANNReg1_0_13{modelANNReg1_0_13, operNameANN1_0_13[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_13{modelANNReg1_0_13, operNameANN1_0_13[operNameANN1_0_13.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_14 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_14/11batch_648epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_14(frozenPathReg_cluster1_0_14);
    std::vector<std::string> operNameANN1_0_14;
    operNameANN1_0_14 = modelANNReg1_0_14.get_operations();
    Tensor inputPCAANNReg1_0_14{modelANNReg1_0_14, operNameANN1_0_14[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_14{modelANNReg1_0_14, operNameANN1_0_14[operNameANN1_0_14.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_15 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_15/1502batch_3399epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_15(frozenPathReg_cluster1_0_15);
    std::vector<std::string> operNameANN1_0_15;
    operNameANN1_0_15 = modelANNReg1_0_15.get_operations();
    Tensor inputPCAANNReg1_0_15{modelANNReg1_0_15, operNameANN1_0_15[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_15{modelANNReg1_0_15, operNameANN1_0_15[operNameANN1_0_15.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_16 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_16/898batch_1791epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_16(frozenPathReg_cluster1_0_16);
    std::vector<std::string> operNameANN1_0_16;
    operNameANN1_0_16 = modelANNReg1_0_16.get_operations();
    Tensor inputPCAANNReg1_0_16{modelANNReg1_0_16, operNameANN1_0_16[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_16{modelANNReg1_0_16, operNameANN1_0_16[operNameANN1_0_16.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_17 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_17/5batch_827epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_17(frozenPathReg_cluster1_0_17);
    std::vector<std::string> operNameANN1_0_17;
    operNameANN1_0_17 = modelANNReg1_0_17.get_operations();
    Tensor inputPCAANNReg1_0_17{modelANNReg1_0_17, operNameANN1_0_17[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_17{modelANNReg1_0_17, operNameANN1_0_17[operNameANN1_0_17.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_18 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_18/2923batch_2709epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_18(frozenPathReg_cluster1_0_18);
    std::vector<std::string> operNameANN1_0_18;
    operNameANN1_0_18 = modelANNReg1_0_18.get_operations();
    Tensor inputPCAANNReg1_0_18{modelANNReg1_0_18, operNameANN1_0_18[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_18{modelANNReg1_0_18, operNameANN1_0_18[operNameANN1_0_18.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_19 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_19/13377batch_2575epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_19(frozenPathReg_cluster1_0_19);
    std::vector<std::string> operNameANN1_0_19;
    operNameANN1_0_19 = modelANNReg1_0_19.get_operations();
    Tensor inputPCAANNReg1_0_19{modelANNReg1_0_19, operNameANN1_0_19[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_19{modelANNReg1_0_19, operNameANN1_0_19[operNameANN1_0_19.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_20 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_20/4795batch_3170epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_20(frozenPathReg_cluster1_0_20);
    std::vector<std::string> operNameANN1_0_20;
    operNameANN1_0_20 = modelANNReg1_0_20.get_operations();
    Tensor inputPCAANNReg1_0_20{modelANNReg1_0_20, operNameANN1_0_20[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_20{modelANNReg1_0_20, operNameANN1_0_20[operNameANN1_0_20.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_21 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_21/86batch_1601epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_21(frozenPathReg_cluster1_0_21);
    std::vector<std::string> operNameANN1_0_21;
    operNameANN1_0_21 = modelANNReg1_0_21.get_operations();
    Tensor inputPCAANNReg1_0_21{modelANNReg1_0_21, operNameANN1_0_21[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_21{modelANNReg1_0_21, operNameANN1_0_21[operNameANN1_0_21.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_22 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_22/7873batch_3866epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_22(frozenPathReg_cluster1_0_22);
    std::vector<std::string> operNameANN1_0_22;
    operNameANN1_0_22 = modelANNReg1_0_22.get_operations();
    Tensor inputPCAANNReg1_0_22{modelANNReg1_0_22, operNameANN1_0_22[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_22{modelANNReg1_0_22, operNameANN1_0_22[operNameANN1_0_22.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_23 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_23/188batch_1769epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_23(frozenPathReg_cluster1_0_23);
    std::vector<std::string> operNameANN1_0_23;
    operNameANN1_0_23 = modelANNReg1_0_23.get_operations();
    Tensor inputPCAANNReg1_0_23{modelANNReg1_0_23, operNameANN1_0_23[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_23{modelANNReg1_0_23, operNameANN1_0_23[operNameANN1_0_23.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_24 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_24/249batch_838epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_24(frozenPathReg_cluster1_0_24);
    std::vector<std::string> operNameANN1_0_24;
    operNameANN1_0_24 = modelANNReg1_0_24.get_operations();
    Tensor inputPCAANNReg1_0_24{modelANNReg1_0_24, operNameANN1_0_24[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_24{modelANNReg1_0_24, operNameANN1_0_24[operNameANN1_0_24.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_25 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_25/4batch_450epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_25(frozenPathReg_cluster1_0_25);
    std::vector<std::string> operNameANN1_0_25;
    operNameANN1_0_25 = modelANNReg1_0_25.get_operations();
    Tensor inputPCAANNReg1_0_25{modelANNReg1_0_25, operNameANN1_0_25[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_25{modelANNReg1_0_25, operNameANN1_0_25[operNameANN1_0_25.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_26 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_26/13batch_1275epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_26(frozenPathReg_cluster1_0_26);
    std::vector<std::string> operNameANN1_0_26;
    operNameANN1_0_26 = modelANNReg1_0_26.get_operations();
    Tensor inputPCAANNReg1_0_26{modelANNReg1_0_26, operNameANN1_0_26[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_26{modelANNReg1_0_26, operNameANN1_0_26[operNameANN1_0_26.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_27 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_27/12696batch_2594epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_27(frozenPathReg_cluster1_0_27);
    std::vector<std::string> operNameANN1_0_27;
    operNameANN1_0_27 = modelANNReg1_0_27.get_operations();
    Tensor inputPCAANNReg1_0_27{modelANNReg1_0_27, operNameANN1_0_27[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_27{modelANNReg1_0_27, operNameANN1_0_27[operNameANN1_0_27.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_28 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_28/2492batch_2227epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_28(frozenPathReg_cluster1_0_28);
    std::vector<std::string> operNameANN1_0_28;
    operNameANN1_0_28 = modelANNReg1_0_28.get_operations();
    Tensor inputPCAANNReg1_0_28{modelANNReg1_0_28, operNameANN1_0_28[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_28{modelANNReg1_0_28, operNameANN1_0_28[operNameANN1_0_28.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_29 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_29/54batch_1286epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_29(frozenPathReg_cluster1_0_29);
    std::vector<std::string> operNameANN1_0_29;
    operNameANN1_0_29 = modelANNReg1_0_29.get_operations();
    Tensor inputPCAANNReg1_0_29{modelANNReg1_0_29, operNameANN1_0_29[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_29{modelANNReg1_0_29, operNameANN1_0_29[operNameANN1_0_29.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_30 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_30/213batch_2006epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_30(frozenPathReg_cluster1_0_30);
    std::vector<std::string> operNameANN1_0_30;
    operNameANN1_0_30 = modelANNReg1_0_30.get_operations();
    Tensor inputPCAANNReg1_0_30{modelANNReg1_0_30, operNameANN1_0_30[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_30{modelANNReg1_0_30, operNameANN1_0_30[operNameANN1_0_30.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_0_31 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_31/1721batch_3501epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_31(frozenPathReg_cluster1_0_31);
    std::vector<std::string> operNameANN1_0_31;
    operNameANN1_0_31 = modelANNReg1_0_31.get_operations();
    Tensor inputPCAANNReg1_0_31{modelANNReg1_0_31, operNameANN1_0_31[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_31{modelANNReg1_0_31, operNameANN1_0_31[operNameANN1_0_31.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_32 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_32/133batch_783epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_32(frozenPathReg_cluster1_0_32);
    std::vector<std::string> operNameANN1_0_32;
    operNameANN1_0_32 = modelANNReg1_0_32.get_operations();
    Tensor inputPCAANNReg1_0_32{modelANNReg1_0_32, operNameANN1_0_32[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_32{modelANNReg1_0_32, operNameANN1_0_32[operNameANN1_0_32.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_33 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_33/1209batch_2024epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_33(frozenPathReg_cluster1_0_33);
    std::vector<std::string> operNameANN1_0_33;
    operNameANN1_0_33 = modelANNReg1_0_33.get_operations();
    Tensor inputPCAANNReg1_0_33{modelANNReg1_0_33, operNameANN1_0_33[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_33{modelANNReg1_0_33, operNameANN1_0_33[operNameANN1_0_33.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_34 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_34/9batch_606epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_34(frozenPathReg_cluster1_0_34);
    std::vector<std::string> operNameANN1_0_34;
    operNameANN1_0_34 = modelANNReg1_0_34.get_operations();
    Tensor inputPCAANNReg1_0_34{modelANNReg1_0_34, operNameANN1_0_34[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_34{modelANNReg1_0_34, operNameANN1_0_34[operNameANN1_0_34.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_35 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_35/2242batch_1523epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_35(frozenPathReg_cluster1_0_35);
    std::vector<std::string> operNameANN1_0_35;
    operNameANN1_0_35 = modelANNReg1_0_35.get_operations();
    Tensor inputPCAANNReg1_0_35{modelANNReg1_0_35, operNameANN1_0_35[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_35{modelANNReg1_0_35, operNameANN1_0_35[operNameANN1_0_35.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_36 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_36/256batch_2495epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_36(frozenPathReg_cluster1_0_36);
    std::vector<std::string> operNameANN1_0_36;
    operNameANN1_0_36 = modelANNReg1_0_36.get_operations();
    Tensor inputPCAANNReg1_0_36{modelANNReg1_0_36, operNameANN1_0_36[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_36{modelANNReg1_0_36, operNameANN1_0_36[operNameANN1_0_36.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_37 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_37/21batch_1630epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_37(frozenPathReg_cluster1_0_37);
    std::vector<std::string> operNameANN1_0_37;
    operNameANN1_0_37 = modelANNReg1_0_37.get_operations();
    Tensor inputPCAANNReg1_0_37{modelANNReg1_0_37, operNameANN1_0_37[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_37{modelANNReg1_0_37, operNameANN1_0_37[operNameANN1_0_37.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_38 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_38/39batch_1286epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_38(frozenPathReg_cluster1_0_38);
    std::vector<std::string> operNameANN1_0_38;
    operNameANN1_0_38 = modelANNReg1_0_38.get_operations();
    Tensor inputPCAANNReg1_0_38{modelANNReg1_0_38, operNameANN1_0_38[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_38{modelANNReg1_0_38, operNameANN1_0_38[operNameANN1_0_38.size()-1]};    //Last tensor = Output (Standardized values)
        
    std::string frozenPathReg_cluster1_0_39 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_0_40grandChild/grandChild1_0_39/8736batch_4716epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_0_39(frozenPathReg_cluster1_0_39);
    std::vector<std::string> operNameANN1_0_39;
    operNameANN1_0_39 = modelANNReg1_0_39.get_operations();
    Tensor inputPCAANNReg1_0_39{modelANNReg1_0_39, operNameANN1_0_39[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_0_39{modelANNReg1_0_39, operNameANN1_0_39[operNameANN1_0_39.size()-1]};    //Last tensor = Output (Standardized values)
        

    // parentCluster1 - childCluster 1 - grandChild
    std::string frozenPathReg_cluster1_1_0 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_0/50btach_696epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_0(frozenPathReg_cluster1_1_0);
    std::vector<std::string> operNameANN1_1_0;
    operNameANN1_1_0 = modelANNReg1_1_0.get_operations();
    Tensor inputPCAANNReg1_1_0{modelANNReg1_1_0, operNameANN1_1_0[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_0{modelANNReg1_1_0, operNameANN1_1_0[operNameANN1_1_0.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_1 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_1/1800batch_2291epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_1(frozenPathReg_cluster1_1_1);
    std::vector<std::string> operNameANN1_1_1;
    operNameANN1_1_1 = modelANNReg1_1_1.get_operations();
    Tensor inputPCAANNReg1_1_1{modelANNReg1_1_1, operNameANN1_1_1[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_1{modelANNReg1_1_1, operNameANN1_1_1[operNameANN1_1_1.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_2 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_2/80batch_1486epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_2(frozenPathReg_cluster1_1_2);
    std::vector<std::string> operNameANN1_1_2;
    operNameANN1_1_2 = modelANNReg1_1_2.get_operations();
    Tensor inputPCAANNReg1_1_2{modelANNReg1_1_2, operNameANN1_1_2[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_2{modelANNReg1_1_2, operNameANN1_1_2[operNameANN1_1_2.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster1_1_3 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_3/50batch_1444epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_3(frozenPathReg_cluster1_1_3);
    std::vector<std::string> operNameANN1_1_3;
    operNameANN1_1_3 = modelANNReg1_1_3.get_operations();
    Tensor inputPCAANNReg1_1_3{modelANNReg1_1_3, operNameANN1_1_3[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_3{modelANNReg1_1_3, operNameANN1_1_3[operNameANN1_1_3.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_4 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_4/1100batch_2913epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_4(frozenPathReg_cluster1_1_4);
    std::vector<std::string> operNameANN1_1_4;
    operNameANN1_1_4 = modelANNReg1_1_4.get_operations();
    Tensor inputPCAANNReg1_1_4{modelANNReg1_1_4, operNameANN1_1_4[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_4{modelANNReg1_1_4, operNameANN1_1_4[operNameANN1_1_4.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_5 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_5/900batch_3106epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_5(frozenPathReg_cluster1_1_5);
    std::vector<std::string> operNameANN1_1_5;
    operNameANN1_1_5 = modelANNReg1_1_5.get_operations();
    Tensor inputPCAANNReg1_1_5{modelANNReg1_1_5, operNameANN1_1_5[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_5{modelANNReg1_1_5, operNameANN1_1_5[operNameANN1_1_5.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_6 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_6/700batch_2883epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_6(frozenPathReg_cluster1_1_6);
    std::vector<std::string> operNameANN1_1_6;
    operNameANN1_1_6 = modelANNReg1_1_6.get_operations();
    Tensor inputPCAANNReg1_1_6{modelANNReg1_1_6, operNameANN1_1_6[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_6{modelANNReg1_1_6, operNameANN1_1_6[operNameANN1_1_6.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_7 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_7/20batch_1074epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_7(frozenPathReg_cluster1_1_7);
    std::vector<std::string> operNameANN1_1_7;
    operNameANN1_1_7 = modelANNReg1_1_7.get_operations();
    Tensor inputPCAANNReg1_1_7{modelANNReg1_1_7, operNameANN1_1_7[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_7{modelANNReg1_1_7, operNameANN1_1_7[operNameANN1_1_7.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_8 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_8/1500batch_2164epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_8(frozenPathReg_cluster1_1_8);
    std::vector<std::string> operNameANN1_1_8;
    operNameANN1_1_8 = modelANNReg1_1_8.get_operations();
    Tensor inputPCAANNReg1_1_8{modelANNReg1_1_8, operNameANN1_1_8[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_8{modelANNReg1_1_8, operNameANN1_1_8[operNameANN1_1_8.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_9 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_9/20batch_1703epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_9(frozenPathReg_cluster1_1_9);
    std::vector<std::string> operNameANN1_1_9;
    operNameANN1_1_9 = modelANNReg1_1_9.get_operations();
    Tensor inputPCAANNReg1_1_9{modelANNReg1_1_9, operNameANN1_1_9[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_9{modelANNReg1_1_9, operNameANN1_1_9[operNameANN1_1_9.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_10 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_10/240batch_2534epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_10(frozenPathReg_cluster1_1_10);
    std::vector<std::string> operNameANN1_1_10;
    operNameANN1_1_10 = modelANNReg1_1_10.get_operations();
    Tensor inputPCAANNReg1_1_10{modelANNReg1_1_10, operNameANN1_1_10[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_10{modelANNReg1_1_10, operNameANN1_1_10[operNameANN1_1_10.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_11 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_11/1200batch_2322epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_11(frozenPathReg_cluster1_1_11);
    std::vector<std::string> operNameANN1_1_11;
    operNameANN1_1_11 = modelANNReg1_1_11.get_operations();
    Tensor inputPCAANNReg1_1_11{modelANNReg1_1_11, operNameANN1_1_11[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_11{modelANNReg1_1_11, operNameANN1_1_11[operNameANN1_1_11.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_12 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_12/2000batch_2252epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_12(frozenPathReg_cluster1_1_12);
    std::vector<std::string> operNameANN1_1_12;
    operNameANN1_1_12 = modelANNReg1_1_12.get_operations();
    Tensor inputPCAANNReg1_1_12{modelANNReg1_1_12, operNameANN1_1_12[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_12{modelANNReg1_1_12, operNameANN1_1_12[operNameANN1_1_12.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_13 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_13/800batch_2372epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_13(frozenPathReg_cluster1_1_13);
    std::vector<std::string> operNameANN1_1_13;
    operNameANN1_1_13 = modelANNReg1_1_13.get_operations();
    Tensor inputPCAANNReg1_1_13{modelANNReg1_1_13, operNameANN1_1_13[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_13{modelANNReg1_1_13, operNameANN1_1_13[operNameANN1_1_13.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_1_14 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_1_15grandChild/grandChild1_1_14/30batch_1259epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_1_14(frozenPathReg_cluster1_1_14);
    std::vector<std::string> operNameANN1_1_14;
    operNameANN1_1_14 = modelANNReg1_1_14.get_operations();
    Tensor inputPCAANNReg1_1_14{modelANNReg1_1_14, operNameANN1_1_14[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_1_14{modelANNReg1_1_14, operNameANN1_1_14[operNameANN1_1_14.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    // parentCluster1 - childCluster 2 - grandChild
    std::string frozenPathReg_cluster1_2_0 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_0/770batch_3840epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_0(frozenPathReg_cluster1_2_0);
    std::vector<std::string> operNameANN1_2_0;
    operNameANN1_2_0 = modelANNReg1_2_0.get_operations();
    Tensor inputPCAANNReg1_2_0{modelANNReg1_2_0, operNameANN1_2_0[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_0{modelANNReg1_2_0, operNameANN1_2_0[operNameANN1_2_0.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_1 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_1/1300batch_2385epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_1(frozenPathReg_cluster1_2_1);
    std::vector<std::string> operNameANN1_2_1;
    operNameANN1_2_1 = modelANNReg1_2_1.get_operations();
    Tensor inputPCAANNReg1_2_1{modelANNReg1_2_1, operNameANN1_2_1[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_1{modelANNReg1_2_1, operNameANN1_2_1[operNameANN1_2_1.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_2 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_2/560batch_2045epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_2(frozenPathReg_cluster1_2_2);
    std::vector<std::string> operNameANN1_2_2;
    operNameANN1_2_2 = modelANNReg1_2_2.get_operations();
    Tensor inputPCAANNReg1_2_2{modelANNReg1_2_2, operNameANN1_2_2[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_2{modelANNReg1_2_2, operNameANN1_2_2[operNameANN1_2_2.size()-1]};    //Last tensor = Output (Standardized values)
    
    
    std::string frozenPathReg_cluster1_2_3 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_3/500batch_1436epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_3(frozenPathReg_cluster1_2_3);
    std::vector<std::string> operNameANN1_2_3;
    operNameANN1_2_3 = modelANNReg1_2_3.get_operations();
    Tensor inputPCAANNReg1_2_3{modelANNReg1_2_3, operNameANN1_2_3[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_3{modelANNReg1_2_3, operNameANN1_2_3[operNameANN1_2_3.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_4 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_4/1000batch_3682epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_4(frozenPathReg_cluster1_2_4);
    std::vector<std::string> operNameANN1_2_4;
    operNameANN1_2_4 = modelANNReg1_2_4.get_operations();
    Tensor inputPCAANNReg1_2_4{modelANNReg1_2_4, operNameANN1_2_4[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_4{modelANNReg1_2_4, operNameANN1_2_4[operNameANN1_2_4.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_5 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_5/93batch_651epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_5(frozenPathReg_cluster1_2_5);
    std::vector<std::string> operNameANN1_2_5;
    operNameANN1_2_5 = modelANNReg1_2_5.get_operations();
    Tensor inputPCAANNReg1_2_5{modelANNReg1_2_5, operNameANN1_2_5[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_5{modelANNReg1_2_5, operNameANN1_2_5[operNameANN1_2_5.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_6 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_6/1500batch_1898epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_6(frozenPathReg_cluster1_2_6);
    std::vector<std::string> operNameANN1_2_6;
    operNameANN1_2_6 = modelANNReg1_2_6.get_operations();
    Tensor inputPCAANNReg1_2_6{modelANNReg1_2_6, operNameANN1_2_6[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_6{modelANNReg1_2_6, operNameANN1_2_6[operNameANN1_2_6.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_7 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_7/20batch_1171epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_7(frozenPathReg_cluster1_2_7);
    std::vector<std::string> operNameANN1_2_7;
    operNameANN1_2_7 = modelANNReg1_2_7.get_operations();
    Tensor inputPCAANNReg1_2_7{modelANNReg1_2_7, operNameANN1_2_7[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_7{modelANNReg1_2_7, operNameANN1_2_7[operNameANN1_2_7.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_8 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_8/120batch_1465epochs_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_8(frozenPathReg_cluster1_2_8);
    std::vector<std::string> operNameANN1_2_8;
    operNameANN1_2_8 = modelANNReg1_2_8.get_operations();
    Tensor inputPCAANNReg1_2_8{modelANNReg1_2_8, operNameANN1_2_8[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_8{modelANNReg1_2_8, operNameANN1_2_8[operNameANN1_2_8.size()-1]};    //Last tensor = Output (Standardized values)
    
    std::string frozenPathReg_cluster1_2_9 = "/home/huutri/workdir/ML-DL_ORCh/dataORChCases/CasKaidi/0-6.Ref_DetailedGRI30-AftEMT-AftREACTOR-5000ite/Run1.Kmeans-HierarchicalCluster-2parentClusters_parent0-14child_parent1_3child_20grandChil10grandChilEach/ANNReg_parentCluster1/ANNReg_childCluster1_2/grandChild1_2_9/420batch_2446epoch_WithEarlyStopping200/frozen_bestModel.pb";
    Model modelANNReg1_2_9(frozenPathReg_cluster1_2_9);
    std::vector<std::string> operNameANN1_2_9;
    operNameANN1_2_9 = modelANNReg1_2_9.get_operations();
    Tensor inputPCAANNReg1_2_9{modelANNReg1_2_9, operNameANN1_2_9[0]}; //First tensor = Input (Standardized values)
    Tensor outputStandardizeANNReg1_2_9{modelANNReg1_2_9, operNameANN1_2_9[operNameANN1_2_9.size()-1]};    //Last tensor = Output (Standardized values)
    
 

    // Create the temporary vectors to store the intermediary result of each particle
    //Create vectors to GLOBAL standardize Y T from Y (without N2)  and T of particle >> Kmeans or ANN Classifier
    std::vector<float> input_GlobalStandardized(numVarANN); //Expected 11 type of data : 10Y T
    
    //Create vectors to PARENT LOCAL standardize Y T from Y (without N2)  and T of particle >> Kmeans or ANN Classifier
    std::vector<float> input_parentLocalStandardized(numVarANN); //Expected 11 type of data : 10Y T
    
    //Create vectors to CHILD LOCAL standardize Y T from Y (without N2)  and T of particle >> ANNRegression or Kmeans (parentCluster0)
    std::vector<float> input_childLocalStandardized(numVarANN); //Expected 11 type of data : 10Y T
    
    //Create vectors to PARENT LOCAL standardize Y T from Y (without N2)  and T of particle >> ANNRegression (parentCluster1)
    std::vector<float> input_grandChildLocalStandardized(numVarANN); //Expected 11 type of data : 10Y T
    
    //Create vector to store inputPCA (inputANN in PCA space)
    std::vector<float> inputPCA_Vec(numComponentPCA);
    
    //Create vector to store outputANNStandardize_Vec (outputANN Standardize in composition space)
    std::vector<float> outputStandardizeANN_Vec(numVarANN);
    
    
    // Commun variable to load
    vector<float> child_MeanINPUTLoad = {};
    vector<float> child_StdINPUTLoad = {};
    vector<float> child_MeanOUTPUTLoad = {};
    vector<float> child_StdOUTPUTLoad = {};
    
    vector<float> child_MaxOUTPUTLoad = {}; //Max Variation (output ANN - composition space)
    vector<float> child_MinOUTPUTLoad = {}; //Min Variation (output ANN - composition space)
    
    vector<double> maxAftREACTORLoad = {}; //double because std::min need double
    vector<double> minAftREACTORLoad = {}; // Max/Min Y,T inside a cluster (composition space)
    
    //Create matrices for PCA transform (input & output)
    cv::PCA pcaANN;
    cv::Mat input_childLocalStandardized_Mat; // Mat: Composition space = input of PCA transform
    cv::Mat input_grandChildLocalStandardized_Mat; // Mat: Composition space = input of PCA transform
    cv::Mat inputPCA;	// Mat: LPCA space = output of PCA transform = input of ANN in LPCA space
    
    // To count EMST mixed particles
    int modifEMSTParticle = 0; // To count the number of particle modified by EMST
    
    // GLOBAL Standardize vector
    cv::Mat x;
    
    // Distance to parent Cluster
    double d0 = 0;
    double d1 = 0;
    
    // minLoc for parentCluster
    int indexParentCluster;
    cv::Point minLoc;
    
    // LOCAL PARENT Standardize vector
    cv::Mat xParent;
    
    // minLoc for childCluster
    cv::Point minLocParent;
    int indexChildCluster;
    
    // LOCAL CHILD Standardize vector (childCluster1_0, 1_1, 1_2)
    cv::Mat xChild;
    
    // minLoc for childCluster
    cv::Point minLocChild;
    int indexGrandChildCluster;
    
    // Distance to childCluster
    //parentCluster0
    double d0_0 = 0; // Calculate Euclidean distance from x to cluster 0
    double d0_1 = 0;
    double d0_2 = 0;
    double d0_3 = 0;
    double d0_4 = 0;
    double d0_5 = 0;
    double d0_6 = 0;
    double d0_7 = 0;
    double d0_8 = 0;
    double d0_9 = 0;
    double d0_10 = 0;
    double d0_11 = 0;
    double d0_12 = 0;
    double d0_13 = 0;
    
    //parentCluster1
    double d1_0 = 0; // Calculate Euclidean distance from x to cluster 0
    double d1_1 = 0;
    double d1_2 = 0;
    
    //parentCluster1 - childCluster0
    double d1_0_0 = 0;
    double d1_0_1 = 0;
    double d1_0_2 = 0;
    double d1_0_3 = 0;
    double d1_0_4 = 0;
    double d1_0_5 = 0;
    double d1_0_6 = 0;
    double d1_0_7 = 0;
    double d1_0_8 = 0;
    double d1_0_9 = 0;
    double d1_0_10 = 0;
    double d1_0_11 = 0;
    double d1_0_12 = 0;
    double d1_0_13 = 0;
    double d1_0_14 = 0;
    double d1_0_15 = 0;
    double d1_0_16 = 0;
    double d1_0_17 = 0;
    double d1_0_18 = 0;
    double d1_0_19 = 0;
    double d1_0_20 = 0;
    double d1_0_21 = 0;
    double d1_0_22 = 0;
    double d1_0_23 = 0;
    double d1_0_24 = 0;
    double d1_0_25 = 0;
    double d1_0_26 = 0;
    double d1_0_27 = 0;
    double d1_0_28 = 0;
    double d1_0_29 = 0;
    double d1_0_30 = 0;
    double d1_0_31 = 0;
    double d1_0_32 = 0;
    double d1_0_33 = 0;
    double d1_0_34 = 0;
    double d1_0_35 = 0;
    double d1_0_36 = 0;
    double d1_0_37 = 0;
    double d1_0_38 = 0;
    double d1_0_39 = 0;
    
    //parentCluster1 - childCluster1
    double d1_1_0 = 0;
    double d1_1_1 = 0;
    double d1_1_2 = 0;
    double d1_1_3 = 0;
    double d1_1_4 = 0;
    double d1_1_5 = 0;
    double d1_1_6 = 0;
    double d1_1_7 = 0;
    double d1_1_8 = 0;
    double d1_1_9 = 0;
    double d1_1_10 = 0;
    double d1_1_11 = 0;
    double d1_1_12 = 0;
    double d1_1_13 = 0;
    double d1_1_14 = 0;
    
    //parentCluster1 - childCluster2
    double d1_2_0 = 0;
    double d1_2_1 = 0;
    double d1_2_2 = 0;
    double d1_2_3 = 0;
    double d1_2_4 = 0;
    double d1_2_5 = 0;
    double d1_2_6 = 0;
    double d1_2_7 = 0;
    double d1_2_8 = 0;
    double d1_2_9 = 0;
*/
    // END Declare ANN parametes  ======================
    // =================================================
    
    
    
   /* =============================== */
   /* BEGIN BIG LOOP - Each time step */
   /* =============================== */
   for (int i=0; i<nbLines-1; i++)
   {
    /* ======================================================== */
    /* Read enthalpy CFD file - Huu-Tri NGUYEN - 30 August 2019 */

    int maxRow = 0; // Max row
    int maxCol = 0; // Max column
    vector<double> t_CFD;		// Use vector because it can easily resize
    vector<double> mean_hCFD;
    


    // Path file - Huu-Tri NGUYEN - 2020.01.10
    string dir ="/home/huutri/workdir/orch/Workcases/";
    string Case = "121_EMST_ORChData.FourUmons_NewVersionORChANN20210312_Stochastic_Qx10_NewConditions_outletGB_ANNmodels_SansPerte/"; // Be careful, add / at the end

    string inputCFD = "CFD_results/20190918_h_tau.txt";
    string dirCFDIn = dir + Case + inputCFD;

    string outputCFD ="CFD_results/Output_h_tau_Interpolated.txt";
    string dirCFDOut = dir + Case + outputCFD;

     bool flagCFD = false;		// flagCFD == true, use CFD result correction
     bool flagCFDDeter = false;		// flagCFDDeter == true, use CFD result correction for Deterministic closure
     bool flagCFDStochas = false;	// flagCFDStochas == true, use CFD result correction for Stochastic closure

    // HuuTri@20220107: flagHeatLossStochas == true, use a sink/source term to impose the heat loss (alpha_loss) for Stochastic closure
	// Sink term  = alpha_loss*(T_gas - T_wall)
	// Heat term  = beta_heat*(T_gas - T_wall)
	// The value of alpha_loss, beta_heat also depends on the time step delta_t
	// To calculate enthalpy: It should be multiplied by delta_t: 
		// H_gasAfterLoss = H_gas -  sinkTerm*delta_t =  H_ini - alpha_loss*(T_gas - T_wall)*delta_t
		// H_gasAfterHeated = H_gas -  sourceTerm*delta_t =  H_ini - beta_heat*(T_gas - T_wall)*delta_t
     bool flagHeatLossStochas = true;
     double T_wall = 1600;
     double alpha_loss = 1.5e+05;	//1.5e+05 // 3e+05 //4.5e+05 //1.5e+06 //0.1e+05;
     double beta_heat = 7.5e+05;
     if(flagHeatLossStochas)
     {
	if(rank==0 && i==0)
	{
	cout << "==== Heat loss sink/source term correction ====" << endl;
	cout << "alpha_loss = " << alpha_loss << " | beta_heat = " << beta_heat << " | Twall = " << T_wall << endl;
	}
     }

     if (flagCFD)
     {
	if(rank==0 && i==0) cout << "==== With CFD correction ====" << endl;

//	ifstream enthalpyCFDfile(fullPathCorrectionIn.c_str());	// Using Boost - ifstream need path in form of c_str, not only string

	ifstream enthalpyCFDfile(dirCFDIn.c_str());	// Using string - ifstream need path in form of c_str, not only string

	enthalpyCFDfile.ignore(500,'\n');	// To skip the first line: 500 characters or until getting down

	if(enthalpyCFDfile)
	{
		//Open file succesfully
		string lineFile, temp;
	  	stringstream ss;		// Create a stringstream to store every single string

				
		//Count line & col
		while(getline(enthalpyCFDfile,lineFile))
		{
			maxRow ++;	// Count the line
			
			ss.clear();
			ss << lineFile;	// Get the lineFile to ss (reference)
			while(ss >> temp)	// while ss still exist (temp is a string, ss is an adress)
			{
				maxCol++;	// Count every single string then divide by maxRow to obtain maxCol
			}
	
		}
		maxCol = maxCol/maxRow;		// Number of column  = Number of string / Number of row
//		cout << " row = " << maxRow << endl;
//		cout << " col = " << maxCol << endl;


		// Read the file again from the begining
		enthalpyCFDfile.clear();			//Clear all error flag
		enthalpyCFDfile.seekg(0, enthalpyCFDfile.beg);	//and move the cursor to the begining to read the file again
		enthalpyCFDfile.ignore(500,'\n');		//To skip the first line, cursor moves to second line
		double data[maxRow][maxCol];		// Array to store the data as double
                for(int row = 0; row < maxRow; row++)
               	{
                      for(int col = 0; col < maxCol; col++)
                      {
                          enthalpyCFDfile >> data[row][col];	// Store data
                        //  cout << "i = " << row << " j = " << col << " data = " << data[row][col] <<  endl;
			

		      }
		}

		for(int col = 0; col < maxCol; col++)
		{
			if(col==0)
			{

				for(int row = 0; row < maxRow; row++)
				{
					t_CFD.push_back(data[row][col]); // Get the first column into vector
				//	cout << "t_CFD = " << t_CFD[row] << endl;
				}
			}
			else
			{
				 for(int row = 0; row < maxRow; row++)
                                {
                                        mean_hCFD.push_back(data[row][col]);	// Get the second column into vector
				//	cout << "mean_hCFD = " << mean_hCFD[row] << endl;
                                }
			}
		}

	}
	else
	{
		cout << "ERREUR: Unable to open  enthalpyCFDfile" << endl;
		cout << "Please make sure that the folder CFD_results was created and h_tau.txt exits" << endl;
	}

				
	enthalpyCFDfile.close();
    } // flagCFD bracket
    else // flagCFD = false
    {
	if(rank==0 && i==0) cout << "Without CFD correction" << endl;
    }


/* END Read CFD */
/* ============ */




	double checkMean_Hm; //Huu-Tri NGUYEN 13 Nov 2019
      	//Mean values
      for (int k=0; k<nsp; k++)
         Mean_Ym[k] = 0.0;
      Mean_Hm = 0.0;
      Mean_Tm = 0.0;
      Total_gas_mass = 0.0;
      for (int p=ndil; p<nTot; p++)
      {
         Total_gas_mass += listParticles[p]->m_P_gas_liquid; // m_P_gas_liquid for 1p = 1
         for (int k=0; k<nsp; k++)
            Mean_Ym[k] += (listParticles[p]->m_P_gas_liquid*listParticles[p]->m_Yk_gas[k]);
         Mean_Hm += (listParticles[p]->m_P_gas_liquid*listParticles[p]->m_H_gas);
         Mean_Tm += (listParticles[p]->m_P_gas_liquid*listParticles[p]->m_T_gas);
      }
      for (int k=0; k<nsp; k++)
       Mean_Ym[k] /= Total_gas_mass;
      Mean_Hm /= Total_gas_mass;
      Mean_Tm /= Total_gas_mass;
	
	// Huu-Tri commented - 2020.03.06
	if(rank==0) 
	{
		cout << endl;		
		cout << " Mean_Hm at ite " << i << " = " << Mean_Hm <<endl;
		cout << " Mean_Tm at ite " << i << " = " << Mean_Tm << endl;
	}
	
	/* Save the mean data Stochastic to output file - Huu-Tri NGUYEN - 19 Nov 2019 */
	bool activateMeanData = false;
	if(activateMeanData)
	{
		if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
		{
			if(i==0) cout << "*Mean data saving is activated" << endl;
			// Check if meanDataStochastic.txt file exists at the first step
			// If yes, clear the file content
			if(file_exists("outputs/mean_dataParticle.dat") && i==0)
			{
				cout << " -------------- Warrning --------------" << endl;
				cout << " outputs/mean_dataParticle.dat exists. Clearing file ... " << endl;	
			
				ofstream mean_dataParticle_clear("outputs/mean_dataParticle.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
				mean_dataParticle_clear.close(); //close the file
	
			}		


	
			ofstream mean_dataParticle("outputs/mean_dataParticle.dat",ios::app); //ios::app = append at the end of the file
			if(mean_dataParticle)
			{
				if(i==0)	//First step: Need to write the headline
				{
					// First line
					mean_dataParticle << "#Time(s)	"; 
					for (int k=0; k<nsp; k++)
					{
						mean_dataParticle << "Mean_Ym_" << listSpecies[k]->m_Name << "	";
					}
					mean_dataParticle << "Mean_Hm	";
					mean_dataParticle << "Mean_Tm(K)" << endl;

					// Data from ORCh
					mean_dataParticle << i*delta_t << "	";
	
					for (int k=0; k<nsp; k++)
					{
						mean_dataParticle << Mean_Ym[k] << "	";
					}
					mean_dataParticle << Mean_Hm << "	";
					mean_dataParticle << Mean_Tm << "	" << endl;
				}	
				else
				{		
					// Data from ORCh
					mean_dataParticle << i*delta_t << "	";
					for (int k=0; k<nsp; k++)
					{
						mean_dataParticle << Mean_Ym[k] << "	";
					}
					mean_dataParticle << Mean_Hm << "	";
					mean_dataParticle << Mean_Tm << "	" << endl;
				}
			}
			else
			{	
				cout << "ERROR: Impossible to write mean_dataParticle.dat" << endl;
				cout << "Please check computeMultipleInlet.cpp" << endl;
			}
	
			mean_dataParticle.close();
		} // End if(rank==0)
	} // End if(activateMeanData)
	/* END Save - Huu-Tri NGUYEN - 19 Nov 2019 */


  
	/* ==================== CORRECTION  DETERMINISTIC EQUATIONS ================== */
	/*CFD Enthalpy Correction - Huu-Tri NGUYEN - 30 Aout 2019*/
	/**Commented 13 Nov 2019 to implement the heat loss to STOCHASTIC EQUATIONS**/

    if (flagCFDDeter)	// flagCFD == true, use CFD result correction 
     {
//if(i<7) // Use heat loss Deterministic in  5 time steps to stabilize the first jump 
//{


	/* === Interpolate the data to match with time step of ORCh - Huu-Tri NGUYEN - 5 Sept. 2019 === */
        vector<double> timeORCh;           // Store all the time of ORCh = Iteration * delta_t
        double  mean_hCFDinterpo[nbLines]; // Store the mean CFD enthalpy interpolated - Size = nb of iterations
	double Mean_Hm_ini; // Huu-Tri NGUYEN - 14.01.2020 - Interpolation

	if(i==0)	// Huu-Tri NGUYEN - 14.01.2020
	{ 
		Mean_Hm_ini = Mean_Hm;	// Mean_Hm of iteration t, we are now t+1 because after Stochastic closure
		if(rank ==0) cout << " Mean ini = " << Mean_Hm_ini << endl;
	}


	mean_hCFDinterpo[0] = Mean_Hm_ini;  // No variation between CFD and ORCh >> mean_hCFDinterpo - Mean_Hm = 0

	for(int step = 0; step < nbLines; step++)	
	{
		timeORCh.push_back(step*delta_t); // size of timeORCh vector equals to nbLines (nb of iterations)
	}
	

	// Find Top, Bot position
	for(int step = 1; step < nbLines; step++)	// Start from second value (step = 1), mean_hCFDinterpo[0] = Mean_Hm
        {
		for(int row = 0; row < maxRow-1; row++)	// End before the last number
		{
			if(timeORCh[step] < t_CFD[0]) // Verify if out of range
			{
                       //         mean_hCFDinterpo[step] = Mean_Hm; // Smaller than the first CFD result
									// assume no loss                                        
				double tTop = 0.0;	// tTop < timeORCh < tBot
				double tBot = t_CFD[0];
				double hTop = mean_hCFDinterpo[0];
				double hBot = mean_hCFD[0];


				mean_hCFDinterpo[step] = hTop + ((hBot - hTop)/(tBot-tTop)*(timeORCh[step]-tTop));			


			}
			else if(timeORCh[step] > t_CFD[maxRow-1]) //  Bigger than the last CFD result, take the last value hm
			{

				mean_hCFDinterpo[step] = mean_hCFDinterpo[step-1];
			} 
			else	// In the range of interpolation
			{
				if(timeORCh[step] > t_CFD[row+1])	// Find the cursor position
				{	
					// Do not thing >> Move to next row
				}
				else if(timeORCh[step] == t_CFD[row])
				{	
					mean_hCFDinterpo[step] = mean_hCFD[row];
				}	
				else if(timeORCh[step] > t_CFD[row] && timeORCh[step] < t_CFD[row+1]) // Interpolate
				{
					double tTop = t_CFD[row];	// tTop < timeORCh < tBot
					double tBot = t_CFD[row+1];
					double hTop = mean_hCFD[row];
					double hBot = mean_hCFD[row+1];
					mean_hCFDinterpo[step] = hTop + ((hBot - hTop)/(tBot-tTop)*(timeORCh[step]-tTop));
				}		
			}
			 	
		}
	} 
	

	// Save the interpolated result to output 1
	ofstream mean_hCFD_interpolated(dirCFDOut.c_str());	// Using string - ifstream need path in form of c_str, not only string


	if(mean_hCFD_interpolated)
	{
		mean_hCFD_interpolated << "#Time(s)	"; 
		mean_hCFD_interpolated << "h_mean_interpolated(J/kg)" << endl;

		for(int step = 0; step < nbLines; step++)
		{
			mean_hCFD_interpolated << timeORCh[step] << "	";
			mean_hCFD_interpolated << mean_hCFDinterpo[step] << endl;
		}
	}
	else
	{
		cout << "ERROR: Unable to write h_tau_Interpolated.txt" << endl;
		cout << "Please check computeMultipleInlet.cpp" << endl;
	}

	mean_hCFD_interpolated.close();


	/* =================================== END Interpolate =================================== */
	

	if(timeORCh[i] == i*delta_t)	// i =nbIteration, timeORCh = i*delta_t >> Check if interpolation is OK
	{	
		
		Mean_Hm = Mean_Hm + (mean_hCFDinterpo[i] - Mean_Hm);	// Add the enthalpy variation
		if(rank ==0)
		{		
			cout << "Correction Deterministic at " << i*delta_t << "s || " << endl;
			cout << "Mean correction = " << Mean_Hm << endl;
		}		
		 cout << "Mean Hm after = " << Mean_Hm << endl;
	}
	else
	{
		cout << "Something is wrong with interpolation - check computeMultipleInlet.cpp" <<  endl;
	}	
// } //if(i<5)  bracket

   } // flagCFD bracket

	/* ================== END CORRECTION ================= */

     // store << t << "  ";
     // for (int k=0; k<nsp; k++)
     //    store << Mean_Ym[k] << "  ";
     // store << Mean_Tm << "  ";
     // store << endl;



     //richesse
     double phi[nTot];
	

  // =========== SCATTERPLOT ===========
     // In this section, there are 2 formulas in order to calculate Mixture fraction Z for each particle (Z_gas and Zn2)
     // Z_gas is based on the Bilger formula (atoms C,H,O - default in ORCh) but only for 1 fuel
     // Zn2 is based on N2 evolution (No reaction of NOx and  - by Huu-Tri NGUYEN - 07.01.2020
     // Zn2_Deter for the mixing Deterministic will be calculated after the correction (Find Stochastic correction)
     bool activateScatter = false;	//flag to activate Scatterplot (write data_particles.dat)
     if(activateScatter)
     {
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{
		if(i==0) cout << "*Scatterplot is activated" << endl;
		// Check if meanSpeciesProdRate.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/scatterplot_data.dat") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/scatterplot_data.dat exists. Clearing file ... " << endl;	
			
			ofstream store_particles_clear("outputs/scatterplot_data.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			store_particles_clear.close(); //close the file
	
		}		


		ofstream store_particles("outputs/scatterplot_data.dat",ios::app); //ios::app = append at the end of the file
		if(store_particles)
		{
			if(i==0)	// write the first line
			{  
				store_particles << "#1:time  2:Particle_number  3:Zfraction  4:T(K) 5:Y_CO2 6:Y_O2 7:particle type  8:ratio  9:Zst	10:Zc	11:Zo	12:Zh 13:Zn2	14:hp" << endl;
			}	

      			for (int z=ndil;z<nTot; z++)
      			{
      				double Yf, Yo, Yf_0, Yo2_0, s, Yco2, Ych4, Yco, Yh2o;
				
      				Yf_0 = 1; 
      				Yo2_0 = 0.232917;

				// Huu-Tri NGUYEN - 07.01.2020 - Calculate Z (mixture fraction) by N2
				double Yn2, Yn2_0, Yn2_f,Zn2;
				Zn2 = 0;
				Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
				Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
      
      				for (int k=0; k<nsp; k++)
      				{
         				if (mixture->speciesName(k) == "NC10H22")
            					Yf = listParticles[z]->m_Yk_gas[k]; 
         				if (mixture->speciesName(k) == "O2")
            					Yo = listParticles[z]->m_Yk_gas[k]; 
         				if (mixture->speciesName(k) == "CO2")
            					Yco2 = listParticles[z]->m_Yk_gas[k]; 
         				if (mixture->speciesName(k) == "CH4")
            					Ych4 = listParticles[z]->m_Yk_gas[k]; 
         				if (mixture->speciesName(k) == "H2O")
            					Yh2o = listParticles[z]->m_Yk_gas[k]; 
         				if (mixture->speciesName(k) == "CO")
            					Yco = listParticles[z]->m_Yk_gas[k]; 
         				if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
            					Yn2 = listParticles[z]->m_Yk_gas[k];
				}      
       
				Zn2 = (Yn2-Yn2_0)/(Yn2_f-Yn2_0); //Huu-Tri NGUYEN - 07.01.2020: Mixture fraction based on N2
									// Zst_n2 is calculated in Excel file of case conditions

      				//mass stoichiometric coefficient
      				double W_NC10H22 = 142; // kg/kmol
      				double W_O2 = 32; // kg/kmol
      				double W_CH4 = 16;
      				double W_CO = 28;
      				double W_CO2 = 44;
      				double W_H2O = 18;
      				double W_C = 12;
      				double W_O = 16;
      				double W_H = 1;  
				double W_H2 = 2;	// Huu-Tri Nguyen - 16.01.2020
				double W_N2 = 28;  	// Huu-Tri Nguyen - 16.01.2020
 
      				int m = 6;	//22
      				int n = 2;     //10
      				int nuO = n + m/4;

      				double Zc = 0;
      				double Zo = 0;
      				double Zh = 0;

				double Y[nsp];
				for (int f=0;f<nsp;f++)
   					Y[f] = listParticles[z]->m_Yk_gas[f];


      				//Species mixture fraction - Bilger formula 
				// Zc = (No_atomsC_inSpecie * Weight_of_C * Y_species) / Weight_of_specie)
      				for (int k=0;k<nsp;k++)
      				{
         				if (listSpecies[k]->m_C != 0)
            					Zc += listSpecies[k]->m_C*W_C*Y[k]/( listSpecies[k]->m_C*W_C +  listSpecies[k]->m_H*W_H + listSpecies[k]->m_O*W_O);
         				if (listSpecies[k]->m_O != 0)
         					Zo += listSpecies[k]->m_O*W_O*Y[k]/( listSpecies[k]->m_C*W_C +  listSpecies[k]->m_H*W_H +  listSpecies[k]->m_O*W_O);
         				if (listSpecies[k]->m_H != 0)
         					Zh += listSpecies[k]->m_H*W_H*Y[k]/( listSpecies[k]->m_C*W_C +  listSpecies[k]->m_H*W_H +  listSpecies[k]->m_O*W_O);
      				}				


     				//Species mixture fraction 
     				double Zc0 = n*W_C*Yf_0/(n*W_C + m*W_H);
     				double Zh0 = m*W_H*Yf_0/(n*W_C + m*W_H);
     				double Zo0 = 2*Yo2_0*W_O/(W_O2);



      				//Calcul de la fraction de mélange locale Z
      				listParticles[z]->m_Z_gas = (Zc/(n*W_C) + Zh/(m*W_H) + 2*(Yo2_0 - Zo)/(nuO*W_O2))/(Zc0/(n*W_C) + Zh0/(m*W_H)+ 2*Yo2_0/(nuO*W_O2));


				//Huu-Tri NGUYEN - check 
				//if(rank == 0)
				//	cout << " Particle " << z << " !!! delta = " << listParticles[z]->m_Z_gas-Zn2 << endl;

      				//Calcul de Zst
      				double Zst = (2*Yo2_0/(nuO*W_O2))/(Zc0/(n*W_C) + Zh0/(m*W_H)+ 2*Yo2_0/(nuO*W_O2));

      				//Calcul de la richesse locale
      				phi[z] =   listParticles[z]->m_Z_gas * (1 - Zst) / (Zst * (1 - listParticles[z]->m_Z_gas));

      				double particleType;
      				if (z < nbParticles[0])
         				particleType = 0;
      				else if (z > nbParticles[0]-1 && z < nbParticles[0] + nbParticles[1])
         				particleType = 1;
      				else if (z >= nbParticles[0] + nbParticles[1])
         				particleType = 2;
     

				// Store the result in data_particles.dat  
				store_particles << t << "  ";
      				store_particles << z+1 << "  ";
      				store_particles << listParticles[z]->m_Z_gas << "  ";
      				store_particles << listParticles[z]->m_T_gas  << "  ";
      				store_particles << Yf  << "  ";
      				store_particles << Yo  << "  ";
     				store_particles << particleType  << "  ";
     				store_particles << phi[z] << "  ";
	     			store_particles << Zst << "  ";    
	     			store_particles << Zc << "  ";    
     				store_particles << Zo << "  ";    
     				store_particles << Zh << "  ";  
  				store_particles << Zn2 << "  ";		//Huu-Tri NGUYEN - 07.01.2020
  				store_particles << listParticles[z]->m_H_gas << "  ";//Huu-Tri NGUYEN - 15.01.2020 - Enthalpy de particule
     				store_particles << endl; 
			
		

      			} //end of scatterplot part
		}
    		store_particles.close(); //store_particles for scatterplot

	
	// Huu-Tri Nguyen - Print enthalpy evolution of each inlet - 15.01.2020

	// Calculate Zn2 Deterministic
		double Yn2_0, Yn2_f;
		double Yn2_Deter0 = 0, Yn2_Deter1 = 0, Yn2_Deter2 = 0, Yn2_DeterMix = 0;;
		double Zn2_Deter0 = 0, Zn2_Deter1 = 0, Zn2_Deter2 = 0, Zn2_DeterMix = 0;
		Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
		Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
	    
		for (int k=0; k<nsp; k++)
		{	
			
			if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
			{
				Yn2_DeterMix = Ym[k];
       		     		Yn2_Deter0 = Ym_Trajectories_store[0][i][k];
				Yn2_Deter1 = Ym_Trajectories_store[1][i][k];
			//	Yn2_Deter2 = Ym_Trajectories_store[2][i][k];	// Huu-Tri Commented - 2 inlets - 20.01.2020

			}
		}
			   
		Zn2_DeterMix = (Yn2_DeterMix-Yn2_0)/(Yn2_f-Yn2_0);
		Zn2_Deter0 = (Yn2_Deter0-Yn2_0)/(Yn2_f-Yn2_0);
		Zn2_Deter1 = (Yn2_Deter1-Yn2_0)/(Yn2_f-Yn2_0);
		Zn2_Deter2 = (Yn2_Deter2-Yn2_0)/(Yn2_f-Yn2_0);






		// Calculate enthalpy mix of inlets - UMONS case - Huu-Tri Nguyen 15.01.2020
		double h_gas = Hm_Trajectories[0];
		double h_air = Hm_Trajectories[1];
		double h_mixZ_Deter;
			h_mixZ_Deter = h_gas*Zn2_DeterMix + h_air*(1-Zn2_DeterMix);	// In the case of 2 inlets adidabatic
		double h_burntGas = Hm_Trajectories[2];


	
		if(file_exists("outputs/scatterplot_dataHDeter.dat") && i==0)
		{
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/scatterplot_dataHDeter.dat exists. Clearing file ... " << endl;	
				
			ofstream dataEnthalpy_clear("outputs/scatterplot_dataHDeter.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			dataEnthalpy_clear.close(); //close the file
		} //end if(file_exists)		

		ofstream dataEnthalpy("outputs/scatterplot_dataHDeter.dat",ios::app); //ios::app = append at the end of the file
		if(dataEnthalpy)
		{
			if(i==0)	// write the first line
			{  
				dataEnthalpy << "#1:time	2:h_gas	3:h_air	4:h_GB	5:h_mixZ_Deter	6:Zn2_Mix	7:Zn2_gas	8:Zn2_air	9:Zn2_GB" << endl;
				dataEnthalpy << i << "	";
				dataEnthalpy << h_gas << "	";
				dataEnthalpy << h_air << "	";
				dataEnthalpy << h_burntGas << "	";
				dataEnthalpy << h_mixZ_Deter << "	";
				dataEnthalpy << Zn2_DeterMix << "	";
				dataEnthalpy << Zn2_Deter0 << "	";
				dataEnthalpy << Zn2_Deter1 << "	";
				dataEnthalpy << Zn2_Deter2 << "	";
				dataEnthalpy << endl;
			
			}
			else
			{
				dataEnthalpy << i << "	";
				dataEnthalpy << h_gas << "	";
				dataEnthalpy << h_air << "	";
				dataEnthalpy << h_burntGas << "	";
				dataEnthalpy << h_mixZ_Deter << "	";
				dataEnthalpy << Zn2_DeterMix << "	";
				dataEnthalpy << Zn2_Deter0 << "	";
				dataEnthalpy << Zn2_Deter1 << "	";
				dataEnthalpy << Zn2_Deter2 << "	";
				dataEnthalpy << endl;
			}
	
		} //end if(dataEnthalpy)	
		dataEnthalpy.close();
	} // end if(rank==0)	
    } //end if(activeScatter)	

     // =========== END SCATTERPLOT ===========	



     //store.close(); // for mean values >> already made a new file mean_dataParticle.txt- Huu-Tri Nguyen - 10.12.2019


     // =========== FULL DATA PARTICLES - Huu-Tri Nguyen 19.12.2019===========
     // Store Temperature & Mass fraction for each particle at each time step - Huu-Tri Nguyen 10.12.2019
     bool activateFullData = true;	//flag to activate Full data (write full_dataParticle.dat)
     if(activateFullData)
     {
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{
		if(i==0) 
			cout << "*Full data saving is activated" << endl;
		// Check if meanSpeciesProdRate.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/full_dataParticle.dat") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/full_dataParticle.dat exists. Clearing file ... " << endl;	
			
			ofstream full_dataParticle_clear("outputs/full_dataParticle.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			full_dataParticle_clear.close(); //close the file
	
		}	
		
		ofstream full_dataParticle("outputs/full_dataParticle.dat",ios::app); //ios::app = append at the end of the file
		if(full_dataParticle)
		{
			if(i==0)
			{
   				ofstream full_dataParticle ("outputs/full_dataParticle.dat"); 
   				full_dataParticle << "#Time	";
				full_dataParticle << "Particle_number	";
   				for (int k=0; k<nsp; k++)
      					full_dataParticle << mixture->speciesName(k) << "	";
				full_dataParticle << "Hm	";	//HT@2020.08.22 : Need to remove
				full_dataParticle << "Temperature	" << endl;

				for(int p=0; p<nTot; p++)
				{
     					full_dataParticle << t << "	";
     					full_dataParticle << p << "	";	// Particle starts from 1
     					for (int k=0; k<nsp; k++)
        					full_dataParticle << listParticles[p]->m_Yk_gas[k] << "	";
					full_dataParticle << listParticles[p]->m_H_gas << "	";	//HT2020.08.22 : Need to remove
					full_dataParticle << listParticles[p]->m_T_gas << "	" << endl;
				}
			}
			else
			{
				for(int p=0; p<nTot; p++)
				{
     					full_dataParticle << t << "	";
     					full_dataParticle << p << "	";	// Particle starts from 1
     					for (int k=0; k<nsp; k++)
        					full_dataParticle << listParticles[p]->m_Yk_gas[k] << "	";
                                        full_dataParticle << listParticles[p]->m_H_gas << "	";      //HT2020.08.22 : Need to remove
					full_dataParticle << listParticles[p]->m_T_gas << "	" << endl;
				}	
			}
		}

		full_dataParticle.close(); //close the file
	} //END if(rank==0)

     } //END if(activateFullData)
     // =========== END FULL DATA PARTICLES ===========

      // ====== LAGRANGIAN TRAJECTORIES - DETERMINISTIC ====== //	
      for (int n=0; n<nbInlets-1; n++)
      {
         for (int k=0; k<nsp; k++)
            Ym[k] = (Ym_Trajectories_store[n][i][k]-Mean_Ym[k])*exp(-(delta_t/(2*tau_t)))+Mean_Ym[k];

         
	
         Hm = (Hm_Trajectories[n]-Mean_Hm)*exp(-(delta_t/(2*tau_t)))+Mean_Hm;

         if (step == "DRGEP_Species" || step == "DRGEP_Reactions")
         {
            Next_Time_Step_with_drgep(mech, mech_desc, Targets, Pressure, Ym, Hm, Tm, delta_t, R_AD_Trajectories[n], max_j_on_Target, step, n, t);
         }
         else if (step == "computeQSSCriteria")
         {
            Next_Time_Step(mech, mech_desc, Pressure, Ym, Hm, Tm, delta_t, Production_Trajectories_ref, Consumption_Trajectories_ref, n, i);
         }
         else
         {

            Next_Time_Step(mech, mech_desc, Pressure, Ym, Hm, Tm, delta_t);
             
             // Huu-Tri TEST - 20210206
            if(rank==0)
            {
                cout << " **** Advance Deterministic inlet " << n << " at " << i << " iterations" << endl;
            }
         }

	// Huu-Tri - After the reactor
         for (int k=0; k<nsp; k++)
            Ym_Trajectories_store[n][i+1][k] = (Ym[k]-Mean_Ym[k])*exp(-(delta_t/(2*tau_t)))+Mean_Ym[k];


         Hm_Trajectories[n] = (Hm-Mean_Hm)*exp(-(delta_t/(2*tau_t)))+Mean_Hm;
         T_Trajectories_store[n][i+1] = Tm;

      } // End "for" each inlet
      // ====== END LAGRANGIAN TRAJECTORIES - DETERMINISTIC ====== //



	//  Huu-Tri NGUYEN - Calculate source term Deterministic - 5 Dec 2019 
	//  1st step: Create the 2D array
	bool calculWDeter = false;
	if(calculWDeter)
	{
		double *wDeter_T = new double[nbInlets-1];
		double **wDeter_species  = new double*[nbInlets-1];	// 2D array ** with first dimension (number of inlets)
		for (int n=0; n<nbInlets-1; n++)	// Create second dimension 
		{
			wDeter_species[n] = new double[nsp];	// nsp = number of species has declared above
		}

		// 2nd step: Calculate source term
		for (int n=0; n<nbInlets-1; n++)
      		{	wDeter_T[n] = T_Trajectories_store[n][i+1] - T_Trajectories_store[n][i];
			wDeter_T[n] /= delta_t;

        		for (int k=0; k<nsp; k++)
			{
				wDeter_species[n][k] = (Ym_Trajectories_store[n][i+1][k] - Ym_Trajectories_store[n][i][k]);
				wDeter_species[n][k] /= delta_t;	
			}
		}
	
		// 3rd step: Save to file
		SaveToFile_wDeter(wDeter_T, wDeter_species, nsp, nbInlets, i, delta_t, listSpecies, rank);

	
		// Free w_species memory (array pointer should be deleted after use)		 
		delete wDeter_T;
		for (int n=0; n<nbInlets-1; n++)	// Create second dimension 
		{
			delete[] wDeter_species[n];
		}
		delete[] wDeter_species;
	} //End if(calculWDeter)	
	//  End Calculate source term deterministic - 5 Dec 2019
	

      //---Particles mixing---
      //
      //Add Nmix variation if dilution
     int Nmix2;
      if (i < nbLines/2)
	Nmix2 = delta_t*(nTot-AirPart+1)/tau_t;
      else 
         {
        
         float c = i;
         float d = nbLines;
         double b = abs(AirPart*(1 - ( 2*( c - d/2 )/d)));
         int a = b;
         Nmix2 = delta_t*(nTot - a)/tau_t;
         }

       /* ======== MIXING MODELS ======== */
       /* 2 options: Curl model or EMST model */
	bool activateCurl = false;	//true = Curl; false = EMST

	//Huu-Tri@20200922 : Save Y, T of particle before EMST to check  if EMST change particle - ANN
	double saveEMSTbefore[nTot][nsp];	
         for (int p=0; p<nTot; p++) //Copy mass fraction of each particle into saveEMSTbefore array
         {
            	for (int k=0; k<nsp; k++)
            	{
			saveEMSTbefore[p][k] = listParticles[p]->m_Yk_gas[k];	// Already checked cout 

            	}
         } 




	 /* CURL Mixing closure phi_p1 = phi_p2 = (phi_p1 + phi_p2)/2 */
	if(activateCurl)
	{
		if(rank ==0) cout << "Curl mixing model" << endl;
     	
      		for (int p=0; p<Nmix; p++)
      		{
          		double run_mixing = true;

          		if (run_mixing)
         		{
 	    		// Huu-Tri: Only gas case,  gas_mass_p1 = gas_mass_p2 = 0.01 = Particle_flowRate
            			gas_mass_p1 = listParticles[Particle_1[i][p]]->m_P_gas_liquid*Particle_flowRate;
             			gas_mass_p2 = listParticles[Particle_2[i][p]]->m_P_gas_liquid*Particle_flowRate; 

             			if (gas_mass_p1+gas_mass_p2 > 0.0)
           			{
                			for (int k=0; k<nsp; k++)
                			{
                   				listParticles[Particle_1[i][p]]->m_Yk_gas[k] = F*(gas_mass_p1*listParticles[Particle_1[i][p]]->m_Yk_gas[k]+gas_mass_p2*listParticles[Particle_2[i][p]]->m_Yk_gas[k])/(gas_mass_p1+gas_mass_p2);
                   				listParticles[Particle_2[i][p]]->m_Yk_gas[k] = listParticles[Particle_1[i][p]]->m_Yk_gas[k];
                			}

      		 				listParticles[Particle_1[i][p]]->m_H_gas = (gas_mass_p1*listParticles[Particle_1[i][p]]->m_H_gas+gas_mass_p2*listParticles[Particle_2[i][p]]->m_H_gas)/(gas_mass_p1+gas_mass_p2);//Original

               
//  Huu-Tri NGUYEN - Add a modified enthaply for heat loss
//                listParticles[Particle_1[i][p]]->m_H_gas = (gas_mass_p1*listParticles[Particle_1[i][p]]->m_H_gas+gas_mass_p2*listParticles[Particle_2[i][p]]->m_H_gas)/(gas_mass_p1+gas_mass_p2) + varEnthalpyCFD;// Huu-Tri Stochastic heat loss 14 Nov 2019 


						listParticles[Particle_2[i][p]]->m_H_gas = listParticles[Particle_1[i][p]]->m_H_gas;
	

             			}
         		}
       		}
	}

      /* END Commented Curl model to add EMST model - Huu-Tri Nguyen -10.12.2019 */
	else // EMST model
	{
		if(rank ==0) 
		{
			cout << "EMST mixing model" << endl;
		}
		/* Add EMST model - Huu-Tri Nguyen -10.12.2019 */
     		//EMST mixing model -- by Kaidi@2019.12
      		double run_mixing = true;

     		if (run_mixing==true)
      		{
         		mode_emst = 2;	// 2 -mixing is performed and the state variables are incremented.

         		i_emst = 0;
         		for (int ic=0; ic<nc_emst; ic++)
         		{
            			for (int ip=0; ip<np_emst; ip++)
            			{
               				if (ic<nsp)  
						f_emst[i_emst] = listParticles[ip]->m_Yk_gas[ic];
               				else         
						f_emst[i_emst] = listParticles[ip]->m_H_gas;
               			i_emst++;
            			}
         		}
    
		// Mixing with EMST model
		bool byPassEMST = false; // By pass EMST to use only ANN - HuuTri@20200919
		if (byPassEMST == false)
		{
			if(rank==0 & i==0) {
                                cout << " Use EMST - Not by pass " << endl;
                        }
			emst_(&mode_emst,&np_emst,&nc_emst,f_emst,state_emst,wt_emst,&omdt_emst,fscale_emst,cvars_emst,&info_emst);
			
			int EMST_mixedParticles =0;			
			for (int ip=0; ip<np_emst; ip++) //HuuTri@20201029: Print number of mixed particles
  			{
				if(state_emst[ip] >0)
				{
      					EMST_mixedParticles++; // Particle mixed state_emst>0, non-mixed state_emst<0
				}
      				// wt_emst[ip];
   			}
			if(rank==0)
			{ 
				cout << "Mixed particles = " << EMST_mixedParticles << endl;
			}        	
		}
		else
		{
			if(rank==0 & i==0) {
				cout << " By pass EMST for ANN !!!! " << endl;
			}
		}
			if (info_emst != 0)
         		{
            			cout << "emst failed" << endl;
            			getchar();
         		}

         		i_emst = 0;


         		for (int ic=0; ic<nc_emst; ic++)
         		{
            			for (int ip=0; ip<np_emst; ip++)
            			{
               				if (ic<nsp)
               				{
                  				listParticles[ip]->m_Yk_gas[ic] = f_emst[i_emst];
                  				//listParticles[ip]->m_Yk_gas[ic] = listParticles[ip]->m_Yk_gas[ic] * (((rand() / double(RAND_MAX))*2.0-1.0)*1.0/100.0 + 1.0);
               				}
               				else
               				{
                  				listParticles[ip]->m_H_gas = f_emst[i_emst];
                  				//T_o = 353;
                  				//if (listParticles[ip]->m_T_gas > T_o) listParticles[ip]->m_H_gas = listParticles[ip]->m_H_gas * (((rand() / double(RAND_MAX))*2.0-1.0)*1.0/100.0 + 1.0);
                  				//if (i > nbLines/3)
						//Heatloss Camille - Commented by Huu-Tri Nguyen -10.12.2019
				                  			
//HT						if (true)
//HT                  				{
//HT                    				T_o = 353; 
//HT                     				if (listParticles[ip]->m_T_gas > T_o) 
//HT							listParticles[ip]->m_H_gas = listParticles[ip]->m_H_gas - K*alpha_loss*(listParticles[ip]->m_T_gas - T_o)*delta_t;
//HT              				}


						// Heatloss Camille - Corrected by Huu-Tri Nguyen - 20220107
    						// HuuTri@20220107: flagHeatLossStochas == true, use a sink/source term to impose the heat loss (alpha_loss) for Stochastic closure
						// Sink term  = alpha_loss*(T_gas - T_wall)
						// Heat term  = beta_heat*(T_gas - T_wall)
						// The value of alpha_loss, beta_heat also depends on the time step delta_t
						// To calculate enthalpy: It should be multiplied by delta_t: 
						// H_gasAfterLoss = H_gas -  sinkTerm*delta_t =  H_ini - alpha_loss*(T_gas - T_wall)*delta_t
						// H_gasAfterHeated = H_gas -  sourceTerm*delta_t =  H_ini - beta_heat*(T_gas - T_wall)*delta_t
						if (flagHeatLossStochas)
						{
							// HuuTri@20220107: alpha_loss and T_wall should be declared above (find "flagHeatLossStochas" keyword)
							// HuuTri@20220107: If Tgas > Twall, the heat will be lost >> alpha_loss
							if (listParticles[ip]->m_T_gas > T_wall)
							{
								listParticles[ip]->m_H_gas = listParticles[ip]->m_H_gas - alpha_loss*(listParticles[ip]->m_T_gas - T_wall)*delta_t;	
							}
							else // When Tgas < Twall, the gas is heated by walls
							{
								listParticles[ip]->m_H_gas = listParticles[ip]->m_H_gas - beta_heat*(listParticles[ip]->m_T_gas - T_wall)*delta_t;
							}


						} // end if (flagHeatLossStochas)
              				}
               				i_emst++;
            			}
         		}
    	
		}
	} // End else EMST model
      // End of EMST mixing model

	/* END Add EMST model - Huu-Tri Nguyen -10.12.2019 */

	



	// ===== SCATTERPLOT Particle 2 - AFTER the correction Enthalpy - Huu-Tri Nguyen - 16.01.2020 
    if(activateScatter)
    {
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{

		if(file_exists("outputs/scatterplot_dataAfterCorrection.dat") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/scatterplot_dataAfterCorrection.dat exists. Clearing file ... " << endl;	
			
			ofstream store_particlesAfter_clear("outputs/scatterplot_dataAfterCorrection.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			store_particlesAfter_clear.close(); //close the file

		}		

		ofstream store_particlesAfter("outputs/scatterplot_dataAfterCorrection.dat",ios::app); //ios::app = append at the end of the file
		if(store_particlesAfter)
		{
			if(i==0)	// write the first line
			{  
				store_particlesAfter << "#1:time  2:Particle_number  3:particle type  4:Zn2	5:hp" << endl;
			}	
		
      			for (int z=ndil;z<nTot; z++)
      			{

				// Huu-Tri NGUYEN - 07.01.2020 - Calculate Z (mixture fraction) by N2
				double Yn2, Yn2_0, Yn2_f,Zn2;
				Zn2 = 0;
				Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
				Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
      
      				for (int k=0; k<nsp; k++)
      				{
         			 
         				if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
            						Yn2 = listParticles[z]->m_Yk_gas[k];
				}      
       
				Zn2 = (Yn2-Yn2_0)/(Yn2_f-Yn2_0); //Huu-Tri NGUYEN - 07.01.2020: Mixture fraction based on N2
									// Zst_n2 is calculated in Excel file of case conditions

      				

      				double particleType;
      				if (z < nbParticles[0])
         				particleType = 0;
      				else if (z > nbParticles[0]-1 && z < nbParticles[0] + nbParticles[1])
         				particleType = 1;
      				else if (z >= nbParticles[0] + nbParticles[1])
         				particleType = 2;
     

				// Store the result in data_particles.dat  
				store_particlesAfter << t << "  ";
      				store_particlesAfter << z+1 << "  ";
     				store_particlesAfter << particleType  << "  "; 
  				store_particlesAfter << Zn2 << "  ";		//Huu-Tri NGUYEN - 07.01.2020
  				store_particlesAfter << listParticles[z]->m_H_gas << "  ";//Huu-Tri NGUYEN - 15.01.2020 - Enthalpy de particule
     				store_particlesAfter << endl; 
			
		
      			} //end of scatterplot part
		}
    		store_particlesAfter.close(); //store_particlesAfter for scatterplot after the correction
		
	} //End(rank==0)
    }// End if(activateScatter)



     //Evaporation
      for (int p=ndil; p<nTot; p++)
      {
         if (listParticles[p]->m_P_gas_liquid < 1.0)
         {
            double Diameter;
            if ((t+dt)/tau_vj < 1)
               Diameter = Diameter_init*pow((1-((t+dt)/tau_vj)),0.5);
            else
               Diameter = 0.0;

            double old_Diameter = listParticles[p]->m_droplets_diameter;
            listParticles[p]->m_droplets_diameter = Diameter;

            double gas_mass = listParticles[p]->m_P_gas_liquid*Particle_flowRate;
            double liquid_mass = (1-listParticles[p]->m_P_gas_liquid)*Particle_flowRate;
            double ReleasedVapor = listParticles[p]->m_N_droplets*listParticles[p]->m_density_liquid*(PI/6)*(pow(old_Diameter,3)-pow(Diameter,3));
            listParticles[p]->m_P_gas_liquid = (gas_mass+ReleasedVapor)/Particle_flowRate;

            for (int k=0; k<nsp; k++)
            {
               double Yk_gas_init = listParticles[p]->m_Yk_gas[k];
               listParticles[p]->m_Yk_gas[k] = ((gas_mass*Yk_gas_init)+(ReleasedVapor*listParticles[p]->m_Yk_liquid[k]))/(gas_mass+ReleasedVapor);
            }

            double H_gas_init = listParticles[p]->m_H_gas;
            double ReleasedEnthalpy = 0.0;
            for (int k=0; k<nsp; k++)
            {
               ReleasedEnthalpy += ReleasedVapor*listParticles[p]->m_Yk_liquid[k]*(BoilingEnthalpy[k]-listParticles[p]->m_EvaporationLatentHeat);
            }
            listParticles[p]->m_H_gas = ((gas_mass*H_gas_init)+(ReleasedEnthalpy))/(gas_mass+ReleasedVapor);
         }


      }


    // Calculate right hand-side of Y(=mixing + source term) and T (=source term) - Huu-Tri NGUYEN - 2019.12.05
    bool activateSourceTermParticle = false;
	// Initialization
	double *Tm_gas_before = new double[nTot];	// 1D array temperature for each particle
	double **Yk_gas_before  = new double*[nTot];	// 2D array ** with first dimension (number of particles)
	for (int p=0; p<nTot; p++)	// Create second dimension 
	{
		Yk_gas_before[p] = new double[nsp];	// nsp = number of species has declared above
	}


	for (int p=ndil; p<nTot; p++)
      	{

		Tm_gas_before[p] = listParticles[p]->m_T_gas;		

 		for (int k=0; k<nsp; k++)
        	{
              	 	Yk_gas_before[p][k] = listParticles[p]->m_Yk_gas[k];
		}	
	}
   // End Calculate right hand-side of Y(=mixing + source term) and T (=source term) - Huu-Tri NGUYEN - 2019.12.05

     // =========== FULL DATA PARTICLES  After EMST - Huu-Tri Nguyen 17.09.2020===========
     // Store Temperature & Mass fraction for each particle at each time step BUT AFTER EMST- Huu-Tri Nguyen 17.09.2020
     // Move from 1205 to Here
     // ORCh : dY/dt = EMST then this one then dY/dt = wdot
     bool activateFullDataAftEMST = true;	//flag to activate Full data (write full_dataParticle.dat)
     if(activateFullDataAftEMST)
     {
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{
		cout << "Save after EMST" << endl;
		if(i==0) 
			cout << "*Full data AFTER EMST saving is activated" << endl;
		// Check if meanSpeciesProdRate.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/full_dataParticleAftEMST.dat") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/full_dataParticleAftEMST.dat exists. Clearing file ... " << endl;	
			
			ofstream full_dataParticle_clear("outputs/full_dataParticleAftEMST.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			full_dataParticle_clear.close(); //close the file
	
		}	
		
		ofstream full_dataParticle("outputs/full_dataParticleAftEMST.dat",ios::app); //ios::app = append at the end of the file
		if(full_dataParticle)
		{
			if(i==0)
			{
   				ofstream full_dataParticle ("outputs/full_dataParticleAftEMST.dat"); 
   				full_dataParticle << "#Time	";
				full_dataParticle << "Particle_number	";
   				for (int k=0; k<nsp; k++)
      					full_dataParticle << mixture->speciesName(k) << "	";
				full_dataParticle << "Hm	";	//HT@2020.08.22 : Need to remove
				full_dataParticle << "Temperature	" << endl;

				for(int p=0; p<nTot; p++)
				{
     					full_dataParticle << t << "	";
     					full_dataParticle << p << "	";	// Particle starts from 1
     					for (int k=0; k<nsp; k++)
        					full_dataParticle << listParticles[p]->m_Yk_gas[k] << "	";
					full_dataParticle << listParticles[p]->m_H_gas << "	";	//HT2020.08.22 : Need to remove
					full_dataParticle << listParticles[p]->m_T_gas << "	" << endl;
				}
			}
			else
			{
				for(int p=0; p<nTot; p++)
				{
     					full_dataParticle << t << "	";
     					full_dataParticle << p << "	";	// Particle starts from 1
     					for (int k=0; k<nsp; k++)
        					full_dataParticle << listParticles[p]->m_Yk_gas[k] << "	";
                                        full_dataParticle << listParticles[p]->m_H_gas << "	";      //HT2020.08.22 : Need to remove
					full_dataParticle << listParticles[p]->m_T_gas << "	" << endl;
				}	
			}
		}

		full_dataParticle.close(); //close the file
	} //END if(rank==0)

     } //END if(activateFullDataAftEMST)
     // =========== END FULL DATA PARTICLES AFTER EMST ===========


    // Huu-Tri@20200724 : Load model with a path to the .pb file. (Using cppflow)
    bool flagANN = false;

/* flagANN 3/4
     bool activateIndexCluster = false;	//flag to activate Full data (write full_dataParticle.dat)
     if(flagANN && activateIndexCluster && i==0)
     {
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{
		cout << "*indexClusterFile saving is activated" << endl;
		// Check if meanSpeciesProdRate.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/indexClusterFile.dat"))
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << "outputs/indexClusterFile.dat exists. Clearing file ... " << endl;	
			
			ofstream indexClusterFile_clear("outputs/indexClusterFile.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			indexClusterFile_clear.close(); //close the file
	
		}	
		
		ofstream indexClusterFile("outputs/indexCluster.dat",ios::app); //ios::app = append at the end of the file
		if(indexClusterFile)
		{ 
   			indexClusterFile << "#Time	";
			indexClusterFile << "Particle_number	";
            indexClusterFile << "parentCluster	";
            indexClusterFile << "childCluster	";
			indexClusterFile << "grandChildCluster" << endl;
            
		}
        indexClusterFile.close();
	} //END if(rank==0)
     } //ENd  if(activateIndexCluster) 

    //if(i>0) // Mix first step
    //{
	//flagANN = true;
    //}
    if (flagANN == true) //Initialization
    {

	// The SavedModel format (a folder) should be frozen to a single .pb file
	// Tensorflow v2 : https://leimao.github.io/blog/Save-Load-Inference-From-TF2-Frozen-Graph/ 
		
	// Collecte the maximum values of Y H T on entire full_dataParticle to normalize
		// Copy these vectors from ORCh_ANN_train.ipynb
		// ATTENTION : Must change these vectors when using another model (delta_t and conditions are differents between each case)
		// Species order is the same as ORCh_ANN_train and also the reduced scheme: Have to check !!!!
	
    //Declare parameters above before LOOP i
        
        // Create kRun
        int kRun=0;
        
        
     // BEGIN the loop for all particles
        for (int p=0; p<nTot; p++)
        {
            
            if(state_emst[p]>0) // EMST mixed particles count
            {
                modifEMSTParticle++;
            }
          
        // GLOBAL Standardize Y ,T: standardizedX = (X - meanScale) / standardDeviationScale
            // Standardize T
            input_GlobalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - GLOBAL_meanScale[numVarANN-1];
            input_GlobalStandardized[numVarANN-1] /= GLOBAL_stdScale[numVarANN-1];
            // Standardize Y
            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
            {
                input_GlobalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - GLOBAL_meanScale[kANN];
                input_GlobalStandardized[kANN] /= GLOBAL_stdScale[kANN];
                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
            }

        // CLASSIFIER GLOBAL: Caculate the distance : Eucledian (Kmeans) or Projection parition (LPCA)
            // >> Determine indexParentCluster
            // LPCA example: cv::Mat d0 = (x-r0).t() * eigenVec0.t() * eigenVec0 * (x-r0);
            // Eucledean: Can be calculated by std::vector
            
            // Declare vector x
            x = cv::Mat(numVarANN, 1, CV_32F, input_GlobalStandardized.data());
            d0 = cv::norm(x,r0,cv::NORM_L2); // Calculate Euclidean distance from x to cluster 0
            d1 = cv::norm(x,r1,cv::NORM_L2);
            // Group distance to d
            cv::Mat d;
            d.push_back(d0);
            d.push_back(d1);
            // Take position of mean (argmin) = indexParentCluster
            cv::minMaxLoc(d, NULL, NULL, &minLoc, NULL); // d, minVal, maxVal, minLoc, maxLoc
            indexParentCluster = minLoc.y; //Point has 2 coordinates (x,y)
            
            if(indexParentCluster==0) //parentCluster0 - 14 child clusters
            {

                // LOCAL PARENT Standardize Y ,T for Kmeans LOCAL PARENT: standardizedX = (X - meanScale) / standardDeviationScale
                    // Standardize T
                input_parentLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - parentCluster0_meanScaleINPUT[numVarANN-1];
                input_parentLocalStandardized[numVarANN-1] /= parentCluster0_stdScaleINPUT[numVarANN-1];
                    // Standardize Y
                for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                {
                    input_parentLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - parentCluster0_meanScaleINPUT[kANN];
                    input_parentLocalStandardized[kANN] /= parentCluster0_stdScaleINPUT[kANN];
                    //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                    if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                }
                
                // CLASSIFIER LOCAL PARENT: Caculate the distance : Eucledian (Kmeans) or Projection parition (LPCA)
                    // >> Determine indexChildCluster
                    // LPCA example: cv::Mat d0 = (x-r0).t() * eigenVec0.t() * eigenVec0 * (x-r0);
                    // Eucledean: Can be calculated by std::vector
                
                    // Declare vector x
                xParent = cv::Mat(numVarANN, 1, CV_32F, input_parentLocalStandardized.data());
                d0_0 = cv::norm(xParent,r0_0,cv::NORM_L2); // Calculate Euclidean distance from x to cluster 0
                d0_1 = cv::norm(xParent,r0_1,cv::NORM_L2);
                d0_2 = cv::norm(xParent,r0_2,cv::NORM_L2);
                d0_3 = cv::norm(xParent,r0_3,cv::NORM_L2);
                d0_4 = cv::norm(xParent,r0_4,cv::NORM_L2);
                d0_5 = cv::norm(xParent,r0_5,cv::NORM_L2);
                d0_6 = cv::norm(xParent,r0_6,cv::NORM_L2);
                d0_7 = cv::norm(xParent,r0_7,cv::NORM_L2);
                d0_8 = cv::norm(xParent,r0_8,cv::NORM_L2);
                d0_9 = cv::norm(xParent,r0_9,cv::NORM_L2);
                d0_10 = cv::norm(xParent,r0_10,cv::NORM_L2);
                d0_11 = cv::norm(xParent,r0_11,cv::NORM_L2);
                d0_12 = cv::norm(xParent,r0_12,cv::NORM_L2);
                d0_13 = cv::norm(xParent,r0_13,cv::NORM_L2);
                // Group distance to d
                cv::Mat dParent;
                dParent.push_back(d0_0);
                dParent.push_back(d0_1);
                dParent.push_back(d0_2);
                dParent.push_back(d0_3);
                dParent.push_back(d0_4);
                dParent.push_back(d0_5);
                dParent.push_back(d0_6);
                dParent.push_back(d0_7);
                dParent.push_back(d0_8);
                dParent.push_back(d0_9);
                dParent.push_back(d0_10);
                dParent.push_back(d0_11);
                dParent.push_back(d0_12);
                dParent.push_back(d0_13);
                    // Take position of mean (argmin) = indexParentCluster
                cv::minMaxLoc(dParent, NULL, NULL, &minLocParent, NULL); // d, minVal, maxVal, minLoc, maxLoc
                indexChildCluster = minLocParent.y; //Point has 2 coordinates (x,y)

                if(rank==0) // Print to check
                {
                    cout << "Particles " << p << " || parentCluster = " << indexParentCluster << " || childCluster = " << indexChildCluster << " ";
                }
                
                // Save indexCluster of this particle
                if(activateIndexCluster)
                {
                    if(rank==0)
                    {
                        ofstream indexClusterFile("outputs/indexCluster.dat",ios::app); //ios::app = append at the end of the file
                        indexClusterFile << t << "	";
                        indexClusterFile << p << "	";
                        indexClusterFile << indexParentCluster <<  "	";
                        indexClusterFile << indexChildCluster <<  "	";
                        indexClusterFile << "" << endl; // parentCluster0 has not grand child
                        indexClusterFile.close();
                    }
                }

 
                
                switch(indexChildCluster) //parentCluster0
                {
                    // Cluster 0_0
                    case 0:
                        if(rank==0)
                        {
                            cout << " Case0_0"<<  endl;
                        }
                        
                        advanceANN(cluster0_0_meanScaleINPUT, cluster0_0_stdScaleINPUT,
                                   cluster0_0_meanScaleOUTPUT, cluster0_0_stdScaleOUTPUT,
                                   cluster0_0_maxOUTPUT, cluster0_0_minOUTPUT,
                                   child0_0_maxVal, child0_0_minVal,
                                   pcaANN0_0,
                                   inputPCAANNReg0_0, modelANNReg0_0, outputStandardizeANNReg0_0,
                                   listParticles[p]->m_T_gas, listParticles[p]->m_Yk_gas,
                                   numVarANN, nsp,
                                   input_childLocalStandardized, input_childLocalStandardized_Mat,
                                   inputPCA, inputPCA_Vec,
                                   outputStandardizeANN_Vec,
                                   listSpecies);
                        break;
                        
                        
                    // Cluster 0_1
                    case 1:
                        if(rank==0)
                        {
                            cout << " Case0_1"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_1_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_1_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_1_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_1_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_1_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_1_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_1_maxVal;
                        minAftREACTORLoad = child0_1_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_1;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_1.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_1.run(inputPCAANNReg0_1,outputStandardizeANNReg0_1);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_1.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_2
                    case 2:
                        if(rank==0)
                        {
                            cout << " Case0_2"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_2_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_2_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_2_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_2_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_2_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_2_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_2_maxVal;
                        minAftREACTORLoad = child0_2_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_2;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_2.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_2.run(inputPCAANNReg0_2,outputStandardizeANNReg0_2);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_2.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_3
                    case 3:
                        if(rank==0)
                        {
                            cout << " Case0_3"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_3_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_3_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_3_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_3_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_3_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_3_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_3_maxVal;
                        minAftREACTORLoad = child0_3_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_3;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_3.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_3.run(inputPCAANNReg0_3,outputStandardizeANNReg0_3);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_3.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;

                    // Cluster 0_4
                    case 4:
                        if(rank==0)
                        {
                            cout << " Case0_4"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_4_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_4_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_4_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_4_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_4_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_4_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_4_maxVal;
                        minAftREACTORLoad = child0_4_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_4;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_4.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_4.run(inputPCAANNReg0_4,outputStandardizeANNReg0_4);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_4.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_5
                    case 5:
                        if(rank==0)
                        {
                            cout << " Case0_5"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_5_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_5_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_5_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_5_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_5_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_5_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_5_maxVal;
                        minAftREACTORLoad = child0_5_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_5;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_5.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_5.run(inputPCAANNReg0_5,outputStandardizeANNReg0_5);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_5.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_6
                    case 6:
                        if(rank==0)
                        {
                            cout << " Case0_6"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_6_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_6_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_6_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_6_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_6_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_6_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_6_maxVal;
                        minAftREACTORLoad = child0_6_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_6;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_6.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_6.run(inputPCAANNReg0_6,outputStandardizeANNReg0_6);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_6.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_7
                    case 7:
                        if(rank==0)
                        {
                            cout << " Case0_7"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_7_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_7_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_7_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_7_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_7_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_7_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_7_maxVal;
                        minAftREACTORLoad = child0_7_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_7;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_7.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_7.run(inputPCAANNReg0_7,outputStandardizeANNReg0_7);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_7.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_8
                    case 8:
                        if(rank==0)
                        {
                            cout << " Case0_8"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_8_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_8_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_8_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_8_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_8_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_8_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_8_maxVal;
                        minAftREACTORLoad = child0_8_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_8;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_8.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_8.run(inputPCAANNReg0_8,outputStandardizeANNReg0_8);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_8.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_9
                    case 9:
                        if(rank==0)
                        {
                            cout << " Case0_9"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_9_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_9_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_9_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_9_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_9_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_9_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_9_maxVal;
                        minAftREACTORLoad = child0_9_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_9;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_9.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_9.run(inputPCAANNReg0_9,outputStandardizeANNReg0_9);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_9.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_10
                    case 10:
                        if(rank==0)
                        {
                            cout << " Case0_10"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_10_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_10_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_10_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_10_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_10_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_10_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_10_maxVal;
                        minAftREACTORLoad = child0_10_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_10;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_10.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_10.run(inputPCAANNReg0_10,outputStandardizeANNReg0_10);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_10.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_11
                    case 11:
                        if(rank==0)
                        {
                            cout << " Case0_11"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_11_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_11_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_11_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_11_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_11_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_11_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_11_maxVal;
                        minAftREACTORLoad = child0_11_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_11;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_11.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_11.run(inputPCAANNReg0_11,outputStandardizeANNReg0_11);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_11.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                    // Cluster 0_12
                    case 12:
                        if(rank==0)
                        {
                            cout << " Case0_12"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_12_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_12_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_12_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_12_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_12_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_12_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_12_maxVal;
                        minAftREACTORLoad = child0_12_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_12;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_12.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_12.run(inputPCAANNReg0_12,outputStandardizeANNReg0_12);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_12.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                        
                        // Cluster 0_13
                    case 13:
                        if(rank==0)
                        {
                            cout << " Case0_13"<<  endl;
                        }
                        // Load INPUT & OUTPUT CHILD Scaler
                        child_MeanINPUTLoad = cluster0_13_meanScaleINPUT;
                        child_StdINPUTLoad = cluster0_13_stdScaleINPUT;
                        child_MeanOUTPUTLoad = cluster0_13_meanScaleOUTPUT;
                        child_StdOUTPUTLoad = cluster0_13_stdScaleOUTPUT;
                        
                        // Load Max & Min OUTPUT (Composition space)
                        child_MaxOUTPUTLoad = cluster0_13_maxOUTPUT;
                        child_MinOUTPUTLoad = cluster0_13_minOUTPUT;
                        
                        // Load maxAftREACTOR & minAftREACTOR
                        //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                        maxAftREACTORLoad = child0_13_maxVal;
                        minAftREACTORLoad = child0_13_minVal;
                        
                        // Child PCA
                        pcaANN = pcaANN0_13;
                        
                        // LOCAL INPUT Standardize
                        // Standardize T
                        input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                        input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                        // Standardize Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                            input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                        }
                        
                        
                        // PCA Transform
                        // Load to matrix
                        input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                        // Project to LPCA space: inputPCA = input of ANN in LPCA space
                        pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                        // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                        if (inputPCA.isContinuous()) // Continuous memory block
                        {
                            inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                        } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                        
                        
                        // ANN regression to predict Standardized variation
                        // Set input tensor for cppflow (Tensorflow)
                        inputPCAANNReg0_13.set_data(inputPCA_Vec);
                        // Predict the  Standardized variation - saved as outputANN tensor
                        modelANNReg0_13.run(inputPCAANNReg0_13,outputStandardizeANNReg0_13);
                        // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                        kRun=0;
                        for (float f : outputStandardizeANNReg0_13.get_data<float>())
                        {
                            outputStandardizeANN_Vec[kRun] = f;
                            kRun++;
                        }
                        
                        // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                        //  X = standardizedX*standardDeviationScale + meanScale
                        // T
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                        outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                        // Verify if output (Composition space) out-of-bound
                        outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                        outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                        // Calculate Temperature and bound on Max Min GLOBAL data
                        listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                        listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                        
                        //  Y
                        for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                        {
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                            outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                            outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                            // Calculate Y and bound on Max Min GLOBAL data
                            listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                            listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                            //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                            if(listSpecies[kANN]->m_Name == "N2")
                                cout << "Warning : N2 in the ANN!!!" << endl;
                        }
                        break;
                } //END switch(indexChildCluster) parentCluster0
                
                // Release OPENCV MAT
                dParent.release();
            } // END parentCluster0
            
            else //parentCluster1
            {
                // LOCAL PARENT Standardize Y ,T for Kmeans LOCAL PARENT: standardizedX = (X - meanScale) / standardDeviationScale
                // Standardize T
                input_parentLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - parentCluster1_meanScaleINPUT[numVarANN-1];
                input_parentLocalStandardized[numVarANN-1] /= parentCluster1_stdScaleINPUT[numVarANN-1];
                // Standardize Y
                for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                {
                    input_parentLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - parentCluster1_meanScaleINPUT[kANN];
                    input_parentLocalStandardized[kANN] /= parentCluster1_stdScaleINPUT[kANN];
                    //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                    if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                }
                
                // CLASSIFIER LOCAL PARENT: Caculate the distance : Eucledian (Kmeans) or Projection parition (LPCA)
                // >> Determine indexChildCluster
                // LPCA example: cv::Mat d0 = (x-r0).t() * eigenVec0.t() * eigenVec0 * (x-r0);
                // Eucledean: Can be calculated by std::vector
                
                // Declare vector x
                xParent = cv::Mat(numVarANN, 1, CV_32F, input_parentLocalStandardized.data());
                d1_0 = cv::norm(xParent,r1_0,cv::NORM_L2); // Calculate Euclidean distance from x to cluster 0
                d1_1 = cv::norm(xParent,r1_1,cv::NORM_L2);
                d1_2 = cv::norm(xParent,r1_2,cv::NORM_L2);


                // Group distance to d
                cv::Mat dParent;
                dParent.push_back(d1_0);
                dParent.push_back(d1_1);
                dParent.push_back(d1_2);
                
                // Take position of mean (argmin) = indexParentCluster
                cv::minMaxLoc(dParent, NULL, NULL, &minLocParent, NULL); // d, minVal, maxVal, minLoc, maxLoc
                indexChildCluster = minLocParent.y; //Point has 2 coordinates (x,y)
                
                
                if(indexChildCluster==0) // childCluster 1_0
                {
                    // Classifier grand child
                    // LOCAL CHILD Standardize Y ,T for Kmeans LOCAL CHILD: standardizedX = (X - meanScale) / standardDeviationScale
                    // Standardize T
                    input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - cluster1_0_meanScaleINPUT[numVarANN-1];
                    input_childLocalStandardized[numVarANN-1] /= cluster1_0_stdScaleINPUT[numVarANN-1];
                    // Standardize Y
                    for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                    {
                        input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - cluster1_0_meanScaleINPUT[kANN];
                        input_childLocalStandardized[kANN] /= cluster1_0_stdScaleINPUT[kANN];
                        //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                        if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                    }

                    
                    // CLASSIFIER LOCAL CHILD: Caculate the distance : Eucledian (Kmeans) or Projection parition (LPCA)
                    // >> Determine indexGrandChildCluster
                    // LPCA example: cv::Mat d0 = (x-r0).t() * eigenVec0.t() * eigenVec0 * (x-r0);
                    // Eucledean: Can be calculated by std::vector
                    
                    // Declare vector x
                    xChild = cv::Mat(numVarANN, 1, CV_32F, input_childLocalStandardized.data());
                    d1_0_0 = cv::norm(xChild,r1_0_0,cv::NORM_L2); // Calculate Euclidean distance from x to cluster 0
                    d1_0_1 = cv::norm(xChild,r1_0_1,cv::NORM_L2);
                    d1_0_2 = cv::norm(xChild,r1_0_2,cv::NORM_L2);
                    d1_0_3 = cv::norm(xChild,r1_0_3,cv::NORM_L2);
                    d1_0_4 = cv::norm(xChild,r1_0_4,cv::NORM_L2);
                    d1_0_5 = cv::norm(xChild,r1_0_5,cv::NORM_L2);
                    d1_0_6 = cv::norm(xChild,r1_0_6,cv::NORM_L2);
                    d1_0_7 = cv::norm(xChild,r1_0_7,cv::NORM_L2);
                    d1_0_8 = cv::norm(xChild,r1_0_8,cv::NORM_L2);
                    d1_0_9 = cv::norm(xChild,r1_0_9,cv::NORM_L2);
                    d1_0_10 = cv::norm(xChild,r1_0_10,cv::NORM_L2);
                    d1_0_11 = cv::norm(xChild,r1_0_11,cv::NORM_L2);
                    d1_0_12 = cv::norm(xChild,r1_0_12,cv::NORM_L2);
                    d1_0_13 = cv::norm(xChild,r1_0_13,cv::NORM_L2);
                    d1_0_14 = cv::norm(xChild,r1_0_14,cv::NORM_L2);
                    d1_0_15 = cv::norm(xChild,r1_0_15,cv::NORM_L2);
                    d1_0_16 = cv::norm(xChild,r1_0_16,cv::NORM_L2);
                    d1_0_17 = cv::norm(xChild,r1_0_17,cv::NORM_L2);
                    d1_0_18 = cv::norm(xChild,r1_0_18,cv::NORM_L2);
                    d1_0_19 = cv::norm(xChild,r1_0_19,cv::NORM_L2);
                    d1_0_20 = cv::norm(xChild,r1_0_20,cv::NORM_L2);
                    d1_0_21 = cv::norm(xChild,r1_0_21,cv::NORM_L2);
                    d1_0_22 = cv::norm(xChild,r1_0_22,cv::NORM_L2);
                    d1_0_23 = cv::norm(xChild,r1_0_23,cv::NORM_L2);
                    d1_0_24 = cv::norm(xChild,r1_0_24,cv::NORM_L2);
                    d1_0_25 = cv::norm(xChild,r1_0_25,cv::NORM_L2);
                    d1_0_26 = cv::norm(xChild,r1_0_26,cv::NORM_L2);
                    d1_0_27 = cv::norm(xChild,r1_0_27,cv::NORM_L2);
                    d1_0_28 = cv::norm(xChild,r1_0_28,cv::NORM_L2);
                    d1_0_29 = cv::norm(xChild,r1_0_29,cv::NORM_L2);
                
                    // Group distance to d
                    cv::Mat dChild;
                    dChild.push_back(d1_0_0);
                    dChild.push_back(d1_0_1);
                    dChild.push_back(d1_0_2);
                    dChild.push_back(d1_0_3);
                    dChild.push_back(d1_0_4);
                    dChild.push_back(d1_0_5);
                    dChild.push_back(d1_0_6);
                    dChild.push_back(d1_0_7);
                    dChild.push_back(d1_0_8);
                    dChild.push_back(d1_0_9);
                    dChild.push_back(d1_0_10);
                    dChild.push_back(d1_0_11);
                    dChild.push_back(d1_0_12);
                    dChild.push_back(d1_0_13);
                    dChild.push_back(d1_0_14);
                    dChild.push_back(d1_0_15);
                    dChild.push_back(d1_0_16);
                    dChild.push_back(d1_0_17);
                    dChild.push_back(d1_0_18);
                    dChild.push_back(d1_0_19);
                    dChild.push_back(d1_0_20);
                    dChild.push_back(d1_0_21);
                    dChild.push_back(d1_0_22);
                    dChild.push_back(d1_0_23);
                    dChild.push_back(d1_0_24);
                    dChild.push_back(d1_0_25);
                    dChild.push_back(d1_0_26);
                    dChild.push_back(d1_0_27);
                    dChild.push_back(d1_0_28);
                    dChild.push_back(d1_0_29);
                    
                    // Take position of mean (argmin) = indexParentCluster
                    cv::minMaxLoc(dChild, NULL, NULL, &minLocChild, NULL); // d, minVal, maxVal, minLoc, maxLoc
                    indexGrandChildCluster = minLocChild.y; //Point has 2 coordinates (x,y)
                    
                    if(rank==0) // Print to check
                    {
                        cout << "Particles " << p << " || parentCluster = " << indexParentCluster;
                        cout << " || childCluster = " << indexChildCluster << " || grandChildCluster = " << indexGrandChildCluster << " ";
                    }
                    
                    // Save indexCluster of this particle
                    if(activateIndexCluster)
                    {
                        if(rank==0)
                        {
                            ofstream indexClusterFile("outputs/indexCluster.dat",ios::app); //ios::app = append at the end of the file
                            indexClusterFile << t << "	";
                            indexClusterFile << p << "	";
                            indexClusterFile << indexParentCluster <<  "	";
                            indexClusterFile << indexChildCluster <<  "	";
                            indexClusterFile << indexGrandChildCluster << endl;
                            indexClusterFile.close();
                        }
                    }
                    
                    switch(indexGrandChildCluster) // cluster1_0_X
                    {
                        // Cluster 1_0_0
                        case 0:
                            if(rank==0)
                            {
                                cout << " Case1_0_0"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_0_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_0_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_0_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_0_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_0_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_0_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_0_maxVal;
                            minAftREACTORLoad = grandChild1_0_0_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_0;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_0.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_0.run(inputPCAANNReg1_0_0,outputStandardizeANNReg1_0_0);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_0.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_0_1
                        case 1:
                            if(rank==0)
                            {
                                cout << " Case1_0_1"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_1_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_1_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_1_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_1_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_1_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_1_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_1_maxVal;
                            minAftREACTORLoad = grandChild1_0_1_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_1;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_1.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_1.run(inputPCAANNReg1_0_1,outputStandardizeANNReg1_0_1);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_1.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_0_2
                        case 2:
                            if(rank==0)
                            {
                                cout << " Case1_0_2"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_2_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_2_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_2_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_2_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_2_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_2_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_2_maxVal;
                            minAftREACTORLoad = grandChild1_0_2_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_2;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_2.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_2.run(inputPCAANNReg1_0_2,outputStandardizeANNReg1_0_2);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_2.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_0_3
                        case 3:
                            if(rank==0)
                            {
                                cout << " Case1_0_3"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_3_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_3_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_3_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_3_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_3_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_3_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_3_maxVal;
                            minAftREACTORLoad = grandChild1_0_3_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_3;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_3.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_3.run(inputPCAANNReg1_0_3,outputStandardizeANNReg1_0_3);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_3.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_0_4
                        case 4:
                            if(rank==0)
                            {
                                cout << " Case1_0_4"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_4_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_4_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_4_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_4_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_4_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_4_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_4_maxVal;
                            minAftREACTORLoad = grandChild1_0_4_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_4;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_4.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_4.run(inputPCAANNReg1_0_4,outputStandardizeANNReg1_0_4);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_4.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_5
                        case 5:
                            if(rank==0)
                            {
                                cout << " Case1_0_5"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_5_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_5_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_5_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_5_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_5_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_5_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_5_maxVal;
                            minAftREACTORLoad = grandChild1_0_5_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_5;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_5.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_5.run(inputPCAANNReg1_0_5,outputStandardizeANNReg1_0_5);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_5.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_6
                        case 6:
                            if(rank==0)
                            {
                                cout << " Case1_0_6"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_6_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_6_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_6_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_6_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_6_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_6_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_6_maxVal;
                            minAftREACTORLoad = grandChild1_0_6_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_6;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_6.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_6.run(inputPCAANNReg1_0_6,outputStandardizeANNReg1_0_6);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_6.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_7
                        case 7:
                            if(rank==0)
                            {
                                cout << " Case1_0_7"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_7_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_7_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_7_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_7_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_7_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_7_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_7_maxVal;
                            minAftREACTORLoad = grandChild1_0_7_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_7;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_7.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_7.run(inputPCAANNReg1_0_7,outputStandardizeANNReg1_0_7);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_7.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_8
                        case 8:
                            if(rank==0)
                            {
                                cout << " Case1_0_8"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_8_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_8_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_8_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_8_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_8_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_8_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_8_maxVal;
                            minAftREACTORLoad = grandChild1_0_8_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_8;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_8.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_8.run(inputPCAANNReg1_0_8,outputStandardizeANNReg1_0_8);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_8.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_9
                        case 9:
                            if(rank==0)
                            {
                                cout << " Case1_0_9"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_9_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_9_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_9_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_9_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_9_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_9_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_9_maxVal;
                            minAftREACTORLoad = grandChild1_0_9_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_9;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_9.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_9.run(inputPCAANNReg1_0_9,outputStandardizeANNReg1_0_9);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_9.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_10
                        case 10:
                            if(rank==0)
                            {
                                cout << " Case1_0_10"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_10_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_10_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_10_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_10_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_10_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_10_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_10_maxVal;
                            minAftREACTORLoad = grandChild1_0_10_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_10;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_10.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_10.run(inputPCAANNReg1_0_10,outputStandardizeANNReg1_0_10);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_10.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_11
                        case 11:
                            if(rank==0)
                            {
                                cout << " Case1_0_11"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_11_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_11_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_11_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_11_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_11_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_11_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_11_maxVal;
                            minAftREACTORLoad = grandChild1_0_11_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_11;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_11.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_11.run(inputPCAANNReg1_0_11,outputStandardizeANNReg1_0_11);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_11.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_12
                        case 12:
                            if(rank==0)
                            {
                                cout << " Case1_0_12"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_12_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_12_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_12_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_12_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_12_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_12_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_12_maxVal;
                            minAftREACTORLoad = grandChild1_0_12_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_12;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_12.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_12.run(inputPCAANNReg1_0_12,outputStandardizeANNReg1_0_12);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_12.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_13
                        case 13:
                            if(rank==0)
                            {
                                cout << " Case1_0_13"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_13_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_13_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_13_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_13_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_13_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_13_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_13_maxVal;
                            minAftREACTORLoad = grandChild1_0_13_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_13;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_13.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_13.run(inputPCAANNReg1_0_13,outputStandardizeANNReg1_0_13);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_13.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_14
                        case 14:
                            if(rank==0)
                            {
                                cout << " Case1_0_14"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_14_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_14_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_14_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_14_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_14_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_14_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_14_maxVal;
                            minAftREACTORLoad = grandChild1_0_14_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_14;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_14.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_14.run(inputPCAANNReg1_0_14,outputStandardizeANNReg1_0_14);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_14.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_15
                        case 15:
                            if(rank==0)
                            {
                                cout << " Case1_0_15"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_15_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_15_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_15_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_15_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_15_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_15_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_15_maxVal;
                            minAftREACTORLoad = grandChild1_0_15_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_15;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_15.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_15.run(inputPCAANNReg1_0_15,outputStandardizeANNReg1_0_15);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_15.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_16
                        case 16:
                            if(rank==0)
                            {
                                cout << " Case1_0_16"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_16_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_16_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_16_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_16_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_16_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_16_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_16_maxVal;
                            minAftREACTORLoad = grandChild1_0_16_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_16;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_16.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_16.run(inputPCAANNReg1_0_16,outputStandardizeANNReg1_0_16);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_16.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_17
                        case 17:
                            if(rank==0)
                            {
                                cout << " Case1_0_17"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_17_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_17_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_17_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_17_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_17_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_17_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_17_maxVal;
                            minAftREACTORLoad = grandChild1_0_17_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_17;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_17.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_17.run(inputPCAANNReg1_0_17,outputStandardizeANNReg1_0_17);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_17.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_18
                        case 18:
                            if(rank==0)
                            {
                                cout << " Case1_0_18"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_18_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_18_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_18_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_18_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_18_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_18_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_18_maxVal;
                            minAftREACTORLoad = grandChild1_0_18_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_18;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_18.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_18.run(inputPCAANNReg1_0_18,outputStandardizeANNReg1_0_18);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_18.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_19
                        case 19:
                            if(rank==0)
                            {
                                cout << " Case1_0_19"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_19_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_19_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_19_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_19_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_19_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_19_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_19_maxVal;
                            minAftREACTORLoad = grandChild1_0_19_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_19;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_19.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_19.run(inputPCAANNReg1_0_19,outputStandardizeANNReg1_0_19);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_19.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_20
                        case 20:
                            if(rank==0)
                            {
                                cout << " Case1_0_20"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_20_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_20_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_20_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_20_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_20_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_20_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_20_maxVal;
                            minAftREACTORLoad = grandChild1_0_20_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_20;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_20.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_20.run(inputPCAANNReg1_0_20,outputStandardizeANNReg1_0_20);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_20.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_21
                        case 21:
                            if(rank==0)
                            {
                                cout << " Case1_0_21"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_21_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_21_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_21_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_21_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_21_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_21_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_21_maxVal;
                            minAftREACTORLoad = grandChild1_0_21_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_21;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_21.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_21.run(inputPCAANNReg1_0_21,outputStandardizeANNReg1_0_21);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_21.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_22
                        case 22:
                            if(rank==0)
                            {
                                cout << " Case1_0_22"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_22_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_22_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_22_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_22_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_22_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_22_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_22_maxVal;
                            minAftREACTORLoad = grandChild1_0_22_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_22;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_22.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_22.run(inputPCAANNReg1_0_22,outputStandardizeANNReg1_0_22);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_22.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_23
                        case 23:
                            if(rank==0)
                            {
                                cout << " Case1_0_23"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_23_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_23_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_23_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_23_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_23_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_23_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_23_maxVal;
                            minAftREACTORLoad = grandChild1_0_23_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_23;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_23.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_23.run(inputPCAANNReg1_0_23,outputStandardizeANNReg1_0_23);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_23.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_24
                        case 24:
                            if(rank==0)
                            {
                                cout << " Case1_0_24"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_24_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_24_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_24_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_24_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_24_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_24_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_24_maxVal;
                            minAftREACTORLoad = grandChild1_0_24_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_24;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_24.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_24.run(inputPCAANNReg1_0_24,outputStandardizeANNReg1_0_24);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_24.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_25
                        case 25:
                            if(rank==0)
                            {
                                cout << " Case1_0_25"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_25_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_25_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_25_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_25_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_25_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_25_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_25_maxVal;
                            minAftREACTORLoad = grandChild1_0_25_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_25;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_25.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_25.run(inputPCAANNReg1_0_25,outputStandardizeANNReg1_0_25);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_25.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_26
                        case 26:
                            if(rank==0)
                            {
                                cout << " Case1_0_26"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_26_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_26_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_26_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_26_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_26_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_26_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_26_maxVal;
                            minAftREACTORLoad = grandChild1_0_26_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_26;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_26.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_26.run(inputPCAANNReg1_0_26,outputStandardizeANNReg1_0_26);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_26.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_27
                        case 27:
                            if(rank==0)
                            {
                                cout << " Case1_0_27"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_27_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_27_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_27_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_27_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_27_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_27_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_27_maxVal;
                            minAftREACTORLoad = grandChild1_0_27_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_27;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_27.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_27.run(inputPCAANNReg1_0_27,outputStandardizeANNReg1_0_27);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_27.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_28
                        case 28:
                            if(rank==0)
                            {
                                cout << " Case1_0_28"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_28_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_28_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_28_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_28_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_28_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_28_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_28_maxVal;
                            minAftREACTORLoad = grandChild1_0_28_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_28;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_28.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_28.run(inputPCAANNReg1_0_28,outputStandardizeANNReg1_0_28);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_28.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_29
                        case 29:
                            if(rank==0)
                            {
                                cout << " Case1_0_29"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_29_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_29_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_29_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_29_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_29_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_29_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_29_maxVal;
                            minAftREACTORLoad = grandChild1_0_29_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_29;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_29.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_29.run(inputPCAANNReg1_0_29,outputStandardizeANNReg1_0_29);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_29.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_30
                        case 30:
                            if(rank==0)
                            {
                                cout << " Case1_0_30"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_30_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_30_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_30_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_30_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_30_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_30_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_30_maxVal;
                            minAftREACTORLoad = grandChild1_0_30_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_30;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_30.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_30.run(inputPCAANNReg1_0_30,outputStandardizeANNReg1_0_30);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_30.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_31
                        case 31:
                            if(rank==0)
                            {
                                cout << " Case1_0_31"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_31_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_31_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_31_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_31_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_31_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_31_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_31_maxVal;
                            minAftREACTORLoad = grandChild1_0_31_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_31;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_31.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_31.run(inputPCAANNReg1_0_31,outputStandardizeANNReg1_0_31);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_31.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_32
                        case 32:
                            if(rank==0)
                            {
                                cout << " Case1_0_32"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_32_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_32_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_32_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_32_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_32_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_32_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_32_maxVal;
                            minAftREACTORLoad = grandChild1_0_32_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_32;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_32.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_32.run(inputPCAANNReg1_0_32,outputStandardizeANNReg1_0_32);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_32.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_33
                        case 33:
                            if(rank==0)
                            {
                                cout << " Case1_0_33"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_33_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_33_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_33_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_33_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_33_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_33_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_33_maxVal;
                            minAftREACTORLoad = grandChild1_0_33_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_33;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_33.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_33.run(inputPCAANNReg1_0_33,outputStandardizeANNReg1_0_33);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_33.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_34
                        case 34:
                            if(rank==0)
                            {
                                cout << " Case1_0_34"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_34_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_34_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_34_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_34_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_34_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_34_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_34_maxVal;
                            minAftREACTORLoad = grandChild1_0_34_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_34;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_34.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_34.run(inputPCAANNReg1_0_34,outputStandardizeANNReg1_0_34);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_34.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_35
                        case 35:
                            if(rank==0)
                            {
                                cout << " Case1_0_35"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_35_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_35_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_35_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_35_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_35_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_35_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_35_maxVal;
                            minAftREACTORLoad = grandChild1_0_35_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_35;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_35.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_35.run(inputPCAANNReg1_0_35,outputStandardizeANNReg1_0_35);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_35.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_36
                        case 36:
                            if(rank==0)
                            {
                                cout << " Case1_0_36"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_36_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_36_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_36_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_36_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_36_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_36_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_36_maxVal;
                            minAftREACTORLoad = grandChild1_0_36_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_36;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_36.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_36.run(inputPCAANNReg1_0_36,outputStandardizeANNReg1_0_36);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_36.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_37
                        case 37:
                            if(rank==0)
                            {
                                cout << " Case1_0_37"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_37_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_37_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_37_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_37_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_37_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_37_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_37_maxVal;
                            minAftREACTORLoad = grandChild1_0_37_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_37;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_37.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_37.run(inputPCAANNReg1_0_37,outputStandardizeANNReg1_0_37);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_37.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            
                            // Cluster 1_0_38
                        case 38:
                            if(rank==0)
                            {
                                cout << " Case1_0_38"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_38_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_38_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_38_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_38_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_38_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_38_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_38_maxVal;
                            minAftREACTORLoad = grandChild1_0_38_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_38;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_38.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_38.run(inputPCAANNReg1_0_38,outputStandardizeANNReg1_0_38);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_38.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_0_39
                        case 39:
                            if(rank==0)
                            {
                                cout << " Case1_0_39"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_0_39_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_0_39_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_0_39_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_0_39_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_0_39_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_0_39_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_0_39_maxVal;
                            minAftREACTORLoad = grandChild1_0_39_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_0_39;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_0_39.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_0_39.run(inputPCAANNReg1_0_39,outputStandardizeANNReg1_0_39);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_0_39.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            
                    } // END switch(indexGrandChildCluster) // cluster1_0_X
                    
                } // END if(indexChildCluster==0)
                else if(indexChildCluster==1) // childCluster1_1
                {
                    // Classifier grand child
                    // LOCAL CHILD Standardize Y ,T for Kmeans LOCAL CHILD: standardizedX = (X - meanScale) / standardDeviationScale
                    // Standardize T
                    input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - cluster1_1_meanScaleINPUT[numVarANN-1];
                    input_childLocalStandardized[numVarANN-1] /= cluster1_1_stdScaleINPUT[numVarANN-1];
                    // Standardize Y
                    for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                    {
                        input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - cluster1_1_meanScaleINPUT[kANN];
                        input_childLocalStandardized[kANN] /= cluster1_1_stdScaleINPUT[kANN];
                        //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                        if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                    }
                    
                    
                    // CLASSIFIER LOCAL CHILD: Caculate the distance : Eucledian (Kmeans) or Projection parition (LPCA)
                    // >> Determine indexGrandChildCluster
                    // LPCA example: cv::Mat d0 = (x-r0).t() * eigenVec0.t() * eigenVec0 * (x-r0);
                    // Eucledean: Can be calculated by std::vector
                    
                    // Declare vector x
                    xChild = cv::Mat(numVarANN, 1, CV_32F, input_childLocalStandardized.data());
                    d1_1_0 = cv::norm(xChild,r1_1_0,cv::NORM_L2); // Calculate Euclidean distance from x to cluster 0
                    d1_1_1 = cv::norm(xChild,r1_1_1,cv::NORM_L2);
                    d1_1_2 = cv::norm(xChild,r1_1_2,cv::NORM_L2);
                    d1_1_3 = cv::norm(xChild,r1_1_3,cv::NORM_L2);
                    d1_1_4 = cv::norm(xChild,r1_1_4,cv::NORM_L2);
                    d1_1_5 = cv::norm(xChild,r1_1_5,cv::NORM_L2);
                    d1_1_6 = cv::norm(xChild,r1_1_6,cv::NORM_L2);
                    d1_1_7 = cv::norm(xChild,r1_1_7,cv::NORM_L2);
                    d1_1_8 = cv::norm(xChild,r1_1_8,cv::NORM_L2);
                    d1_1_9 = cv::norm(xChild,r1_1_9,cv::NORM_L2);
                    d1_1_10 = cv::norm(xChild,r1_1_10,cv::NORM_L2);
                    d1_1_11 = cv::norm(xChild,r1_1_11,cv::NORM_L2);
                    d1_1_12 = cv::norm(xChild,r1_1_12,cv::NORM_L2);
                    d1_1_13 = cv::norm(xChild,r1_1_13,cv::NORM_L2);
                    d1_1_14 = cv::norm(xChild,r1_1_14,cv::NORM_L2);
                    
                    // Group distance to d
                    cv::Mat dChild;
                    dChild.push_back(d1_1_0);
                    dChild.push_back(d1_1_1);
                    dChild.push_back(d1_1_2);
                    dChild.push_back(d1_1_3);
                    dChild.push_back(d1_1_4);
                    dChild.push_back(d1_1_5);
                    dChild.push_back(d1_1_6);
                    dChild.push_back(d1_1_7);
                    dChild.push_back(d1_1_8);
                    dChild.push_back(d1_1_9);
                    dChild.push_back(d1_1_10);
                    dChild.push_back(d1_1_11);
                    dChild.push_back(d1_1_12);
                    dChild.push_back(d1_1_13);
                    dChild.push_back(d1_1_14);
                    
                    // Take position of mean (argmin) = indexParentCluster
                    cv::minMaxLoc(dChild, NULL, NULL, &minLocChild, NULL); // d, minVal, maxVal, minLoc, maxLoc
                    indexGrandChildCluster = minLocChild.y; //Point has 2 coordinates (x,y)
                    
                    if(rank==0) // Print to check
                    {
                        cout << "Particles " << p << " || parentCluster = " << indexParentCluster;
                        cout << " || childCluster = " << indexChildCluster << " || grandChildCluster = " << indexGrandChildCluster << " ";
                    }
                    
                    // Save indexCluster of this particle
                    if(activateIndexCluster)
                    {
                        if(rank==0)
                        {
                            ofstream indexClusterFile("outputs/indexCluster.dat",ios::app); //ios::app = append at the end of the file
                            indexClusterFile << t << "	";
                            indexClusterFile << p << "	";
                            indexClusterFile << indexParentCluster <<  "	";
                            indexClusterFile << indexChildCluster <<  "	";
                            indexClusterFile << indexGrandChildCluster << endl;
                            indexClusterFile.close();
                        }
                    }
                    
                    switch(indexGrandChildCluster) // cluster1_1_X
                    {
                            
                        // Cluster 1_1_0
                        case 0:
                            if(rank==0)
                            {
                                cout << " Case1_1_0"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_0_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_0_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_0_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_0_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_0_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_0_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_0_maxVal;
                            minAftREACTORLoad = grandChild1_1_0_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_0;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_0.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_0.run(inputPCAANNReg1_1_0,outputStandardizeANNReg1_1_0);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_0.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_1_1
                        case 1:
                            if(rank==0)
                            {
                                cout << " Case1_1_1"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_1_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_1_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_1_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_1_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_1_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_1_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_1_maxVal;
                            minAftREACTORLoad = grandChild1_1_1_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_1;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_1.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_1.run(inputPCAANNReg1_1_1,outputStandardizeANNReg1_1_1);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_1.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_1_2
                        case 2:
                            if(rank==0)
                            {
                                cout << " Case1_1_2"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_2_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_2_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_2_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_2_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_2_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_2_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_2_maxVal;
                            minAftREACTORLoad = grandChild1_1_2_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_2;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_2.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_2.run(inputPCAANNReg1_1_2,outputStandardizeANNReg1_1_2);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_2.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_3
                        case 3:
                            if(rank==0)
                            {
                                cout << " Case1_1_3"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_3_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_3_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_3_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_3_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_3_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_3_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_3_maxVal;
                            minAftREACTORLoad = grandChild1_1_3_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_3;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_3.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_3.run(inputPCAANNReg1_1_3,outputStandardizeANNReg1_1_3);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_3.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_1_4
                        case 4:
                            if(rank==0)
                            {
                                cout << " Case1_1_4"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_4_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_4_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_4_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_4_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_4_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_4_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_4_maxVal;
                            minAftREACTORLoad = grandChild1_1_4_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_4;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_4.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_4.run(inputPCAANNReg1_1_4,outputStandardizeANNReg1_1_4);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_4.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            // Cluster 1_1_5
                        case 5:
                            if(rank==0)
                            {
                                cout << " Case1_1_5"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_5_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_5_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_5_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_5_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_5_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_5_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_5_maxVal;
                            minAftREACTORLoad = grandChild1_1_5_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_5;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_5.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_5.run(inputPCAANNReg1_1_5,outputStandardizeANNReg1_1_5);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_5.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_6
                        case 6:
                            if(rank==0)
                            {
                                cout << " Case1_1_6"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_6_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_6_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_6_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_6_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_6_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_6_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_6_maxVal;
                            minAftREACTORLoad = grandChild1_1_6_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_6;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_6.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_6.run(inputPCAANNReg1_1_6,outputStandardizeANNReg1_1_6);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_6.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_7
                        case 7:
                            if(rank==0)
                            {
                                cout << " Case1_1_7"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_7_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_7_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_7_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_7_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_7_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_7_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_7_maxVal;
                            minAftREACTORLoad = grandChild1_1_7_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_7;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_7.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_7.run(inputPCAANNReg1_1_7,outputStandardizeANNReg1_1_7);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_7.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            
                            // Cluster 1_1_8
                        case 8:
                            if(rank==0)
                            {
                                cout << " Case1_1_8"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_8_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_8_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_8_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_8_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_8_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_8_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_8_maxVal;
                            minAftREACTORLoad = grandChild1_1_8_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_8;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_8.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_8.run(inputPCAANNReg1_1_8,outputStandardizeANNReg1_1_8);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_8.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_9
                        case 9:
                            if(rank==0)
                            {
                                cout << " Case1_1_9"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_9_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_9_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_9_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_9_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_9_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_9_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_9_maxVal;
                            minAftREACTORLoad = grandChild1_1_9_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_9;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_9.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_9.run(inputPCAANNReg1_1_9,outputStandardizeANNReg1_1_9);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_9.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_10
                        case 10:
                            if(rank==0)
                            {
                                cout << " Case1_1_10"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_10_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_10_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_10_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_10_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_10_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_10_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_10_maxVal;
                            minAftREACTORLoad = grandChild1_1_10_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_10;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_10.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_10.run(inputPCAANNReg1_1_10,outputStandardizeANNReg1_1_10);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_10.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_11
                        case 11:
                            if(rank==0)
                            {
                                cout << " Case1_1_11"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_11_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_11_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_11_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_11_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_11_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_11_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_11_maxVal;
                            minAftREACTORLoad = grandChild1_1_11_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_11;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_11.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_11.run(inputPCAANNReg1_1_11,outputStandardizeANNReg1_1_11);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_11.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_12
                        case 12:
                            if(rank==0)
                            {
                                cout << " Case1_1_12"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_12_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_12_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_12_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_12_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_12_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_12_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_12_maxVal;
                            minAftREACTORLoad = grandChild1_1_12_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_12;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_12.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_12.run(inputPCAANNReg1_1_12,outputStandardizeANNReg1_1_12);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_12.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_13
                        case 13:
                            if(rank==0)
                            {
                                cout << " Case1_1_13"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_13_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_13_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_13_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_13_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_13_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_13_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_13_maxVal;
                            minAftREACTORLoad = grandChild1_1_13_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_13;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_13.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_13.run(inputPCAANNReg1_1_13,outputStandardizeANNReg1_1_13);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_13.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_1_14
                        case 14:
                            if(rank==0)
                            {
                                cout << " Case1_1_14"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_1_14_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_1_14_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_1_14_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_1_14_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_1_14_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_1_14_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_1_14_maxVal;
                            minAftREACTORLoad = grandChild1_1_14_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_1_14;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_1_14.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_1_14.run(inputPCAANNReg1_1_14,outputStandardizeANNReg1_1_14);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_1_14.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            
                            
                    } // END switch(indexGrandChildCluster) // cluster1_1_X
                    
                }// END if(indexChildCluster==1)
                else // // if(indexChildCluster==2) - childCluster1_2
                {
                    // Classifier grand child
                    // LOCAL CHILD Standardize Y ,T for Kmeans LOCAL CHILD: standardizedX = (X - meanScale) / standardDeviationScale
                    // Standardize T
                    input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - cluster1_2_meanScaleINPUT[numVarANN-1];
                    input_childLocalStandardized[numVarANN-1] /= cluster1_2_stdScaleINPUT[numVarANN-1];
                    // Standardize Y
                    for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                    {
                        input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - cluster1_2_meanScaleINPUT[kANN];
                        input_childLocalStandardized[kANN] /= cluster1_2_stdScaleINPUT[kANN];
                        //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                        if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                    }
                    
                    
                    // CLASSIFIER LOCAL CHILD: Caculate the distance : Eucledian (Kmeans) or Projection parition (LPCA)
                    // >> Determine indexGrandChildCluster
                    // LPCA example: cv::Mat d0 = (x-r0).t() * eigenVec0.t() * eigenVec0 * (x-r0);
                    // Eucledean: Can be calculated by std::vector
                    
                    // Declare vector x
                    xChild = cv::Mat(numVarANN, 1, CV_32F, input_childLocalStandardized.data());
                    d1_2_0 = cv::norm(xChild,r1_2_0,cv::NORM_L2); // Calculate Euclidean distance from x to cluster 0
                    d1_2_1 = cv::norm(xChild,r1_2_1,cv::NORM_L2);
                    d1_2_2 = cv::norm(xChild,r1_2_2,cv::NORM_L2);
                    d1_2_3 = cv::norm(xChild,r1_2_3,cv::NORM_L2);
                    d1_2_4 = cv::norm(xChild,r1_2_4,cv::NORM_L2);
                    d1_2_5 = cv::norm(xChild,r1_2_5,cv::NORM_L2);
                    d1_2_6 = cv::norm(xChild,r1_2_6,cv::NORM_L2);
                    d1_2_7 = cv::norm(xChild,r1_2_7,cv::NORM_L2);
                    d1_2_8 = cv::norm(xChild,r1_2_8,cv::NORM_L2);
                    d1_2_9 = cv::norm(xChild,r1_2_9,cv::NORM_L2);
                    
                    // Group distance to d
                    cv::Mat dChild;
                    dChild.push_back(d1_2_0);
                    dChild.push_back(d1_2_1);
                    dChild.push_back(d1_2_2);
                    dChild.push_back(d1_2_3);
                    dChild.push_back(d1_2_4);
                    dChild.push_back(d1_2_5);
                    dChild.push_back(d1_2_6);
                    dChild.push_back(d1_2_7);
                    dChild.push_back(d1_2_8);
                    dChild.push_back(d1_2_9);
                    
                    // Take position of mean (argmin) = indexParentCluster
                    cv::minMaxLoc(dChild, NULL, NULL, &minLocChild, NULL); // d, minVal, maxVal, minLoc, maxLoc
                    indexGrandChildCluster = minLocChild.y; //Point has 2 coordinates (x,y)
                    
                    if(rank==0) // Print to check
                    {
                        cout << "Particles " << p << " || parentCluster = " << indexParentCluster;
                        cout << " || childCluster = " << indexChildCluster << " || grandChildCluster = " << indexGrandChildCluster << " ";
                    }
                    
                    // Save indexCluster of this particle
                    if(activateIndexCluster)
                    {
                        if(rank==0)
                        {
                            ofstream indexClusterFile("outputs/indexCluster.dat",ios::app); //ios::app = append at the end of the file
                            indexClusterFile << t << "	";
                            indexClusterFile << p << "	";
                            indexClusterFile << indexParentCluster <<  "	";
                            indexClusterFile << indexChildCluster <<  "	";
                            indexClusterFile << indexGrandChildCluster << endl;
                            indexClusterFile.close();
                        }
                    }
                    
                    switch(indexGrandChildCluster) // cluster1_2_X
                    {
                        // Cluster 1_2_0
                        case 0:
                            if(rank==0)
                            {
                                cout << " Case1_2_0"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_0_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_0_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_0_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_0_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_0_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_0_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_0_maxVal;
                            minAftREACTORLoad = grandChild1_2_0_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_0;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_0.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_0.run(inputPCAANNReg1_2_0,outputStandardizeANNReg1_2_0);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_0.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_2_1
                        case 1:
                            if(rank==0)
                            {
                                cout << " Case1_2_1"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_1_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_1_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_1_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_1_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_1_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_1_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_1_maxVal;
                            minAftREACTORLoad = grandChild1_2_1_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_1;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_1.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_1.run(inputPCAANNReg1_2_1,outputStandardizeANNReg1_2_1);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_1.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_2
                        case 2:
                            if(rank==0)
                            {
                                cout << " Case1_2_2"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_2_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_2_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_2_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_2_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_2_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_2_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_2_maxVal;
                            minAftREACTORLoad = grandChild1_2_2_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_2;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_2.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_2.run(inputPCAANNReg1_2_2,outputStandardizeANNReg1_2_2);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_2.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                        // Cluster 1_2_3
                        case 3:
                            if(rank==0)
                            {
                                cout << " Case1_2_3"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_3_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_3_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_3_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_3_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_3_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_3_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_3_maxVal;
                            minAftREACTORLoad = grandChild1_2_3_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_3;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_3.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_3.run(inputPCAANNReg1_2_3,outputStandardizeANNReg1_2_3);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_3.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_4
                        case 4:
                            if(rank==0)
                            {
                                cout << " Case1_2_4"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_4_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_4_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_4_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_4_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_4_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_4_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_4_maxVal;
                            minAftREACTORLoad = grandChild1_2_4_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_4;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_4.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_4.run(inputPCAANNReg1_2_4,outputStandardizeANNReg1_2_4);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_4.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_5
                        case 5:
                            if(rank==0)
                            {
                                cout << " Case1_2_5"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_5_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_5_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_5_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_5_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_5_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_5_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_5_maxVal;
                            minAftREACTORLoad = grandChild1_2_5_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_5;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_5.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_5.run(inputPCAANNReg1_2_5,outputStandardizeANNReg1_2_5);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_5.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_6
                        case 6:
                            if(rank==0)
                            {
                                cout << " Case1_2_6"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_6_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_6_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_6_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_6_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_6_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_6_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_6_maxVal;
                            minAftREACTORLoad = grandChild1_2_6_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_6;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_6.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_6.run(inputPCAANNReg1_2_6,outputStandardizeANNReg1_2_6);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_6.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_7
                        case 7:
                            if(rank==0)
                            {
                                cout << " Case1_2_7"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_7_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_7_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_7_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_7_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_7_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_7_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_7_maxVal;
                            minAftREACTORLoad = grandChild1_2_7_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_7;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_7.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_7.run(inputPCAANNReg1_2_7,outputStandardizeANNReg1_2_7);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_7.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_8
                        case 8:
                            if(rank==0)
                            {
                                cout << " Case1_2_8"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_8_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_8_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_8_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_8_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_8_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_8_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_8_maxVal;
                            minAftREACTORLoad = grandChild1_2_8_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_8;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_8.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_8.run(inputPCAANNReg1_2_8,outputStandardizeANNReg1_2_8);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_8.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            // Cluster 1_2_9
                        case 9:
                            if(rank==0)
                            {
                                cout << " Case1_2_9"<<  endl;
                            }
                            // Load INPUT & OUTPUT CHILD Scaler
                            child_MeanINPUTLoad = cluster1_2_9_meanScaleINPUT;
                            child_StdINPUTLoad = cluster1_2_9_stdScaleINPUT;
                            child_MeanOUTPUTLoad = cluster1_2_9_meanScaleOUTPUT;
                            child_StdOUTPUTLoad = cluster1_2_9_stdScaleOUTPUT;
                            
                            // Load Max & Min OUTPUT (Composition space)
                            child_MaxOUTPUTLoad = cluster1_2_9_maxOUTPUT;
                            child_MinOUTPUTLoad = cluster1_2_9_minOUTPUT;
                            
                            // Load maxAftREACTOR & minAftREACTOR
                            //(parent0_maxVal, parent0_minVal; child1_0_maxVal, child1_0_minVal; child1_1_maxVal,child1_1_minVal; child1_2_maxVal,child1_2_minVal)
                            maxAftREACTORLoad = grandChild1_2_9_maxVal;
                            minAftREACTORLoad = grandChild1_2_9_minVal;
                            
                            // Child PCA
                            pcaANN = pcaANN1_2_9;
                            
                            // LOCAL INPUT Standardize
                            // Standardize T
                            input_childLocalStandardized[numVarANN-1] = listParticles[p]->m_T_gas - child_MeanINPUTLoad[numVarANN-1];
                            input_childLocalStandardized[numVarANN-1] /= child_StdINPUTLoad[numVarANN-1];
                            // Standardize Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                input_childLocalStandardized[kANN] = listParticles[p]->m_Yk_gas[kANN] - child_MeanINPUTLoad[kANN];
                                input_childLocalStandardized[kANN] /= child_StdINPUTLoad[kANN];
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2") {cout << "Warning : N2 in the ANN!!!" << endl;}
                            }
                            
                            
                            // PCA Transform
                            // Load to matrix
                            input_childLocalStandardized_Mat = cv::Mat(1, numVarANN, CV_32FC1, input_childLocalStandardized.data());
                            // Project to LPCA space: inputPCA = input of ANN in LPCA space
                            pcaANN.project(input_childLocalStandardized_Mat, inputPCA);
                            // Copy matrix inputPCA to inputPCA_Vec vector - cppflow cannot communicate with cv::Mat of OpenCV
                            if (inputPCA.isContinuous()) // Continuous memory block
                            {
                                inputPCA_Vec.assign((float*)inputPCA.data,(float*)inputPCA.data + inputPCA.total()*inputPCA.channels());
                            } // General formular for multiple channels matrix, here we have only 1 channel (image RGB = 3 channels)
                            
                            
                            // ANN regression to predict Standardized variation
                            // Set input tensor for cppflow (Tensorflow)
                            inputPCAANNReg1_2_9.set_data(inputPCA_Vec);
                            // Predict the  Standardized variation - saved as outputANN tensor
                            modelANNReg1_2_9.run(inputPCAANNReg1_2_9,outputStandardizeANNReg1_2_9);
                            // Get value of outputPCAANNReg tensor (ANN output) to Vector outputStandardizeANN_Vec
                            kRun=0;
                            for (float f : outputStandardizeANNReg1_2_9.get_data<float>())
                            {
                                outputStandardizeANN_Vec[kRun] = f;
                                kRun++;
                            }
                            
                            // INVERSE outputStandardizeANN to outputANN (variation of Y,T in delta_t)
                            //  X = standardizedX*standardDeviationScale + meanScale
                            // T
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] * child_StdOUTPUTLoad[numVarANN-1];
                            outputStandardizeANN_Vec[numVarANN-1] = outputStandardizeANN_Vec[numVarANN-1] + child_MeanOUTPUTLoad[numVarANN-1];
                            // Verify if output (Composition space) out-of-bound
                            outputStandardizeANN_Vec[numVarANN-1] = std::max(outputStandardizeANN_Vec[numVarANN-1],child_MinOUTPUTLoad[numVarANN-1]);
                            outputStandardizeANN_Vec[numVarANN-1] = std::min(outputStandardizeANN_Vec[numVarANN-1],child_MaxOUTPUTLoad[numVarANN-1]);
                            // Calculate Temperature and bound on Max Min GLOBAL data
                            listParticles[p]->m_T_gas = listParticles[p]->m_T_gas + outputStandardizeANN_Vec[numVarANN-1];
                            listParticles[p]->m_T_gas = std::min(std::max(listParticles[p]->m_T_gas,minAftREACTORLoad[numVarANN-1]),maxAftREACTORLoad[numVarANN-1]); // Check if <minValue or >maxValue on GLOBAL
                            
                            //  Y
                            for (int kANN=0; kANN<nsp-1; kANN++) // Don't take N2 (last species)
                            {
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] * child_StdOUTPUTLoad[kANN];
                                outputStandardizeANN_Vec[kANN] = outputStandardizeANN_Vec[kANN] + child_MeanOUTPUTLoad[kANN];
                                // Verify if output (Composition space) out-of-bound
                                outputStandardizeANN_Vec[kANN] = std::max(outputStandardizeANN_Vec[kANN],child_MinOUTPUTLoad[kANN]);
                                outputStandardizeANN_Vec[kANN] = std::min(outputStandardizeANN_Vec[kANN],child_MaxOUTPUTLoad[kANN]);
                                // Calculate Y and bound on Max Min GLOBAL data
                                listParticles[p]->m_Yk_gas[kANN] = listParticles[p]->m_Yk_gas[kANN] + outputStandardizeANN_Vec[kANN];
                                listParticles[p]->m_Yk_gas[kANN] = std::min(std::max(listParticles[p]->m_Yk_gas[kANN],minAftREACTORLoad[kANN]),maxAftREACTORLoad[kANN]); // Check if <minValue or >maxValue
                                //Cross-check if there is N2 inside, if yes, should move N2 to the end of the scheme
                                if(listSpecies[kANN]->m_Name == "N2")
                                    cout << "Warning : N2 in the ANN!!!" << endl;
                            }
                            break;
                            
                            
                    } // END switch(indexGrandChildCluster) // cluster1_2_X
                    
                } // END if(indexChildCluster==2)
                
                // Release OPENCV MAT
                dParent.release();
                
            } // END parentCluster1
            
            // Release OPENCV MAT
            d.release();
            
            
        } // END for (int p=0; p<nTot; p++)
        
 
        
        if(rank==0) cout << "Number of particles modified by EMST check = " << modifEMSTParticle << endl;
        
    }// END flagANN
*/

	// HuuTri@20220111: Commented
	//if(rank==0)	//HT@2020.08.20 check after test
        //{
        //        cout << "Particle 700 before - T= " << listParticles[700]->m_T_gas << " |Enthalpy = " <<  listParticles[700]->m_H_gas << endl;
        //}


	/* ==================================== */
	/* ============ STOCHASTIC ============ */
	/* ==================================== */
      if (step == "Optimisation")
         Reacting(listParticles, mech, mech_desc, nsp, dt, Pressure);
       
      else
	{
	 // Use ANN to predict the source term, then calculate the next-iteration state of each particle - Huu-Tri@20200729
	 	if (flagANN==true)  // Huu-Tri@20200724
		{
			if (rank==0) cout << "Use ANN to advance Y and T" << endl;
		}
	 	else	// Use Cantera to integrate - obtain the next step
		{
			if(i==0)
			{
				if(rank==0)
				{	
					cout << "***Use Cantera ConstPressureReactor to advance" << " |flagANN  = " << flagANN << endl;
         			}
			}
			ReactingParallel(listParticles, mech, mech_desc, nsp, dt, Pressure);
		}
	}	
	/* ==================================== */
	/* ==================================== */

	// =========== FULL DATA PARTICLES  After Reactor - Huu-Tri Nguyen 17.12.2020 ===========
     // Store Temperature & Mass fraction for each particle at each time step BUT AFTER REACTOR- Huu-Tri Nguyen 17.12.2020
     // This is the label of ANN Regression
     // ORCh : dY/dt = EMST then AftEMST then dY/dt = wdot then AftREACTOR
     bool activateFullDataAftREACTOR = true;	//flag to activate Full data (write full_dataParticle.dat)
     if(activateFullDataAftREACTOR)
     {
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{
		cout << "Save after Reactor" << endl;
		if(i==0) 
			cout << "*Full data AFTER REACTOR saving is activated" << endl;
		// Check if meanSpeciesProdRate.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/full_dataParticleAftREACTOR.dat") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/full_dataParticleAftREACTOR.dat exists. Clearing file ... " << endl;	
			
			ofstream full_dataParticleAftREACTOR_clear("outputs/full_dataParticleAftREACTOR.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			full_dataParticleAftREACTOR_clear.close(); //close the file
	
		}	
		
		ofstream full_dataParticleAftREACTOR("outputs/full_dataParticleAftREACTOR.dat",ios::app); //ios::app = append at the end of the file
		if(full_dataParticleAftREACTOR)
		{
			if(i==0)
			{
   				ofstream full_dataParticleAftREACTOR("outputs/full_dataParticleAftREACTOR.dat"); 
   				full_dataParticleAftREACTOR << "#Time	";
				full_dataParticleAftREACTOR << "Particle_number	";
   				for (int k=0; k<nsp; k++)
      					full_dataParticleAftREACTOR << mixture->speciesName(k) << "	";
				full_dataParticleAftREACTOR << "Hm	";	//HT@2020.08.22 : Need to remove
				full_dataParticleAftREACTOR << "Temperature	" << endl;

				for(int p=0; p<nTot; p++)
				{
     					full_dataParticleAftREACTOR << t << "	";
     					full_dataParticleAftREACTOR << p << "	";	// Particle starts from 1
     					for (int k=0; k<nsp; k++)
        					full_dataParticleAftREACTOR << listParticles[p]->m_Yk_gas[k] << "	";
					full_dataParticleAftREACTOR << listParticles[p]->m_H_gas << "	";	//HT2020.08.22 : Need to remove
					full_dataParticleAftREACTOR << listParticles[p]->m_T_gas << "	" << endl;
				}
			}
			else
			{
				for(int p=0; p<nTot; p++)
				{
     					full_dataParticleAftREACTOR << t << "	";
     					full_dataParticleAftREACTOR << p << "	";	// Particle starts from 1
     					for (int k=0; k<nsp; k++)
        					full_dataParticleAftREACTOR << listParticles[p]->m_Yk_gas[k] << "	";
                                        full_dataParticleAftREACTOR << listParticles[p]->m_H_gas << "	";      //HT2020.08.22 : Need to remove
					full_dataParticleAftREACTOR << listParticles[p]->m_T_gas << "	" << endl;
				}	
			}
		}

		full_dataParticleAftREACTOR.close(); //close the  file
	} //END if(rank==0)

     } //END if(activateFullDataAftEMST)
     // =========== END FULL DATA PARTICLES AFTER EMST ===========



    double varEnthalpyCFD = 0.0; 	// Correction CFD Stochastic - Huu-Tri NGUYEN - 13 Nov 2019
   
     if (flagCFDStochas)	// flagCFD == true, use CFD result correction 
     {
	
	/* === Interpolate the data to match with time step of ORCh - Huu-Tri NGUYEN - 5 Sept. 2019 === */
        vector<double> timeORCh;           // Store all the time of ORCh = Iteration * delta_t
        double  mean_hCFDinterpo[nbLines]; // Store the mean CFD enthalpy interpolated - Size = nb of iterations
	double Mean_Hm_ini; // Huu-Tri NGUYEN - 14.01.2020 - Interpolation

	if(i==0)	// Huu-Tri NGUYEN - 14.01.2020
	{ 
		Mean_Hm_ini = Mean_Hm;	// Mean_Hm of iteration t, we are now t+1 because after Stochastic closure
		if(rank ==0) cout << " Correction Stochastic - Mean ini = " << Mean_Hm_ini << endl;
	}


	mean_hCFDinterpo[0] = Mean_Hm_ini;  // No variation between CFD and ORCh >> mean_hCFDinterpo - Mean_Hm = 0

	for(int step = 0; step < nbLines; step++)	
	{
		timeORCh.push_back(step*delta_t); // size of timeORCh vector equals to nbLines (nb of iterations)
	}
	

	// Find Top, Bot position
	for(int step = 1; step < nbLines; step++)	// Start from second value (step = 1), mean_hCFDinterpo[0] = Mean_Hm
        {
		for(int row = 0; row < maxRow-1; row++)	// End before the last number
		{
			if(timeORCh[step] < t_CFD[0]) // Verify if out of range
			{
                       //         mean_hCFDinterpo[step] = Mean_Hm; // Smaller than the first CFD result
									// assume no loss                                        
				double tTop = 0.0;	// tTop < timeORCh < tBot
				double tBot = t_CFD[0];
				double hTop = mean_hCFDinterpo[0];
				double hBot = mean_hCFD[0];


				mean_hCFDinterpo[step] = hTop + ((hBot - hTop)/(tBot-tTop)*(timeORCh[step]-tTop));			


			}
			else if(timeORCh[step] > t_CFD[maxRow-1]) //  Bigger than the last CFD result, take the last value hm
			{

				mean_hCFDinterpo[step] = mean_hCFDinterpo[step-1];
			} 
			else	// In the range of interpolation
			{
				if(timeORCh[step] > t_CFD[row+1])	// Find the cursor position
				{	
					// Do not thing >> Move to next row
				}
				else if(timeORCh[step] == t_CFD[row])
				{	
					mean_hCFDinterpo[step] = mean_hCFD[row];
				}	
				else if(timeORCh[step] > t_CFD[row] && timeORCh[step] < t_CFD[row+1]) // Interpolate
				{
					double tTop = t_CFD[row];	// tTop < timeORCh < tBot
					double tBot = t_CFD[row+1];
					double hTop = mean_hCFD[row];
					double hBot = mean_hCFD[row+1];
					mean_hCFDinterpo[step] = hTop + ((hBot - hTop)/(tBot-tTop)*(timeORCh[step]-tTop));
				}		
			}
			 	
		}
	} 
	

	// Save the interpolated result to output 1
	ofstream mean_hCFD_interpolated(dirCFDOut.c_str());	// Using string - ifstream need path in form of c_str, not only string


	if(mean_hCFD_interpolated)
	{
		mean_hCFD_interpolated << "#Time(s)	"; 
		mean_hCFD_interpolated << "h_mean_interpolated(J/kg)" << endl;

		for(int step = 0; step < nbLines; step++)
		{
			mean_hCFD_interpolated << timeORCh[step] << "	";
			mean_hCFD_interpolated << mean_hCFDinterpo[step] << endl;
		}
	}
	else
	{
		cout << "ERROR: Unable to write h_tau_Interpolated.txt" << endl;
		cout << "Please check computeMultipleInlet.cpp" << endl;
	}

	mean_hCFD_interpolated.close();


	/* =================================== END Interpolate =================================== */
	
	/* =================== CORRECTION STOCHASITIC EQUATIONS ==================== */
        /* CFD Enthalpy Correction - Huu-Tri NGUYEN - 13 Nov 2019 */
        /* Calculate the variation between hCFD and Mean_Hm for each particle */
        /* Calculate heat-loss weight for each particle */
        /* See more at Stochastic equations part below */

	double Mean_Hm_NextStep = 0.0;

 	for (int p=ndil; p<nTot; p++)
      	{	
         	Mean_Hm_NextStep += (listParticles[p]->m_P_gas_liquid*listParticles[p]->m_H_gas);
      	}
      	Mean_Hm_NextStep /= Total_gas_mass;




       if(timeORCh[i] == i*delta_t)
        {
 		/* Main equation */
		/* hp_new = hp_old + weight*varEnthalpyCFD */

		/** varEnthalpyCFd = hCFD - Mean_Hm **/
		/** weight = hp_old / Mean_Hm **/ //Calculate this later (below) due to Curl mixing closure


                varEnthalpyCFD = mean_hCFDinterpo[i+1] - Mean_Hm_NextStep;	// After Stochastic closure so we have calculate for next time step Mean_Hm_NextStep[i+1]
		
		// Huu-Tri Commented check Correction Stochastic - 2020.03.05
	/*	if(rank==0)	//Print only 1 time on screen
		{
			cout << " ======================== Correction Stochastic ========================= " << endl;
			cout << " ----- At " << i*delta_t << "s -step " << i << " -----" << endl; 
			cout << "hCFD at t+1 " << (i+1)*delta_t << " = " << mean_hCFDinterpo[i+1] << endl;
			cout << "Mean_Hm_NextStep at t+1 " << (i+1)*delta_t << "s = " << Mean_Hm_NextStep << endl;
			cout << "Variation = hCFD[i+1] - Mean_Hm_NextStep = " << varEnthalpyCFD << endl;
		}
	*/
		// Averaged loss on nTot particles
		// varEnthalpyCFD *= nTot;
		//if(rank ==0)
		//	cout << "Variation*nTot = " << varEnthalpyCFD << endl;


        }
        else
        {
                cout << "Something is wrong with interpolation - check computeMultipleInlet.cpp" << endl;
        }




 
        /* ================== END CORRECTION ================= */
	

	/*====================== CORRECTION STOCHASTIC EQUATIONS ====================== */
	/* CFD Enthalpy Correction STOCHASTIC EQUATIONS - Huu-Tri NGUYEN - 13 Novembre 2019*/
	/* Start at i==1 (i==0 is initial condition) */	
	
	double checkEnthalpy = 0.0;
	double sumVar = 0.0;
	double sumH_gas = 0.0;
	int mixingIte = -1; // Number of mixing iterations before enthalpy correction  

	if(i<mixingIte) // Wait "mixingIte" steps before correct enthalpy	//i=0, initial state
	{
		// Without correction			if(rank==0) 
		cout << "The particles mix in " << mixingIte << " iterations = " << (mixingIte*delta_t)*1000 << "ms before correction" << endl << endl;
	}
	else // i> mixingIte
	{
	
	// Commented by Huu-Tri Nguyen - 2020.03.05
	//	if(rank==0) 
	//	{	
	//		cout << "Correction Enthalpy" << endl;

	//	}
	
		// Define Particle type
	//	vector<double> particleType;
	//	for (int p=0; p<nTot; p++)
	//	{
      	//		if (p < nbParticles[0])
        //			particleType[p] = 0;
      	//		else if (p > nbParticles[0]-1 && p < nbParticles[0] + nbParticles[1])
        // 			particleType[p] = 1;
      	//		else if (p >= nbParticles[0] + nbParticles[1])
        // 			particleType[p] = 2;
	//	}


		// Calculate hTot_abs = sum(abs(h_particle))
		double hTot_abs = 0.0;
		double sum_Tm_C = 0.0;	// Huu-Tri Nguyen - 26.01.2020 - Calculate weight
		for (int p=0; p<nTot; p++)
		{

			hTot_abs += abs(listParticles[p]->m_H_gas);
			sum_Tm_C += (listParticles[p]->m_T_gas - 273.15);

		}
	
		// check enthalpy particle
		double Mean_Hm_NextStep_checkBefore = 0.0;
        	for (int p=ndil; p<nTot; p++)
        	{
                	Mean_Hm_NextStep_checkBefore += (listParticles[p]->m_P_gas_liquid*listParticles[p]->m_H_gas);
		
        	}
        
		Mean_Hm_NextStep_checkBefore /= Total_gas_mass;
	
		// Commented by Huu-Tri Nguyen - 2020.03.05
	/*	if(rank ==0) cout << " Mean_Hm_NextStep_check = " << Mean_Hm_NextStep_checkBefore << " :: ndil = " << ndil << " :: Total gas mass = " << Total_gas_mass << " :: nTot = " << nTot << endl; 
		

		if(rank ==0) cout << "sum_Tm_C = " << sum_Tm_C <<  " Mean_Tm_C next step = " << sum_Tm_C/nTot << endl;
	*/

		double sum_weight = 0.0; // HT 26.01.2020
		
		
		for (int p=0; p<nTot; p++)
		{	
			double weight_particle = 0;
			sumVar += varEnthalpyCFD; // Should = varEnthalpy before /nTot
			sumH_gas += listParticles[p]->m_P_gas_liquid*listParticles[p]->m_H_gas;	// Should = meanHm (before correction)
	
			//Correction
		//HT	weight_particle = listParticles[p]->m_H_gas/Mean_Hm_NextStep;

		//HT	weight_particle = abs(listParticles[p]->m_H_gas)/hTot_abs*nTot;	// New formulation - Huu-Tri - 22.01.2020

			weight_particle = (listParticles[p]->m_T_gas-273.15)/sum_Tm_C*nTot; 
			sum_weight += weight_particle;
		//	weight_particle = 1.0/nTot;
		//	if(rank==0) 	cout << "var = " << varEnthalpyCFD << " Weight = " << weight_particle << " * = " << weight_particle*varEnthalpyCFD << endl;

//		if(rank==0) cout << "Particle " << p << " before correction = " << listParticles[p]->m_H_gas << endl; 	
 //		if(p >= nbParticles[0])
 			listParticles[p]->m_H_gas = listParticles[p]->m_H_gas +  weight_particle*varEnthalpyCFD;	// Add abs(weight_particle) - Huu-Tri Nguyen - 17.01.2020	


//		if(rank==0) cout << " 	after correction = " << listParticles[p]->m_H_gas << endl;

			checkEnthalpy += listParticles[p]->m_H_gas; // Should = mean_CFDinterpo (after correction)
//			if(rank==0) cout << " check Enthaly particle " << p << " = " << checkEnthalpy << endl;
		
		}


		sumH_gas /= Total_gas_mass;		
		checkEnthalpy /= nTot;
		
		// Check enthalpy after correction
		double Mean_Hm_NextStep_checkAfter = 0.0;
                for (int p=ndil; p<nTot; p++)
                {
                        Mean_Hm_NextStep_checkAfter += (listParticles[p]->m_P_gas_liquid*listParticles[p]->m_H_gas);

                }
                Mean_Hm_NextStep_checkAfter /= Total_gas_mass;

		double varBeforeAfter = 0.0;
		varBeforeAfter = Mean_Hm_NextStep_checkAfter - Mean_Hm_NextStep_checkBefore;


	/* Commented by Huu-Tri Nguyen - 2020.03.05 
               if(rank ==0) 
		{
			cout << " Mean_Hm_NextStep_check AFTER = " << Mean_Hm_NextStep_checkAfter  << endl;
			cout << " varBeforeAfter = Mean_Hm_NextStep_checkAfter - Mean_Hm_NextStep_checkBefore  = " << varBeforeAfter << "  >> should = varEnthalpyCFD " << endl;
		} 

		if(rank==0)
		{
		cout << " --------- Correction Check ---------- " << endl;
		cout << " sum_weight = " << sum_weight << endl;
		cout << "Before correction, sumH_gas (should = Mean_Hm) =  " << sumH_gas << endl;
		cout << "After correction, checkEnthalpy (should = hCFD) = " << checkEnthalpy << endl;	
		cout << "Variation = checkEnthalpy - mean_hCFDinterpo[i+1] = " <<  checkEnthalpy - mean_hCFDinterpo[i+1] << endl;
		cout << endl;
		}
	*/
	} //End else


	// ==== Check correction of particles enthalpy  - Huu-Tri Nguyen - 16.01.2020 ==== //
	bool hmindataAfter = false;
	if(rank==0 && hmindataAfter)
	{	
		if(file_exists("outputs/Z_hmindataAfterCorrection.dat") && i==0)
		{
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/Z_hmindataAfterCorrection.dat exists. Clearing file ... " << endl;	
			
			ofstream Z_hmindataAfter_clear("outputs/Z_hmindataAfterCorrection.dat", ios::out | ios::trunc);	//open file in trunc mode to clear the content
			Z_hmindataAfter_clear.close(); //close the file

		}		

		ofstream Z_hmindataAfter("outputs/Z_hmindataAfterCorrection.dat",ios::app); //ios::app = append at the end of the file
		if(Z_hmindataAfter)
		{
			if(i==0)	// write the first line
			{  
				Z_hmindataAfter << "#1:time  2:Particle_number  3:particle type  4:Zn2p	5:hminp	6:hp_befo	7:hp_after	8:OutOfBound" << endl;
			}		


			double Yn2_0, Yn2_f;
			double Yn2_gbIni = 0, Zn2_gbIni = 0  ; // Huu-Tri Nguyen 16.01.2020 - To calculate Zn2_gbIni >> hmin(Z)
			Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
			Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
	    
			// Find initial mixture fraction Zn2_gbIni of inlet GB 
			for (int k=0; k<nsp; k++)
			{	
			
				if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
				{
			//GB		Yn2_gbIni = Ym_Trajectories_store[2][0][k];	// Only take the first step i=0
				}
			}

			Zn2_gbIni = ( Yn2_gbIni-Yn2_0)/(Yn2_f-Yn2_0);	// Initial mixture fraction of Burnt gas

	
			// Calculate enthalpy mix of inlets - UMONS case - Huu-Tri Nguyen 15.01.2020
			double h_gasIni = Hm_inletIni[0];
			double h_airIni = Hm_inletIni[1];
			double h_burntGasIni = Hm_inletIni[2];
			double hminParticle = 0;			// Save hmin(Z) of each particle
			double hmaxParticle =0; 			// Save hmax(Z) of each particle - 20.01.2020
			double Zn2Particle = 0;
			//double h_mixZ_Deter;
			//	h_mixZ_Deter = h_gas*Zn2_DeterMix + h_air*(1-Zn2_DeterMix);	// In the case of 2 inlets adidabatic


			// Huu-Tri NGUYEN - 07.01.2020 - Calculate Z (mixture fraction) by N2
			for (int p=0; p<nTot; p++)
      			{	

				
				// Define Particle type
      				double particleType;
      				if (p < nbParticles[0])
         				particleType = 0;
      				else if (p > nbParticles[0]-1 && p < nbParticles[0] + nbParticles[1])
         				particleType = 1;
      				else if (p >= nbParticles[0] + nbParticles[1])
         				particleType = 2;

				double Yn2, Yn2_0, Yn2_f;
				Zn2Particle = 0;
				Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
				Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
				int OutOfBound = 0; 	// To know if the particle gets out the triangle (=1) or Not (=0)
      
      				for (int k=0; k<nsp; k++)
      				{
	
         				if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
            					Yn2 = listParticles[p]->m_Yk_gas[k];
				}      
       	
				Zn2Particle = (Yn2-Yn2_0)/(Yn2_f-Yn2_0); //Huu-Tri NGUYEN - 07.01.2020: Mixture fraction based on N2 of 1 particle
									// Zst_n2 is calculated in Excel file of case conditions
				// Calculate hmin(Z) of this particle
				if(Zn2Particle <= Zn2_gbIni)		// Left branch air-burnt gas on (h,z) space
				{
					hminParticle = (h_burntGasIni - h_airIni)/Zn2_gbIni*Zn2Particle + h_airIni; 
				}
				else // Zn2Particle > Zn2_gbIni 	// Right branch burnt gas-fuel on (h,z) space
				{
					hminParticle = (h_gasIni - h_burntGasIni)/(1 - Zn2_gbIni)*(Zn2Particle - Zn2_gbIni) + h_burntGasIni;
				}



				// Calculate hmax - 20.01.2020
				hmaxParticle = (h_gasIni - h_airIni)*Zn2Particle + h_airIni;


				// Print to file
				Z_hmindataAfter << t << "	";
				Z_hmindataAfter << p+1 << "	";
				Z_hmindataAfter << particleType << "	";
				Z_hmindataAfter << Zn2Particle << "	";
				Z_hmindataAfter << hminParticle << "	";
				Z_hmindataAfter << listParticles[p]->m_H_gas << "	";	// Particle enthalpy BEFORE the comparison with hmin

				// Check if Enthalpy after correction of this particle < or > hminParticle
				// If < hminParticle, particle go outside the triangle (h_gasIni, h_airIni, h_burntGasIni) 
				// Enthalpy of this particle should be = hminParticle
			//	if(listParticles[p]->m_H_gas < hminParticle)
			//	{
			//		OutOfBound = 1; 	// Particle is out of boudary hmin
	//HT				listParticles[p]->m_H_gas =  hminParticle;
			//	}





				Z_hmindataAfter << listParticles[p]->m_H_gas << "	";	// Particle enthalpy AFTER the comparison with hmin

				Z_hmindataAfter << OutOfBound << "	";
				Z_hmindataAfter << endl;

			} //end for(p = 0>pTot)
		} //End if(Z_hmindataAfter)

	Z_hmindataAfter.close();
	// End Check correction of particles enthalpy  - Huu-Tri Nguyen - 16.01.2020 //
	} // End if(rank==0)

  } //End if(flagCFD)
	/*==================== END CORRECTION ====================*/



	// h_particle = hmin (After Stochastic closure) - Huu-Tri Nguyen 20.01.2020
	// For iteration i+1 >> Calculate Mean_Hm before go into Lagrangian closure
	// This part should be place here because when i==0, all particles has the initial state so h_particle[i==0] = hmin[i==0] = hInletIni 

			double Yn2_0, Yn2_f;
			double Yn2_gbIni = 0, Zn2_gbIni = 0  ; // Huu-Tri Nguyen 16.01.2020 - To calculate Zn2_gbIni >> hmin(Z)
			Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
			Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
	    
			// Find initial mixture fraction Zn2_gbIni of inlet GB 
			for (int k=0; k<nsp; k++)
			{	
			
				if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
				{
					Yn2_gbIni = Ym_Trajectories_store[2][0][k];	// Only take the first step i=0
				}
			}

			Zn2_gbIni = ( Yn2_gbIni-Yn2_0)/(Yn2_f-Yn2_0);	// Initial mixture fraction of Burnt gas

	
			// Calculate enthalpy mix of inlets - UMONS case - Huu-Tri Nguyen 15.01.2020
			double h_gasIni = Hm_inletIni[0];
			double h_airIni = Hm_inletIni[1];
			double h_burntGasIni = Hm_inletIni[2];
			double hminParticle = 0;			// Save hmin(Z) of each particle
			double hmaxParticle =0; 			// Save hmax(Z) of each particle - 20.01.2020
			double Zn2Particle = 0;
			//double h_mixZ_Deter;
			//	h_mixZ_Deter = h_gas*Zn2_DeterMix + h_air*(1-Zn2_DeterMix);	// In the case of 2 inlets adidabatic


			// Huu-Tri NGUYEN - 07.01.2020 - Calculate Z (mixture fraction) by N2
			for (int p=0; p<nTot; p++)
      			{
				
				double Yn2, Yn2_0, Yn2_f;
				Zn2Particle = 0;
				Yn2_0 = 0.766990291; 	// UMONS case - Inlet air preheated 
				Yn2_f = 0.396761134;	// UMONS case - Inlet fuel
				int OutOfBound = 0; 	// To know if the particle gets out the triangle (=1) or Not (=0)
      
      				for (int k=0; k<nsp; k++)
      				{
	
         				if (mixture->speciesName(k) == "N2")		//Huu-Tri NGUYEN - 07.01.2020
            					Yn2 = listParticles[p]->m_Yk_gas[k];
				}      
       	
				Zn2Particle = (Yn2-Yn2_0)/(Yn2_f-Yn2_0); //Huu-Tri NGUYEN - 07.01.2020: Mixture fraction based on N2 of 1 particle
									// Zst_n2 is calculated in Excel file of case conditions
				// Calculate hmin(Z) of this particle
				if(Zn2Particle <= Zn2_gbIni)		// Left branch air-burnt gas on (h,z) space
				{
					hminParticle = (h_burntGasIni - h_airIni)/Zn2_gbIni*Zn2Particle + h_airIni; 
				}
				else // Zn2Particle > Zn2_gbIni 	// Right branch burnt gas-fuel on (h,z) space
				{
					hminParticle = (h_gasIni - h_burntGasIni)/(1 - Zn2_gbIni)*(Zn2Particle - Zn2_gbIni) + h_burntGasIni;
				}



				// Calculate hmax - 20.01.2020
				hmaxParticle = (h_gasIni - h_airIni)*Zn2Particle + h_airIni;


				// Check if Enthalpy after correction of this particle < or > hminParticle
				// If < hminParticle, particle go outside the triangle (h_gasIni, h_airIni, h_burntGasIni) 
				// Enthalpy of this particle should be = hminParticle
			//	if(listParticles[p]->m_H_gas < hminParticle)
			//	{
			//		OutOfBound = 1; 	// Particle is out of boudary hmin
	//HT				listParticles[p]->m_H_gas =  hminParticle;
			//	}


			} //end for(p = 0>pTot)

	//  END h_particle = hmin (After Stochastic closure) - Huu-Tri Nguyen 20.01.2020

    // Calculate right hand-side of Y(=mixing + source term) and T (=source term) - Huu-Tri NGUYEN - 2019.12.05
   	// Initialization
	double *Tm_gas_after = new double[nTot];	// 1D array temperature for each particle
	double *rightSide_T  = new double[nTot];	// 1D array right-hand-side for each particle

	double **Yk_gas_after  = new double*[nTot];	// 2D array ** with first dimension (number of particles)
	for (int p=0; p<nTot; p++)	// Create second dimension 
	{
		Yk_gas_after[p] = new double[nsp];	// nsp = number of species has declared above

	}
	double **rightSide  = new double*[nTot];	// 2D array ** with first dimension (number of particles)
	for (int p=0; p<nTot; p++)	// Create second dimension 
	{
		rightSide[p] = new double[nsp];	// nsp = number of species has declared above
	}

	double *meanSourceTerm_Stochas = new double[nsp];
	double meanSourceTerm_T = 0.0;


    if(activateSourceTermParticle)
    { 
	// Calculation
	// For each particle
	for (int p=ndil; p<nTot; p++)
      	{
		Tm_gas_after[p] = listParticles[p]->m_T_gas;		
		rightSide_T[p] = Tm_gas_after[p] - Tm_gas_before[p];
		rightSide_T[p] /= delta_t;
	
 		for (int k=0; k<nsp; k++)
        	{
              	 	Yk_gas_after[p][k] = listParticles[p]->m_Yk_gas[k];
			rightSide[p][k] = Yk_gas_after[p][k] - Yk_gas_before[p][k];	// HT@2020.09.17: Correct after - before
			rightSide[p][k] /= delta_t;
	
		}	
		
	}
	
	// Sum and Averaged on all particles
	for (int p=ndil; p<nTot; p++)
      	{
		meanSourceTerm_T += rightSide_T[p];
		for (int k=0; k<nsp; k++)
        	{
			meanSourceTerm_Stochas[k] += rightSide[p][k]; // rightSide = Mix + w (Must subtract Mix) 
		}
	}
	

	meanSourceTerm_T /= nTot;
	
	for (int k=0; k<nsp; k++)
	{
		meanSourceTerm_Stochas[k] /= nTot;
			//if(rank==0) // commented by Huu-Tri@20200731
				//cout << "meanSource term of " << listSpecies[k]->m_Name << " = " << meanSourceTerm_Stochas [k]  << endl;
	}
	

	// Step 3: Print the MEAN species production rate to CFD_results/meanSpeciesProdRate.txt

	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{

		// Check if meanSpeciesProdRate.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/meanSpeciesProdRate.txt") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/meanSpeciesProdRate.txt exists. Clearing file ... " << endl;	
			
			ofstream meanSpeciesProdRate_clear("outputs/meanSpeciesProdRate.txt", ios::out |  ios::trunc);	//open file in trunc mode to clear the content
			meanSpeciesProdRate_clear.close(); //close the file
	
		}		


	
		ofstream meanSpeciesProdRate("outputs/meanSpeciesProdRate.txt",ios::app); //ios::app = append at the end of the file
		if(meanSpeciesProdRate)
		{
			if(i==0)	//First step: Need to write the headline
			{
				// First line
				meanSpeciesProdRate << "Time	"; 
					//meanSpeciesProdRate << "T	"; //HT@2020.09.08
				for (int k=0; k<nsp; k++)
				{
				//	meanSpeciesProdRate << k+3 << ":" << listSpecies[k]->m_Name << "	";
				meanSpeciesProdRate << listSpecies[k]->m_Name << "        "; //Added by Huu-Tri@2020.09.08
				}	
				meanSpeciesProdRate << "T	"; 
				meanSpeciesProdRate << endl;			

				// Data from ORCh
				meanSpeciesProdRate << i*delta_t << "	";
					//meanSpeciesProdRate << meanSourceTerm_T << "	";
				for (int k=0; k<nsp; k++)
				{
					meanSpeciesProdRate << meanSourceTerm_Stochas[k] << "	";
				}	
				meanSpeciesProdRate << meanSourceTerm_T << "    "; //HT@2020.09.08
				meanSpeciesProdRate << endl;
			}
			else
			{		
				// Data from ORCh
				meanSpeciesProdRate << i*delta_t << "	";
					//meanSpeciesProdRate << meanSourceTerm_T << "	"; //HT@2020.09.08
				for (int k=0; k<nsp; k++)
				{
					meanSpeciesProdRate << meanSourceTerm_Stochas[k]  << "	";
				}
				meanSpeciesProdRate << meanSourceTerm_T << "    ";
				meanSpeciesProdRate << endl;
			}
		}
		else
		{	
			cout << "ERROR: Impossible to write meanSpeciesProdRate.txt" << endl;
			cout << "Please check computeMultipleInlet.cpp" << endl;
		}
	
		meanSpeciesProdRate.close();
	}

	// Step 4: Print the source term of each particle to CFD_results/dataSourceTerm_Particle.txt
	if(rank==0)	//Parallel MPI stuff to prevent print multiple lines, rank = 0 <=> First processor
	{

		// Check if dataSourceTerm_Particle.txt file exists at the first step
		// If yes, clear the file content
		if(file_exists("outputs/dataSourceTerm_Particle.txt") && i==0)
		{
		
			cout << " -------------- Warrning --------------" << endl;
			cout << " outputs/dataSourceTerm_Particle.txt exists. Clearing file ... " << endl;	
			
			ofstream dataSourceTerm_Particle_clear("outputs/dataSourceTerm_Particle.txt", ios::out |  ios::trunc);	//open file in trunc mode to clear the content
			dataSourceTerm_Particle_clear.close(); //close the file
	
		}		


	
		ofstream dataSourceTerm_Particle("outputs/dataSourceTerm_Particle.txt",ios::app); //ios::app = append at the end of the file
		if(dataSourceTerm_Particle)
		{
			if(i==0)	//First step: Need to write the headline
			{
				// First line
				dataSourceTerm_Particle << "#Time	"; 
				dataSourceTerm_Particle << "Particle_number	"; 
					//dataSourceTerm_Particle << "T	"; //HT@2020.09.08
				for (int k=0; k<nsp; k++)
				{
				//	dataSourceTerm_Particle << k+4 << ":" << listSpecies[k]->m_Name << "	";
				dataSourceTerm_Particle << listSpecies[k]->m_Name << "	"; // Added by Huu-Tri@2020.09.08
				}
				dataSourceTerm_Particle << "T";
				dataSourceTerm_Particle << endl;			

				// Data from ORCh
				for(int p=0; p<nTot; p++)
				{
					dataSourceTerm_Particle << (i+1)*delta_t << "	";	//rightSide is calculated on (i+1)-i
					dataSourceTerm_Particle << p << "	";
						//dataSourceTerm_Particle << rightSide_T[p] << "	"; //HT@2020.09.08
					for (int k=0; k<nsp; k++)
					{
						dataSourceTerm_Particle << rightSide[p][k] << "	";
					}
					dataSourceTerm_Particle << rightSide_T[p] << "  ";
					dataSourceTerm_Particle << endl;
				}
			}
			else
			{		
				// Data from ORCh
				for(int p=0; p<nTot; p++)
				{
					dataSourceTerm_Particle << (i+1)*delta_t << "	";
					dataSourceTerm_Particle << p << "	";
						//dataSourceTerm_Particle << rightSide_T[p] << "	"; //HT@2020.09.08
					for (int k=0; k<nsp; k++)
					{
						dataSourceTerm_Particle << rightSide[p][k] << "	";
					}
					dataSourceTerm_Particle << rightSide_T[p] << "  ";
					dataSourceTerm_Particle << endl;
				}
			}
		}
		else
		{	
			cout << "ERROR: Impossible to write dataSourceTerm_Particle.txt" << endl;
			cout << "Please check computeMultipleInlet.cpp" << endl;
		}
	
		dataSourceTerm_Particle.close();
	}

   } // End if(activateSourceTermParticle)


	// Free w_species memory (array pointer should be deleted after use)	
	delete Tm_gas_before;
	delete Tm_gas_after;
	delete rightSide_T; 

	for (int p=0; p<nTot; p++)	// Create second dimension 
	{
		delete[] Yk_gas_before[p];
	}
	delete[] Yk_gas_before;

	for (int p=0; p<nTot; p++)	// Create second dimension 
	{
		delete[] Yk_gas_after[p];
	}
	delete[] Yk_gas_after;

	for (int p=0; p<nTot; p++)	// Create second dimension 
	{
		delete[] rightSide[p];
	}
	delete[] rightSide;
	
	delete meanSourceTerm_Stochas ;
	
   // End Calculate right hand-side of Y(=mixing + source term) and T (=source term) - Huu-Tri NGUYEN - 2019.12.05


      // Store time step	
      t = t + dt;
      time_store[i+1] = t;

      // Print to screen
       if (rank == 0) cout << '.' << flush;
       //if (rank ==0)  cout << t << " |*| " << flush;
   } // END of big loop i

    // FLAGANN: Release OPENCV MAT >> If declare before for(i), it should release after loop
    /* flagANN 4/4
    r0.release();
    r1.release();
    
    r0_0.release();
    r0_1.release();
    r0_2.release();
    r0_3.release();
    r0_4.release();
    r0_5.release();
    r0_6.release();
    r0_7.release();
    r0_8.release();
    r0_9.release();
    r0_10.release();
    r0_11.release();
    r0_12.release();
    r0_13.release();
    
    r1_0.release();
    r1_1.release();
    r1_2.release();

    
    input_childLocalStandardized_Mat.release();
    inputPCA.release();
    
    x.release();
    xParent.release();
    */
    // END FLAGANN: Release OPENCV MAT


} //end of main computeMultipleInlet::getMultipleInlet







void computeMultipleInlet::Reacting(vector<Particle*> &listParticles, string mech, string mech_desc, int nsp, double dt, double Pressure)
{
   int nTot = listParticles.size();
   double *Ym = new double[nsp];
   double Hm;
   double Zm;
   double Tm;

   for (int p=0; p<nTot; p++)
   {
      for (int k=0; k<nsp; k++)
         Ym[k] = listParticles[p]->m_Yk_gas[k];

      Hm = listParticles[p]->m_H_gas;

      Next_Time_Step(mech, mech_desc, Pressure, Ym, Hm, Tm, dt);

      for (int k=0; k<nsp; k++)
         listParticles[p]->m_Yk_gas[k] = Ym[k];

      listParticles[p]->m_H_gas = Hm;
      listParticles[p]->m_T_gas = Tm;
   }
}

void computeMultipleInlet::ReactingParallel(vector<Particle*> &listParticles, string mech, string mech_desc, int nsp, double dt, double Pressure)
{
   int nTot = listParticles.size();
   double *Ym = new double[nsp];
   double Hm;
   double Tm;

   //Treat parallel stuff
   int rank, nb_processus;
  
   MPI_Comm_rank(MPI_COMM_WORLD, &rank);
   MPI_Comm_size(MPI_COMM_WORLD, &nb_processus);

   int Ifi = 0;
   int Ila = 0;
   int Ifi_rank = 0;
   int Ila_rank = 0;

   int RecvCounts [nb_processus];
   int Disp [nb_processus];
   for (int r=0; r<nb_processus; r++)
      Disp[r] = 0;
   

   for (int r=0; r<nb_processus; r++)
   {
      if (r < nTot%nb_processus)
      {
         Ifi = (nTot/nb_processus)*r + r;
         Ila = (nTot/nb_processus)*r + (nTot/nb_processus) + r + 1;
      }
      else
      {
         Ifi = (nTot/nb_processus)*r + nTot%nb_processus;
         Ila = (nTot/nb_processus)*r + (nTot/nb_processus) + nTot%nb_processus;
      }

      RecvCounts[r] = (Ila-Ifi)*(nsp+2); //for Yks and H and T
      for (int rb=r; rb<nb_processus-1; rb++)
         Disp[rb+1] += (Ila-Ifi)*(nsp+2);
      
      if (rank == r)
      {
         Ifi_rank = Ifi;
         Ila_rank = Ila;
      }
   }

   int nb_particles = Ila_rank-Ifi_rank;

   for (int p=Ifi_rank; p<Ila_rank; p++)
   {
      for (int k=0; k<nsp; k++)
         Ym[k] = listParticles[p]->m_Yk_gas[k];

      Hm = listParticles[p]->m_H_gas;

      Next_Time_Step(mech, mech_desc, Pressure, Ym, Hm, Tm, dt);

      for (int k=0; k<nsp; k++)
         listParticles[p]->m_Yk_gas[k] = Ym[k];

      listParticles[p]->m_H_gas = Hm;
      listParticles[p]->m_T_gas = Tm;
   }

   double Data_Proc[nb_particles*(nsp+2)];
   double Data_All[nb_processus*nb_particles*(nsp+2)];

   int count = 0;
   for (int p=Ifi_rank; p<Ila_rank; p++)
   {
      for (int k=0; k<nsp; k++)
      {
         Data_Proc[count] = listParticles[p]->m_Yk_gas[k];
         count += 1;
      }
      Data_Proc[count] = listParticles[p]->m_H_gas;
      count += 1;
       
      Data_Proc[count] = listParticles[p]->m_T_gas;
      count += 1;
   }

   MPI_Allgatherv(Data_Proc, nb_particles*(nsp+2), MPI_DOUBLE, Data_All, RecvCounts, Disp, MPI_DOUBLE, MPI_COMM_WORLD);

   count = 0;
   for (int p=0; p<nTot; p++)
   {
 
      for (int k=0; k<nsp; k++)
      {
         listParticles[p]->m_Yk_gas[k] = Data_All[count];
         count += 1;
      }
      listParticles[p]->m_H_gas = Data_All[count];
      count += 1;

      listParticles[p]->m_T_gas = Data_All[count];
      count += 1;
   }
}

void computeMultipleInlet::getMixedGasesComposition(string mech, string mech_desc, vector<MultipleInlet*> listInlets, string step)
{

   int rank, nb_processus;

   if (step != "Optimisation")
   {
      MPI_Comm_rank(MPI_COMM_WORLD, &rank);
      MPI_Comm_size(MPI_COMM_WORLD, &nb_processus);
   }

   IdealGasMix *mixture  = new IdealGasMix(mech,mech_desc);
   int nsp = mixture->nSpecies();
   int nbInlets = listInlets.size(); 

   double *Compo_Yk_mixed = new double[nsp];
   for (int k=0; k<nsp; k++)
      Compo_Yk_mixed[k] = 0.0;
   double Compo_H_mixed = 0.0;
   double Total_flowRate = 0.0;

   //Composition of the burned gases
   for (int n=0; n<nbInlets; n++)
   {
      IdealGasMix *InletMixture = new IdealGasMix(mech, mech_desc);

      if (listInlets[n]->m_X_Species != "")
      {
         if (rank == 0)
          //  cout << "Set the mole fraction of inlet " << n << endl;
         InletMixture->setState_TPX(listInlets[n]->m_Temperature, listInlets[n]->m_Pressure, listInlets[n]->m_X_Species);
      }
      else if (listInlets[n]->m_Y_Species != "")
      {
         if (rank == 0)
          //  cout << "Set the mass fraction of inlet " << n << endl;
         InletMixture->setState_TPY(listInlets[n]->m_Temperature, listInlets[n]->m_Pressure, listInlets[n]->m_Y_Species);
      }

      double *Ym = new double[nsp];
      double Hm = 0.0;
      InletMixture->getMassFractions(Ym);
      Hm = InletMixture->enthalpy_mass();

      for (int k=0; k<nsp; k++)
         Compo_Yk_mixed[k] += listInlets[n]->m_flowRate*Ym[k];
      Compo_H_mixed += listInlets[n]->m_flowRate*Hm;
      Total_flowRate += listInlets[n]->m_flowRate;
   }
   
   for (int k=0; k<nsp; k++)
   {
      Compo_Yk_mixed[k] /= Total_flowRate;
   }
   Compo_H_mixed /= Total_flowRate;
   if (rank == 0)
   {
      cout << endl <<  "Composition to enter for the equilibrium computation to get the Burned gases" << endl;
      cout << "Compo_H_mixed " << Compo_H_mixed << endl;
   }

   IdealGasMix *TestMixture = new IdealGasMix(mech, mech_desc);
   TestMixture->setMassFractions(Compo_Yk_mixed);
   TestMixture->setState_HP(Compo_H_mixed, listInlets[0]->m_Pressure);

   double *Xm = new double[nsp];
   double T_mixed = 0.0;
   TestMixture->getMoleFractions(Xm);
   T_mixed = TestMixture->temperature();

   if (rank == 0)
   {
      for (int k=0; k<nsp; k++)
      {
         if (Xm[k] != 0.0)
            cout << "X_" << mixture->speciesName(k) << ": " << Xm[k] << endl;
      }
      cout << "T_mixed " << T_mixed << endl;
   }

   delete TestMixture;
}

void computeMultipleInlet::Next_Time_Step_with_drgep(string mech, string mech_desc, vector<bool> Targets, double P, double *Ym, double &Hm, double &Tm, double delta_t, 
                    vector<vector<double> > &R_AD_Trajectories, vector<vector<double> > &max_j_on_Target, string  step, int n, double time)
{


   IdealGasMix *mixture = new IdealGasMix(mech, mech_desc);
   mixture->setMassFractions(Ym);
   mixture->setState_HP(Hm, P);

   ConstPressureReactor reac;
   reac.insert(*mixture);
   ReactorNet sim;
   sim.addReactor(reac);

   sim.advance(delta_t);

   Hm  = mixture->enthalpy_mass();
   Tm = mixture->temperature();
   mixture->getMassFractions(Ym);

   drgep *species_relations = new drgep();
   species_relations->drgep_0D_species(mixture, Targets, R_AD_Trajectories, n, time);

  // Comment the duplicated part (???) - Huu-TriNGUYEN@2020.10.14  	
   /*if (step == "DRGEP_Reactions")
   drgep *species_relations = new drgep();
   species_relations->drgep_0D_species(mixture, Targets, R_AD_Trajectories, n, time);

   if (step == "DRGEP_Reactions")
   drgep *species_relations = new drgep();
   species_relations->drgep_0D_species(mixture, Targets, R_AD_Trajectories, n, time);

   if (step == "DRGEP_Reactions")
   drgep *species_relations = new drgep();
   species_relations->drgep_0D_species(mixture, Targets, R_AD_Trajectories, n, time);*/

   if (step == "DRGEP_Reactions")
   {
      int nsp = mixture->nSpecies();
      int nreac = mixture->nReactions();

      vector<vector<double> > rj_for_k (nsp, vector<double> (nreac,0.0));
      species_relations->drgep_0D_reactions(mixture, rj_for_k);

      for (int ka=0; ka<nsp; ka++)
      {
         for (int kb=0; kb<nsp; kb++)
         {
            for (int j=0; j<nreac; j++)
            {
               if (max_j_on_Target[ka][j] < R_AD_Trajectories[ka][kb]*rj_for_k[kb][j])
                  max_j_on_Target[ka][j] = R_AD_Trajectories[ka][kb]*rj_for_k[kb][j];
            }
         }
      }
   }

   delete mixture;
}

//Next_Time_Step without drgep analysis (to use for the computations with optimisation)
void computeMultipleInlet::Next_Time_Step(string mech, string mech_desc, double P, double *Ym, double &Hm, double &Tm, double delta_t)
{
   IdealGasMix *mixture = new IdealGasMix(mech, mech_desc);

   mixture->setMassFractions(Ym);
   mixture->setState_HP(Hm, P);

   ConstPressureReactor reac;
   reac.insert(*mixture);
   ReactorNet sim;
   sim.addReactor(reac);

 
//   cout << "68 " << sim.componentName(68) << endl;	// Huu-Tri Nguyen - To find out the stiff component that CVODE cannot find the time step to integrate >> Cantera error: Components with largest weighted error estimates: 48: -0.250213
//   cout << "71 " << sim.componentName(71) << endl;

   sim.advance(delta_t);

   // Function to get the internal step number during advance() - Huu-Tri@2020.09.15
   //int numStep = 0;
   //sim.getNumInternalStepReactor(numStep);
   //cout << "Internal step number = " << numStep << endl;

   Hm  = mixture->enthalpy_mass();
   Tm = mixture->temperature();
   mixture->getMassFractions(Ym);


   delete mixture;
}

//Next_Time_Step with QSS analysis 
void computeMultipleInlet::Next_Time_Step(string mech, string mech_desc, double P, double *Ym, double &Hm, double &Tm, double delta_t,
                    vector<vector<vector<double> > > &Production_Trajectories_ref, vector<vector<vector<double> > > &Consumption_Trajectories_ref, int nInlet, int nLine)
{
   IdealGasMix *mixture = new IdealGasMix(mech, mech_desc);
   mixture->setMassFractions(Ym);
   mixture->setState_HP(Hm, P);

   ConstPressureReactor reac;
   reac.insert(*mixture);
   ReactorNet sim;
   sim.addReactor(reac);

   sim.advance(delta_t);

   Hm  = mixture->enthalpy_mass();
   Tm = mixture->temperature();
   mixture->getMassFractions(Ym);

   int nreac = mixture->nReactions();
   int nsp = mixture->nSpecies();

   double* fwdRates = new double[nreac];
   double* revRates = new double[nreac];
   mixture->getFwdRatesOfProgress(fwdRates);
   mixture->getRevRatesOfProgress(revRates);

   for (int k=0; k<nsp; k++)
   {
      double omega_k_prod = 0.0;
      double omega_k_cons = 0.0;
      for (int j=0; j<nreac; j++)
      {
         omega_k_prod += mixture->productStoichCoeff(k,j)*fwdRates[j]
                        +mixture->reactantStoichCoeff(k,j)*revRates[j];
         omega_k_cons += mixture->reactantStoichCoeff(k,j)*fwdRates[j]
                        +mixture->productStoichCoeff(k,j)*revRates[j];
      }
      Production_Trajectories_ref[nInlet][nLine][k] = omega_k_prod;
      Consumption_Trajectories_ref[nInlet][nLine][k] = omega_k_cons;
   }
   delete mixture;
}


computeMultipleInlet::~computeMultipleInlet() //Destructeur
{}

